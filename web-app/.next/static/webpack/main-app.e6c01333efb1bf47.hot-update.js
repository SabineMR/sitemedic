"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("main-app",{

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/app-find-source-map-url.js":
/*!**********************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/app-find-source-map-url.js ***!
  \**********************************************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"findSourceMapURL\", ({\n    enumerable: true,\n    get: function() {\n        return findSourceMapURL;\n    }\n}));\nconst basePath =  false || '';\nconst pathname = \"\" + basePath + \"/__nextjs_source-map\";\nconst findSourceMapURL =  true ? function findSourceMapURL(filename) {\n    if (filename === '') {\n        return null;\n    }\n    if (filename.startsWith(document.location.origin) && filename.includes('/_next/static')) {\n        // This is a request for a client chunk. This can only happen when\n        // using Turbopack. In this case, since we control how those source\n        // maps are generated, we can safely assume that the sourceMappingURL\n        // is relative to the filename, with an added `.map` extension. The\n        // browser can just request this file, and it gets served through the\n        // normal dev server, without the need to route this through\n        // the `/__nextjs_source-map` dev middleware.\n        return \"\" + filename + \".map\";\n    }\n    const url = new URL(pathname, document.location.origin);\n    url.searchParams.set('filename', filename);\n    return url.href;\n} : 0;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-find-source-map-url.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE1LjUuMTJfcmVhY3QtZG9tQDE5LjIuNF9yZWFjdEAxOS4yLjRfX3JlYWN0QDE5LjIuNC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9hcHAtZmluZC1zb3VyY2UtbWFwLXVybC5qcyIsIm1hcHBpbmdzIjoiOzs7O29EQUdhQTs7O2VBQUFBOzs7QUFIYixNQUFNQyxXQUFXQyxNQUFrQyxJQUFJO0FBQ3ZELE1BQU1HLFdBQVksS0FBRUosV0FBUztBQUV0QixNQUFNRCxtQkFDWEUsS0FBb0IsR0FDaEIsU0FBU0YsaUJBQWlCTyxRQUFnQjtJQUN4QyxJQUFJQSxhQUFhLElBQUk7UUFDbkIsT0FBTztJQUNUO0lBRUEsSUFDRUEsU0FBU0MsVUFBVSxDQUFDQyxTQUFTQyxRQUFRLENBQUNDLE1BQU0sS0FDNUNKLFNBQVNLLFFBQVEsQ0FBQyxrQkFDbEI7UUFDQSxrRUFBa0U7UUFDbEUsbUVBQW1FO1FBQ25FLHFFQUFxRTtRQUNyRSxtRUFBbUU7UUFDbkUscUVBQXFFO1FBQ3JFLDREQUE0RDtRQUM1RCw2Q0FBNkM7UUFDN0MsT0FBUSxLQUFFTCxXQUFTO0lBQ3JCO0lBRUEsTUFBTU0sTUFBTSxJQUFJQyxJQUFJVCxVQUFVSSxTQUFTQyxRQUFRLENBQUNDLE1BQU07SUFDdERFLElBQUlFLFlBQVksQ0FBQ0MsR0FBRyxDQUFDLFlBQVlUO0lBRWpDLE9BQU9NLElBQUlJLElBQUk7QUFDakIsSUFDQUMsQ0FBU0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWJpbmVyZXNvYWdsaS9HaXRIdWIvc3JjL2NsaWVudC9hcHAtZmluZC1zb3VyY2UtbWFwLXVybC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBiYXNlUGF0aCA9IHByb2Nlc3MuZW52Ll9fTkVYVF9ST1VURVJfQkFTRVBBVEggfHwgJydcbmNvbnN0IHBhdGhuYW1lID0gYCR7YmFzZVBhdGh9L19fbmV4dGpzX3NvdXJjZS1tYXBgXG5cbmV4cG9ydCBjb25zdCBmaW5kU291cmNlTWFwVVJMID1cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCdcbiAgICA/IGZ1bmN0aW9uIGZpbmRTb3VyY2VNYXBVUkwoZmlsZW5hbWU6IHN0cmluZyk6IHN0cmluZyB8IG51bGwge1xuICAgICAgICBpZiAoZmlsZW5hbWUgPT09ICcnKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBmaWxlbmFtZS5zdGFydHNXaXRoKGRvY3VtZW50LmxvY2F0aW9uLm9yaWdpbikgJiZcbiAgICAgICAgICBmaWxlbmFtZS5pbmNsdWRlcygnL19uZXh0L3N0YXRpYycpXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgYSByZXF1ZXN0IGZvciBhIGNsaWVudCBjaHVuay4gVGhpcyBjYW4gb25seSBoYXBwZW4gd2hlblxuICAgICAgICAgIC8vIHVzaW5nIFR1cmJvcGFjay4gSW4gdGhpcyBjYXNlLCBzaW5jZSB3ZSBjb250cm9sIGhvdyB0aG9zZSBzb3VyY2VcbiAgICAgICAgICAvLyBtYXBzIGFyZSBnZW5lcmF0ZWQsIHdlIGNhbiBzYWZlbHkgYXNzdW1lIHRoYXQgdGhlIHNvdXJjZU1hcHBpbmdVUkxcbiAgICAgICAgICAvLyBpcyByZWxhdGl2ZSB0byB0aGUgZmlsZW5hbWUsIHdpdGggYW4gYWRkZWQgYC5tYXBgIGV4dGVuc2lvbi4gVGhlXG4gICAgICAgICAgLy8gYnJvd3NlciBjYW4ganVzdCByZXF1ZXN0IHRoaXMgZmlsZSwgYW5kIGl0IGdldHMgc2VydmVkIHRocm91Z2ggdGhlXG4gICAgICAgICAgLy8gbm9ybWFsIGRldiBzZXJ2ZXIsIHdpdGhvdXQgdGhlIG5lZWQgdG8gcm91dGUgdGhpcyB0aHJvdWdoXG4gICAgICAgICAgLy8gdGhlIGAvX19uZXh0anNfc291cmNlLW1hcGAgZGV2IG1pZGRsZXdhcmUuXG4gICAgICAgICAgcmV0dXJuIGAke2ZpbGVuYW1lfS5tYXBgXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHBhdGhuYW1lLCBkb2N1bWVudC5sb2NhdGlvbi5vcmlnaW4pXG4gICAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdmaWxlbmFtZScsIGZpbGVuYW1lKVxuXG4gICAgICAgIHJldHVybiB1cmwuaHJlZlxuICAgICAgfVxuICAgIDogdW5kZWZpbmVkXG4iXSwibmFtZXMiOlsiZmluZFNvdXJjZU1hcFVSTCIsImJhc2VQYXRoIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9ST1VURVJfQkFTRVBBVEgiLCJwYXRobmFtZSIsIk5PREVfRU5WIiwiZmlsZW5hbWUiLCJzdGFydHNXaXRoIiwiZG9jdW1lbnQiLCJsb2NhdGlvbiIsIm9yaWdpbiIsImluY2x1ZGVzIiwidXJsIiwiVVJMIiwic2VhcmNoUGFyYW1zIiwic2V0IiwiaHJlZiIsInVuZGVmaW5lZCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/app-find-source-map-url.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/app-index.js":
/*!********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/app-index.js ***!
  \********************************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"hydrate\", ({\n    enumerable: true,\n    get: function() {\n        return hydrate;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.15/node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.15/node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/compiled/react/jsx-runtime.js\");\n__webpack_require__(/*! ./app-globals */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/app-globals.js\");\nconst _client = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react-dom/client */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/compiled/react-dom/client.js\"));\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/compiled/react/index.js\"));\nconst _client1 = __webpack_require__(/*! react-server-dom-webpack/client */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/compiled/react-server-dom-webpack/client.browser.js\");\nconst _headmanagercontextsharedruntime = __webpack_require__(/*! ../shared/lib/head-manager-context.shared-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/shared/lib/head-manager-context.shared-runtime.js\");\nconst _onrecoverableerror = __webpack_require__(/*! ./react-client-callbacks/on-recoverable-error */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/react-client-callbacks/on-recoverable-error.js\");\nconst _errorboundarycallbacks = __webpack_require__(/*! ./react-client-callbacks/error-boundary-callbacks */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/react-client-callbacks/error-boundary-callbacks.js\");\nconst _appcallserver = __webpack_require__(/*! ./app-call-server */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/app-call-server.js\");\nconst _appfindsourcemapurl = __webpack_require__(/*! ./app-find-source-map-url */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/app-find-source-map-url.js\");\nconst _approuterinstance = __webpack_require__(/*! ./components/app-router-instance */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/app-router-instance.js\");\nconst _approuter = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./components/app-router */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/app-router.js\"));\nconst _createinitialrouterstate = __webpack_require__(/*! ./components/router-reducer/create-initial-router-state */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/router-reducer/create-initial-router-state.js\");\nconst _approutercontextsharedruntime = __webpack_require__(/*! ../shared/lib/app-router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\");\nconst _appbuildid = __webpack_require__(/*! ./app-build-id */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/app-build-id.js\");\n/// <reference types=\"react-dom/experimental\" />\nconst createFromReadableStream = _client1.createFromReadableStream;\nconst appElement = document;\nconst encoder = new TextEncoder();\nlet initialServerDataBuffer = undefined;\nlet initialServerDataWriter = undefined;\nlet initialServerDataLoaded = false;\nlet initialServerDataFlushed = false;\nlet initialFormStateData = null;\nfunction nextServerDataCallback(seg) {\n    if (seg[0] === 0) {\n        initialServerDataBuffer = [];\n    } else if (seg[0] === 1) {\n        if (!initialServerDataBuffer) throw Object.defineProperty(new Error('Unexpected server data: missing bootstrap script.'), \"__NEXT_ERROR_CODE\", {\n            value: \"E18\",\n            enumerable: false,\n            configurable: true\n        });\n        if (initialServerDataWriter) {\n            initialServerDataWriter.enqueue(encoder.encode(seg[1]));\n        } else {\n            initialServerDataBuffer.push(seg[1]);\n        }\n    } else if (seg[0] === 2) {\n        initialFormStateData = seg[1];\n    } else if (seg[0] === 3) {\n        if (!initialServerDataBuffer) throw Object.defineProperty(new Error('Unexpected server data: missing bootstrap script.'), \"__NEXT_ERROR_CODE\", {\n            value: \"E18\",\n            enumerable: false,\n            configurable: true\n        });\n        // Decode the base64 string back to binary data.\n        const binaryString = atob(seg[1]);\n        const decodedChunk = new Uint8Array(binaryString.length);\n        for(var i = 0; i < binaryString.length; i++){\n            decodedChunk[i] = binaryString.charCodeAt(i);\n        }\n        if (initialServerDataWriter) {\n            initialServerDataWriter.enqueue(decodedChunk);\n        } else {\n            initialServerDataBuffer.push(decodedChunk);\n        }\n    }\n}\nfunction isStreamErrorOrUnfinished(ctr) {\n    // If `desiredSize` is null, it means the stream is closed or errored. If it is lower than 0, the stream is still unfinished.\n    return ctr.desiredSize === null || ctr.desiredSize < 0;\n}\n// There might be race conditions between `nextServerDataRegisterWriter` and\n// `DOMContentLoaded`. The former will be called when React starts to hydrate\n// the root, the latter will be called when the DOM is fully loaded.\n// For streaming, the former is called first due to partial hydration.\n// For non-streaming, the latter can be called first.\n// Hence, we use two variables `initialServerDataLoaded` and\n// `initialServerDataFlushed` to make sure the writer will be closed and\n// `initialServerDataBuffer` will be cleared in the right time.\nfunction nextServerDataRegisterWriter(ctr) {\n    if (initialServerDataBuffer) {\n        initialServerDataBuffer.forEach((val)=>{\n            ctr.enqueue(typeof val === 'string' ? encoder.encode(val) : val);\n        });\n        if (initialServerDataLoaded && !initialServerDataFlushed) {\n            if (isStreamErrorOrUnfinished(ctr)) {\n                ctr.error(Object.defineProperty(new Error('The connection to the page was unexpectedly closed, possibly due to the stop button being clicked, loss of Wi-Fi, or an unstable internet connection.'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E117\",\n                    enumerable: false,\n                    configurable: true\n                }));\n            } else {\n                ctr.close();\n            }\n            initialServerDataFlushed = true;\n            initialServerDataBuffer = undefined;\n        }\n    }\n    initialServerDataWriter = ctr;\n}\n// When `DOMContentLoaded`, we can close all pending writers to finish hydration.\nconst DOMContentLoaded = function() {\n    if (initialServerDataWriter && !initialServerDataFlushed) {\n        initialServerDataWriter.close();\n        initialServerDataFlushed = true;\n        initialServerDataBuffer = undefined;\n    }\n    initialServerDataLoaded = true;\n};\n_c = DOMContentLoaded;\n// It's possible that the DOM is already loaded.\nif (document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', DOMContentLoaded, false);\n} else {\n    // Delayed in marco task to ensure it's executed later than hydration\n    setTimeout(DOMContentLoaded);\n}\nconst nextServerDataLoadingGlobal = self.__next_f = self.__next_f || [];\nnextServerDataLoadingGlobal.forEach(nextServerDataCallback);\nnextServerDataLoadingGlobal.push = nextServerDataCallback;\nconst readable = new ReadableStream({\n    start (controller) {\n        nextServerDataRegisterWriter(controller);\n    }\n});\nconst initialServerResponse = createFromReadableStream(readable, {\n    callServer: _appcallserver.callServer,\n    findSourceMapURL: _appfindsourcemapurl.findSourceMapURL\n});\nfunction ServerRoot(param) {\n    let { pendingActionQueue } = param;\n    const initialRSCPayload = (0, _react.use)(initialServerResponse);\n    const actionQueue = (0, _react.use)(pendingActionQueue);\n    const router = /*#__PURE__*/ (0, _jsxruntime.jsx)(_approuter.default, {\n        actionQueue: actionQueue,\n        globalErrorState: initialRSCPayload.G,\n        assetPrefix: initialRSCPayload.p\n    });\n    if ( true && initialRSCPayload.m) {\n        // We provide missing slot information in a context provider only during development\n        // as we log some additional information about the missing slots in the console.\n        return /*#__PURE__*/ (0, _jsxruntime.jsx)(_approutercontextsharedruntime.MissingSlotContext, {\n            value: initialRSCPayload.m,\n            children: router\n        });\n    }\n    return router;\n}\n_c1 = ServerRoot;\nconst StrictModeIfEnabled =  true ? _react.default.StrictMode : 0;\nfunction Root(param) {\n    let { children } = param;\n    if (false) {}\n    return children;\n}\n_c2 = Root;\nfunction onDefaultTransitionIndicator() {\n    // TODO: Compose default with user-configureable (e.g. nprogress)\n    // TODO: Use React's default once we figure out hanging indicators: https://codesandbox.io/p/sandbox/charming-moon-hktkp6?file=%2Fsrc%2Findex.js%3A106%2C30\n    return ()=>{};\n}\nconst reactRootOptions = {\n    onDefaultTransitionIndicator: onDefaultTransitionIndicator,\n    onRecoverableError: _onrecoverableerror.onRecoverableError,\n    onCaughtError: _errorboundarycallbacks.onCaughtError,\n    onUncaughtError: _errorboundarycallbacks.onUncaughtError\n};\nfunction hydrate(instrumentationHooks) {\n    // React overrides `.then` and doesn't return a new promise chain,\n    // so we wrap the action queue in a promise to ensure that its value\n    // is defined when the promise resolves.\n    // https://github.com/facebook/react/blob/163365a07872337e04826c4f501565d43dbd2fd4/packages/react-client/src/ReactFlightClient.js#L189-L190\n    const pendingActionQueue = new Promise((resolve, reject)=>{\n        initialServerResponse.then((initialRSCPayload)=>{\n            // setAppBuildId should be called only once, during JS initialization\n            // and before any components have hydrated.\n            (0, _appbuildid.setAppBuildId)(initialRSCPayload.b);\n            const initialTimestamp = Date.now();\n            resolve((0, _approuterinstance.createMutableActionQueue)((0, _createinitialrouterstate.createInitialRouterState)({\n                navigatedAt: initialTimestamp,\n                initialFlightData: initialRSCPayload.f,\n                initialCanonicalUrlParts: initialRSCPayload.c,\n                initialParallelRoutes: new Map(),\n                location: window.location,\n                couldBeIntercepted: initialRSCPayload.i,\n                postponed: initialRSCPayload.s,\n                prerendered: initialRSCPayload.S\n            }), instrumentationHooks));\n        }, (err)=>reject(err));\n    });\n    const reactEl = /*#__PURE__*/ (0, _jsxruntime.jsx)(StrictModeIfEnabled, {\n        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_headmanagercontextsharedruntime.HeadManagerContext.Provider, {\n            value: {\n                appDir: true\n            },\n            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(Root, {\n                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(ServerRoot, {\n                    pendingActionQueue: pendingActionQueue\n                })\n            })\n        })\n    });\n    if (document.documentElement.id === '__next_error__') {\n        let element = reactEl;\n        // Server rendering failed, fall back to client-side rendering\n        if (true) {\n            const { RootLevelDevOverlayElement } = __webpack_require__(/*! ../next-devtools/userspace/app/client-entry */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/next-devtools/userspace/app/client-entry.js\");\n            // Note this won't cause hydration mismatch because we are doing CSR w/o hydration\n            element = /*#__PURE__*/ (0, _jsxruntime.jsx)(RootLevelDevOverlayElement, {\n                children: element\n            });\n        }\n        _client.default.createRoot(appElement, reactRootOptions).render(element);\n    } else {\n        _react.default.startTransition(()=>{\n            _client.default.hydrateRoot(appElement, reactEl, {\n                ...reactRootOptions,\n                formState: initialFormStateData\n            });\n        });\n    }\n    // TODO-APP: Remove this logic when Float has GC built-in in development.\n    if (true) {\n        const { linkGc } = __webpack_require__(/*! ./app-link-gc */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/app-link-gc.js\");\n        linkGc();\n    }\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-index.js.map\nvar _c, _c1, _c2;\n$RefreshReg$(_c, \"DOMContentLoaded\");\n$RefreshReg$(_c1, \"ServerRoot\");\n$RefreshReg$(_c2, \"Root\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE1LjUuMTJfcmVhY3QtZG9tQDE5LjIuNF9yZWFjdEAxOS4yLjRfX3JlYWN0QDE5LjIuNC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9hcHAtaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7OzsyQ0FrT2dCQTs7O2VBQUFBOzs7Ozs7b0JBbE9UOzZFQUNvQjs2RUFDQTtxQ0FHaUQ7NkRBQ3pDO2dEQUNBO29EQUk1QjsyQ0FDb0I7aURBQ007K0NBSTFCO2dGQUNlO3NEQUVtQjsyREFDTjt3Q0FDTDtBQUU5QixnREFBZ0Q7QUFFaEQsTUFBTUMsMkJBQ0pDLFNBQUFBLHdCQUErQjtBQUVqQyxNQUFNQyxhQUFxQ0M7QUFFM0MsTUFBTUMsVUFBVSxJQUFJQztBQUVwQixJQUFJQywwQkFBK0RDO0FBQ25FLElBQUlDLDBCQUNGRDtBQUNGLElBQUlFLDBCQUEwQjtBQUM5QixJQUFJQywyQkFBMkI7QUFFL0IsSUFBSUMsdUJBQW1DO0FBbUJ2QyxTQUFTQyx1QkFBdUJDLEdBQWtCO0lBQ2hELElBQUlBLEdBQUcsQ0FBQyxFQUFFLEtBQUssR0FBRztRQUNoQlAsMEJBQTBCLEVBQUU7SUFDOUIsT0FBTyxJQUFJTyxHQUFHLENBQUMsRUFBRSxLQUFLLEdBQUc7UUFDdkIsSUFBSSxDQUFDUCx5QkFDSCxNQUFNLHFCQUE4RCxDQUE5RCxJQUFJUSxNQUFNLHNEQUFWO21CQUFBO3dCQUFBOzBCQUFBO1FBQTZEO1FBRXJFLElBQUlOLHlCQUF5QjtZQUMzQkEsd0JBQXdCTyxPQUFPLENBQUNYLFFBQVFZLE1BQU0sQ0FBQ0gsR0FBRyxDQUFDLEVBQUU7UUFDdkQsT0FBTztZQUNMUCx3QkFBd0JXLElBQUksQ0FBQ0osR0FBRyxDQUFDLEVBQUU7UUFDckM7SUFDRixPQUFPLElBQUlBLEdBQUcsQ0FBQyxFQUFFLEtBQUssR0FBRztRQUN2QkYsdUJBQXVCRSxHQUFHLENBQUMsRUFBRTtJQUMvQixPQUFPLElB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QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL3NhYmluZXJlc29hZ2xpL0dpdEh1Yi9zcmMvY2xpZW50L2FwcC1pbmRleC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICcuL2FwcC1nbG9iYWxzJ1xuaW1wb3J0IFJlYWN0RE9NQ2xpZW50IGZyb20gJ3JlYWN0LWRvbS9jbGllbnQnXG5pbXBvcnQgUmVhY3QsIHsgdXNlIH0gZnJvbSAncmVhY3QnXG4vLyBUT0RPOiBFeHBsaWNpdGx5IGltcG9ydCBmcm9tIGNsaWVudC5icm93c2VyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLWV4dHJhbmVvdXMtZGVwZW5kZW5jaWVzXG5pbXBvcnQgeyBjcmVhdGVGcm9tUmVhZGFibGVTdHJlYW0gYXMgY3JlYXRlRnJvbVJlYWRhYmxlU3RyZWFtQnJvd3NlciB9IGZyb20gJ3JlYWN0LXNlcnZlci1kb20td2VicGFjay9jbGllbnQnXG5pbXBvcnQgeyBIZWFkTWFuYWdlckNvbnRleHQgfSBmcm9tICcuLi9zaGFyZWQvbGliL2hlYWQtbWFuYWdlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHsgb25SZWNvdmVyYWJsZUVycm9yIH0gZnJvbSAnLi9yZWFjdC1jbGllbnQtY2FsbGJhY2tzL29uLXJlY292ZXJhYmxlLWVycm9yJ1xuaW1wb3J0IHtcbiAgb25DYXVnaHRFcnJvcixcbiAgb25VbmNhdWdodEVycm9yLFxufSBmcm9tICcuL3JlYWN0LWNsaWVudC1jYWxsYmFja3MvZXJyb3ItYm91bmRhcnktY2FsbGJhY2tzJ1xuaW1wb3J0IHsgY2FsbFNlcnZlciB9IGZyb20gJy4vYXBwLWNhbGwtc2VydmVyJ1xuaW1wb3J0IHsgZmluZFNvdXJjZU1hcFVSTCB9IGZyb20gJy4vYXBwLWZpbmQtc291cmNlLW1hcC11cmwnXG5pbXBvcnQge1xuICB0eXBlIEFwcFJvdXRlckFjdGlvblF1ZXVlLFxuICBjcmVhdGVNdXRhYmxlQWN0aW9uUXVldWUsXG59IGZyb20gJy4vY29tcG9uZW50cy9hcHAtcm91dGVyLWluc3RhbmNlJ1xuaW1wb3J0IEFwcFJvdXRlciBmcm9tICcuL2NvbXBvbmVudHMvYXBwLXJvdXRlcidcbmltcG9ydCB0eXBlIHsgSW5pdGlhbFJTQ1BheWxvYWQgfSBmcm9tICcuLi9zZXJ2ZXIvYXBwLXJlbmRlci90eXBlcydcbmltcG9ydCB7IGNyZWF0ZUluaXRpYWxSb3V0ZXJTdGF0ZSB9IGZyb20gJy4vY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9jcmVhdGUtaW5pdGlhbC1yb3V0ZXItc3RhdGUnXG5pbXBvcnQgeyBNaXNzaW5nU2xvdENvbnRleHQgfSBmcm9tICcuLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB7IHNldEFwcEJ1aWxkSWQgfSBmcm9tICcuL2FwcC1idWlsZC1pZCdcblxuLy8vIDxyZWZlcmVuY2UgdHlwZXM9XCJyZWFjdC1kb20vZXhwZXJpbWVudGFsXCIgLz5cblxuY29uc3QgY3JlYXRlRnJvbVJlYWRhYmxlU3RyZWFtID1cbiAgY3JlYXRlRnJvbVJlYWRhYmxlU3RyZWFtQnJvd3NlciBhcyAodHlwZW9mIGltcG9ydCgncmVhY3Qtc2VydmVyLWRvbS13ZWJwYWNrL2NsaWVudC5icm93c2VyJykpWydjcmVhdGVGcm9tUmVhZGFibGVTdHJlYW0nXVxuXG5jb25zdCBhcHBFbGVtZW50OiBIVE1MRWxlbWVudCB8IERvY3VtZW50ID0gZG9jdW1lbnRcblxuY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpXG5cbmxldCBpbml0aWFsU2VydmVyRGF0YUJ1ZmZlcjogKHN0cmluZyB8IFVpbnQ4QXJyYXkpW10gfCB1bmRlZmluZWQgPSB1bmRlZmluZWRcbmxldCBpbml0aWFsU2VydmVyRGF0YVdyaXRlcjogUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlciB8IHVuZGVmaW5lZCA9XG4gIHVuZGVmaW5lZFxubGV0IGluaXRpYWxTZXJ2ZXJEYXRhTG9hZGVkID0gZmFsc2VcbmxldCBpbml0aWFsU2VydmVyRGF0YUZsdXNoZWQgPSBmYWxzZVxuXG5sZXQgaW5pdGlhbEZvcm1TdGF0ZURhdGE6IG51bGwgfCBhbnkgPSBudWxsXG5cbnR5cGUgRmxpZ2h0U2VnbWVudCA9XG4gIHwgW2lzQm9vdFN0cmFwOiAwXVxuICB8IFtpc05vdEJvb3RzdHJhcDogMSwgcmVzcG9uc2VQYXJ0aWFsOiBzdHJpbmddXG4gIHwgW2lzRm9ybVN0YXRlOiAyLCBmb3JtU3RhdGU6IGFueV1cbiAgfCBbaXNCaW5hcnk6IDMsIHJlc3BvbnNlQmFzZTY0UGFydGlhbDogc3RyaW5nXVxuXG50eXBlIE5leHRGbGlnaHQgPSBPbWl0PEFycmF5PEZsaWdodFNlZ21lbnQ+LCAncHVzaCc+ICYge1xuICBwdXNoOiAoc2VnOiBGbGlnaHRTZWdtZW50KSA9PiB2b2lkXG59XG5cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgLy8gSWYgeW91J3JlIHdvcmtpbmcgaW4gYSBicm93c2VyIGVudmlyb25tZW50XG4gIGludGVyZmFjZSBXaW5kb3cge1xuICAgIF9fbmV4dF9mOiBOZXh0RmxpZ2h0XG4gIH1cbn1cblxuZnVuY3Rpb24gbmV4dFNlcnZlckRhdGFDYWxsYmFjayhzZWc6IEZsaWdodFNlZ21lbnQpOiB2b2lkIHtcbiAgaWYgKHNlZ1swXSA9PT0gMCkge1xuICAgIGluaXRpYWxTZXJ2ZXJEYXRhQnVmZmVyID0gW11cbiAgfSBlbHNlIGlmIChzZWdbMF0gPT09IDEpIHtcbiAgICBpZiAoIWluaXRpYWxTZXJ2ZXJEYXRhQnVmZmVyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHNlcnZlciBkYXRhOiBtaXNzaW5nIGJvb3RzdHJhcCBzY3JpcHQuJylcblxuICAgIGlmIChpbml0aWFsU2VydmVyRGF0YVdyaXRlcikge1xuICAgICAgaW5pdGlhbFNlcnZlckRhdGFXcml0ZXIuZW5xdWV1ZShlbmNvZGVyLmVuY29kZShzZWdbMV0pKVxuICAgIH0gZWxzZSB7XG4gICAgICBpbml0aWFsU2VydmVyRGF0YUJ1ZmZlci5wdXNoKHNlZ1sxXSlcbiAgICB9XG4gIH0gZWxzZSBpZiAoc2VnWzBdID09PSAyKSB7XG4gICAgaW5pdGlhbEZvcm1TdGF0ZURhdGEgPSBzZWdbMV1cbiAgfSBlbHNlIGlmIChzZWdbMF0gPT09IDMpIHtcbiAgICBpZiAoIWluaXRpYWxTZXJ2ZXJEYXRhQnVmZmVyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHNlcnZlciBkYXRhOiBtaXNzaW5nIGJvb3RzdHJhcCBzY3JpcHQuJylcblxuICAgIC8vIERlY29kZSB0aGUgYmFzZTY0IHN0cmluZyBiYWNrIHRvIGJpbmFyeSBkYXRhLlxuICAgIGNvbnN0IGJpbmFyeVN0cmluZyA9IGF0b2Ioc2VnWzFdKVxuICAgIGNvbnN0IGRlY29kZWRDaHVuayA9IG5ldyBVaW50OEFycmF5KGJpbmFyeVN0cmluZy5sZW5ndGgpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiaW5hcnlTdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlY29kZWRDaHVua1tpXSA9IGJpbmFyeVN0cmluZy5jaGFyQ29kZUF0KGkpXG4gICAgfVxuXG4gICAgaWYgKGluaXRpYWxTZXJ2ZXJEYXRhV3JpdGVyKSB7XG4gICAgICBpbml0aWFsU2VydmVyRGF0YVdyaXRlci5lbnF1ZXVlKGRlY29kZWRDaHVuaylcbiAgICB9IGVsc2Uge1xuICAgICAgaW5pdGlhbFNlcnZlckRhdGFCdWZmZXIucHVzaChkZWNvZGVkQ2h1bmspXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzU3RyZWFtRXJyb3JPclVuZmluaXNoZWQoY3RyOiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKSB7XG4gIC8vIElmIGBkZXNpcmVkU2l6ZWAgaXMgbnVsbCwgaXQgbWVhbnMgdGhlIHN0cmVhbSBpcyBjbG9zZWQgb3IgZXJyb3JlZC4gSWYgaXQgaXMgbG93ZXIgdGhhbiAwLCB0aGUgc3RyZWFtIGlzIHN0aWxsIHVuZmluaXNoZWQuXG4gIHJldHVybiBjdHIuZGVzaXJlZFNpemUgPT09IG51bGwgfHwgY3RyLmRlc2lyZWRTaXplIDwgMFxufVxuXG4vLyBUaGVyZSBtaWdodCBiZSByYWNlIGNvbmRpdGlvbnMgYmV0d2VlbiBgbmV4dFNlcnZlckRhdGFSZWdpc3RlcldyaXRlcmAgYW5kXG4vLyBgRE9NQ29udGVudExvYWRlZGAuIFRoZSBmb3JtZXIgd2lsbCBiZSBjYWxsZWQgd2hlbiBSZWFjdCBzdGFydHMgdG8gaHlkcmF0ZVxuLy8gdGhlIHJvb3QsIHRoZSBsYXR0ZXIgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgRE9NIGlzIGZ1bGx5IGxvYWRlZC5cbi8vIEZvciBzdHJlYW1pbmcsIHRoZSBmb3JtZXIgaXMgY2FsbGVkIGZpcnN0IGR1ZSB0byBwYXJ0aWFsIGh5ZHJhdGlvbi5cbi8vIEZvciBub24tc3RyZWFtaW5nLCB0aGUgbGF0dGVyIGNhbiBiZSBjYWxsZWQgZmlyc3QuXG4vLyBIZW5jZSwgd2UgdXNlIHR3byB2YXJpYWJsZXMgYGluaXRpYWxTZXJ2ZXJEYXRhTG9hZGVkYCBhbmRcbi8vIGBpbml0aWFsU2VydmVyRGF0YUZsdXNoZWRgIHRvIG1ha2Ugc3VyZSB0aGUgd3JpdGVyIHdpbGwgYmUgY2xvc2VkIGFuZFxuLy8gYGluaXRpYWxTZXJ2ZXJEYXRhQnVmZmVyYCB3aWxsIGJlIGNsZWFyZWQgaW4gdGhlIHJpZ2h0IHRpbWUuXG5mdW5jdGlvbiBuZXh0U2VydmVyRGF0YVJlZ2lzdGVyV3JpdGVyKGN0cjogUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcikge1xuICBpZiAoaW5pdGlhbFNlcnZlckRhdGFCdWZmZXIpIHtcbiAgICBpbml0aWFsU2VydmVyRGF0YUJ1ZmZlci5mb3JFYWNoKCh2YWwpID0+IHtcbiAgICAgIGN0ci5lbnF1ZXVlKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnID8gZW5jb2Rlci5lbmNvZGUodmFsKSA6IHZhbClcbiAgICB9KVxuICAgIGlmIChpbml0aWFsU2VydmVyRGF0YUxvYWRlZCAmJiAhaW5pdGlhbFNlcnZlckRhdGFGbHVzaGVkKSB7XG4gICAgICBpZiAoaXNTdHJlYW1FcnJvck9yVW5maW5pc2hlZChjdHIpKSB7XG4gICAgICAgIGN0ci5lcnJvcihcbiAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnVGhlIGNvbm5lY3Rpb24gdG8gdGhlIHBhZ2Ugd2FzIHVuZXhwZWN0ZWRseSBjbG9zZWQsIHBvc3NpYmx5IGR1ZSB0byB0aGUgc3RvcCBidXR0b24gYmVpbmcgY2xpY2tlZCwgbG9zcyBvZiBXaS1GaSwgb3IgYW4gdW5zdGFibGUgaW50ZXJuZXQgY29ubmVjdGlvbi4nXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHIuY2xvc2UoKVxuICAgICAgfVxuICAgICAgaW5pdGlhbFNlcnZlckRhdGFGbHVzaGVkID0gdHJ1ZVxuICAgICAgaW5pdGlhbFNlcnZlckRhdGFCdWZmZXIgPSB1bmRlZmluZWRcbiAgICB9XG4gIH1cblxuICBpbml0aWFsU2VydmVyRGF0YVdyaXRlciA9IGN0clxufVxuXG4vLyBXaGVuIGBET01Db250ZW50TG9hZGVkYCwgd2UgY2FuIGNsb3NlIGFsbCBwZW5kaW5nIHdyaXRlcnMgdG8gZmluaXNoIGh5ZHJhdGlvbi5cbmNvbnN0IERPTUNvbnRlbnRMb2FkZWQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChpbml0aWFsU2VydmVyRGF0YVdyaXRlciAmJiAhaW5pdGlhbFNlcnZlckRhdGFGbHVzaGVkKSB7XG4gICAgaW5pdGlhbFNlcnZlckRhdGFXcml0ZXIuY2xvc2UoKVxuICAgIGluaXRpYWxTZXJ2ZXJEYXRhRmx1c2hlZCA9IHRydWVcbiAgICBpbml0aWFsU2VydmVyRGF0YUJ1ZmZlciA9IHVuZGVmaW5lZFxuICB9XG4gIGluaXRpYWxTZXJ2ZXJEYXRhTG9hZGVkID0gdHJ1ZVxufVxuXG4vLyBJdCdzIHBvc3NpYmxlIHRoYXQgdGhlIERPTSBpcyBhbHJlYWR5IGxvYWRlZC5cbmlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnbG9hZGluZycpIHtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIERPTUNvbnRlbnRMb2FkZWQsIGZhbHNlKVxufSBlbHNlIHtcbiAgLy8gRGVsYXllZCBpbiBtYXJjbyB0YXNrIHRvIGVuc3VyZSBpdCdzIGV4ZWN1dGVkIGxhdGVyIHRoYW4gaHlkcmF0aW9uXG4gIHNldFRpbWVvdXQoRE9NQ29udGVudExvYWRlZClcbn1cblxuY29uc3QgbmV4dFNlcnZlckRhdGFMb2FkaW5nR2xvYmFsID0gKHNlbGYuX19uZXh0X2YgPSBzZWxmLl9fbmV4dF9mIHx8IFtdKVxubmV4dFNlcnZlckRhdGFMb2FkaW5nR2xvYmFsLmZvckVhY2gobmV4dFNlcnZlckRhdGFDYWxsYmFjaylcbm5leHRTZXJ2ZXJEYXRhTG9hZGluZ0dsb2JhbC5wdXNoID0gbmV4dFNlcnZlckRhdGFDYWxsYmFja1xuXG5jb25zdCByZWFkYWJsZSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICBuZXh0U2VydmVyRGF0YVJlZ2lzdGVyV3JpdGVyKGNvbnRyb2xsZXIpXG4gIH0sXG59KVxuXG5jb25zdCBpbml0aWFsU2VydmVyUmVzcG9uc2UgPSBjcmVhdGVGcm9tUmVhZGFibGVTdHJlYW08SW5pdGlhbFJTQ1BheWxvYWQ+KFxuICByZWFkYWJsZSxcbiAgeyBjYWxsU2VydmVyLCBmaW5kU291cmNlTWFwVVJMIH1cbilcblxuZnVuY3Rpb24gU2VydmVyUm9vdCh7XG4gIHBlbmRpbmdBY3Rpb25RdWV1ZSxcbn06IHtcbiAgcGVuZGluZ0FjdGlvblF1ZXVlOiBQcm9taXNlPEFwcFJvdXRlckFjdGlvblF1ZXVlPlxufSk6IFJlYWN0LlJlYWN0Tm9kZSB7XG4gIGNvbnN0IGluaXRpYWxSU0NQYXlsb2FkID0gdXNlKGluaXRpYWxTZXJ2ZXJSZXNwb25zZSlcbiAgY29uc3QgYWN0aW9uUXVldWUgPSB1c2U8QXBwUm91dGVyQWN0aW9uUXVldWU+KHBlbmRpbmdBY3Rpb25RdWV1ZSlcblxuICBjb25zdCByb3V0ZXIgPSAoXG4gICAgPEFwcFJvdXRlclxuICAgICAgYWN0aW9uUXVldWU9e2FjdGlvblF1ZXVlfVxuICAgICAgZ2xvYmFsRXJyb3JTdGF0ZT17aW5pdGlhbFJTQ1BheWxvYWQuR31cbiAgICAgIGFzc2V0UHJlZml4PXtpbml0aWFsUlNDUGF5bG9hZC5wfVxuICAgIC8+XG4gIClcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgaW5pdGlhbFJTQ1BheWxvYWQubSkge1xuICAgIC8vIFdlIHByb3ZpZGUgbWlzc2luZyBzbG90IGluZm9ybWF0aW9uIGluIGEgY29udGV4dCBwcm92aWRlciBvbmx5IGR1cmluZyBkZXZlbG9wbWVudFxuICAgIC8vIGFzIHdlIGxvZyBzb21lIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG1pc3Npbmcgc2xvdHMgaW4gdGhlIGNvbnNvbGUuXG4gICAgcmV0dXJuIChcbiAgICAgIDxNaXNzaW5nU2xvdENvbnRleHQgdmFsdWU9e2luaXRpYWxSU0NQYXlsb2FkLm19PlxuICAgICAgICB7cm91dGVyfVxuICAgICAgPC9NaXNzaW5nU2xvdENvbnRleHQ+XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHJvdXRlclxufVxuXG5jb25zdCBTdHJpY3RNb2RlSWZFbmFibGVkID0gcHJvY2Vzcy5lbnYuX19ORVhUX1NUUklDVF9NT0RFX0FQUFxuICA/IFJlYWN0LlN0cmljdE1vZGVcbiAgOiBSZWFjdC5GcmFnbWVudFxuXG5mdW5jdGlvbiBSb290KHsgY2hpbGRyZW4gfTogUmVhY3QuUHJvcHNXaXRoQ2hpbGRyZW48e30+KSB7XG4gIGlmIChwcm9jZXNzLmVudi5fX05FWFRfVEVTVF9NT0RFKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIHdpbmRvdy5fX05FWFRfSFlEUkFURUQgPSB0cnVlXG4gICAgICB3aW5kb3cuX19ORVhUX0hZRFJBVEVEX0FUID0gcGVyZm9ybWFuY2Uubm93KClcbiAgICAgIHdpbmRvdy5fX05FWFRfSFlEUkFURURfQ0I/LigpXG4gICAgfSwgW10pXG4gIH1cblxuICByZXR1cm4gY2hpbGRyZW5cbn1cblxuZnVuY3Rpb24gb25EZWZhdWx0VHJhbnNpdGlvbkluZGljYXRvcigpIHtcbiAgLy8gVE9ETzogQ29tcG9zZSBkZWZhdWx0IHdpdGggdXNlci1jb25maWd1cmVhYmxlIChlLmcuIG5wcm9ncmVzcylcbiAgLy8gVE9ETzogVXNlIFJlYWN0J3MgZGVmYXVsdCBvbmNlIHdlIGZpZ3VyZSBvdXQgaGFuZ2luZyBpbmRpY2F0b3JzOiBodHRwczovL2NvZGVzYW5kYm94LmlvL3Avc2FuZGJveC9jaGFybWluZy1tb29uLWhrdGtwNj9maWxlPSUyRnNyYyUyRmluZGV4LmpzJTNBMTA2JTJDMzBcbiAgcmV0dXJuICgpID0+IHt9XG59XG5cbmNvbnN0IHJlYWN0Um9vdE9wdGlvbnM6IFJlYWN0RE9NQ2xpZW50LlJvb3RPcHRpb25zID0ge1xuICBvbkRlZmF1bHRUcmFuc2l0aW9uSW5kaWNhdG9yOiBvbkRlZmF1bHRUcmFuc2l0aW9uSW5kaWNhdG9yLFxuICBvblJlY292ZXJhYmxlRXJyb3IsXG4gIG9uQ2F1Z2h0RXJyb3IsXG4gIG9uVW5jYXVnaHRFcnJvcixcbn1cblxuZXhwb3J0IHR5cGUgQ2xpZW50SW5zdHJ1bWVudGF0aW9uSG9va3MgPSB7XG4gIG9uUm91dGVyVHJhbnNpdGlvblN0YXJ0PzogKFxuICAgIHVybDogc3RyaW5nLFxuICAgIG5hdmlnYXRpb25UeXBlOiAncHVzaCcgfCAncmVwbGFjZScgfCAndHJhdmVyc2UnXG4gICkgPT4gdm9pZFxufVxuXG5leHBvcnQgZnVuY3Rpb24gaHlkcmF0ZShcbiAgaW5zdHJ1bWVudGF0aW9uSG9va3M6IENsaWVudEluc3RydW1lbnRhdGlvbkhvb2tzIHwgbnVsbFxuKSB7XG4gIC8vIFJlYWN0IG92ZXJyaWRlcyBgLnRoZW5gIGFuZCBkb2Vzbid0IHJldHVybiBhIG5ldyBwcm9taXNlIGNoYWluLFxuICAvLyBzbyB3ZSB3cmFwIHRoZSBhY3Rpb24gcXVldWUgaW4gYSBwcm9taXNlIHRvIGVuc3VyZSB0aGF0IGl0cyB2YWx1ZVxuICAvLyBpcyBkZWZpbmVkIHdoZW4gdGhlIHByb21pc2UgcmVzb2x2ZXMuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9ibG9iLzE2MzM2NWEwNzg3MjMzN2UwNDgyNmM0ZjUwMTU2NWQ0M2RiZDJmZDQvcGFja2FnZXMvcmVhY3QtY2xpZW50L3NyYy9SZWFjdEZsaWdodENsaWVudC5qcyNMMTg5LUwxOTBcbiAgY29uc3QgcGVuZGluZ0FjdGlvblF1ZXVlOiBQcm9taXNlPEFwcFJvdXRlckFjdGlvblF1ZXVlPiA9IG5ldyBQcm9taXNlKFxuICAgIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGluaXRpYWxTZXJ2ZXJSZXNwb25zZS50aGVuKFxuICAgICAgICAoaW5pdGlhbFJTQ1BheWxvYWQpID0+IHtcbiAgICAgICAgICAvLyBzZXRBcHBCdWlsZElkIHNob3VsZCBiZSBjYWxsZWQgb25seSBvbmNlLCBkdXJpbmcgSlMgaW5pdGlhbGl6YXRpb25cbiAgICAgICAgICAvLyBhbmQgYmVmb3JlIGFueSBjb21wb25lbnRzIGhhdmUgaHlkcmF0ZWQuXG4gICAgICAgICAgc2V0QXBwQnVpbGRJZChpbml0aWFsUlNDUGF5bG9hZC5iKVxuXG4gICAgICAgICAgY29uc3QgaW5pdGlhbFRpbWVzdGFtcCA9IERhdGUubm93KClcblxuICAgICAgICAgIHJlc29sdmUoXG4gICAgICAgICAgICBjcmVhdGVNdXRhYmxlQWN0aW9uUXVldWUoXG4gICAgICAgICAgICAgIGNyZWF0ZUluaXRpYWxSb3V0ZXJTdGF0ZSh7XG4gICAgICAgICAgICAgICAgbmF2aWdhdGVkQXQ6IGluaXRpYWxUaW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgaW5pdGlhbEZsaWdodERhdGE6IGluaXRpYWxSU0NQYXlsb2FkLmYsXG4gICAgICAgICAgICAgICAgaW5pdGlhbENhbm9uaWNhbFVybFBhcnRzOiBpbml0aWFsUlNDUGF5bG9hZC5jLFxuICAgICAgICAgICAgICAgIGluaXRpYWxQYXJhbGxlbFJvdXRlczogbmV3IE1hcCgpLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB3aW5kb3cubG9jYXRpb24sXG4gICAgICAgICAgICAgICAgY291bGRCZUludGVyY2VwdGVkOiBpbml0aWFsUlNDUGF5bG9hZC5pLFxuICAgICAgICAgICAgICAgIHBvc3Rwb25lZDogaW5pdGlhbFJTQ1BheWxvYWQucyxcbiAgICAgICAgICAgICAgICBwcmVyZW5kZXJlZDogaW5pdGlhbFJTQ1BheWxvYWQuUyxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIGluc3RydW1lbnRhdGlvbkhvb2tzXG4gICAgICAgICAgICApXG4gICAgICAgICAgKVxuICAgICAgICB9LFxuICAgICAgICAoZXJyOiBFcnJvcikgPT4gcmVqZWN0KGVycilcbiAgICAgIClcbiAgICB9XG4gIClcblxuICBjb25zdCByZWFjdEVsID0gKFxuICAgIDxTdHJpY3RNb2RlSWZFbmFibGVkPlxuICAgICAgPEhlYWRNYW5hZ2VyQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17eyBhcHBEaXI6IHRydWUgfX0+XG4gICAgICAgIDxSb290PlxuICAgICAgICAgIDxTZXJ2ZXJSb290IHBlbmRpbmdBY3Rpb25RdWV1ZT17cGVuZGluZ0FjdGlvblF1ZXVlfSAvPlxuICAgICAgICA8L1Jvb3Q+XG4gICAgICA8L0hlYWRNYW5hZ2VyQ29udGV4dC5Qcm92aWRlcj5cbiAgICA8L1N0cmljdE1vZGVJZkVuYWJsZWQ+XG4gIClcblxuICBpZiAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmlkID09PSAnX19uZXh0X2Vycm9yX18nKSB7XG4gICAgbGV0IGVsZW1lbnQgPSByZWFjdEVsXG4gICAgLy8gU2VydmVyIHJlbmRlcmluZyBmYWlsZWQsIGZhbGwgYmFjayB0byBjbGllbnQtc2lkZSByZW5kZXJpbmdcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgY29uc3QgeyBSb290TGV2ZWxEZXZPdmVybGF5RWxlbWVudCB9ID1cbiAgICAgICAgcmVxdWlyZSgnLi4vbmV4dC1kZXZ0b29scy91c2Vyc3BhY2UvYXBwL2NsaWVudC1lbnRyeScpIGFzIHR5cGVvZiBpbXBvcnQoJy4uL25leHQtZGV2dG9vbHMvdXNlcnNwYWNlL2FwcC9jbGllbnQtZW50cnknKVxuXG4gICAgICAvLyBOb3RlIHRoaXMgd29uJ3QgY2F1c2UgaHlkcmF0aW9uIG1pc21hdGNoIGJlY2F1c2Ugd2UgYXJlIGRvaW5nIENTUiB3L28gaHlkcmF0aW9uXG4gICAgICBlbGVtZW50ID0gKFxuICAgICAgICA8Um9vdExldmVsRGV2T3ZlcmxheUVsZW1lbnQ+e2VsZW1lbnR9PC9Sb290TGV2ZWxEZXZPdmVybGF5RWxlbWVudD5cbiAgICAgIClcbiAgICB9XG5cbiAgICBSZWFjdERPTUNsaWVudC5jcmVhdGVSb290KGFwcEVsZW1lbnQsIHJlYWN0Um9vdE9wdGlvbnMpLnJlbmRlcihlbGVtZW50KVxuICB9IGVsc2Uge1xuICAgIFJlYWN0LnN0YXJ0VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICBSZWFjdERPTUNsaWVudC5oeWRyYXRlUm9vdChhcHBFbGVtZW50LCByZWFjdEVsLCB7XG4gICAgICAgIC4uLnJlYWN0Um9vdE9wdGlvbnMsXG4gICAgICAgIGZvcm1TdGF0ZTogaW5pdGlhbEZvcm1TdGF0ZURhdGEsXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICAvLyBUT0RPLUFQUDogUmVtb3ZlIHRoaXMgbG9naWMgd2hlbiBGbG9hdCBoYXMgR0MgYnVpbHQtaW4gaW4gZGV2ZWxvcG1lbnQuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY29uc3QgeyBsaW5rR2MgfSA9XG4gICAgICByZXF1aXJlKCcuL2FwcC1saW5rLWdjJykgYXMgdHlwZW9mIGltcG9ydCgnLi9hcHAtbGluay1nYycpXG4gICAgbGlua0djKClcbiAgfVxufVxuIl0sIm5hbWVzIjpbImh5ZHJhdGUiLCJjcmVhdGVGcm9tUmVhZGFibGVTdHJlYW0iLCJjcmVhdGVGcm9tUmVhZGFibGVTdHJlYW1Ccm93c2VyIiwiYXBwRWxlbWVudCIsImRvY3VtZW50IiwiZW5jb2RlciIsIlRleHRFbmNvZGVyIiwiaW5pdGlhbFNlcnZlckRhdGFCdWZmZXIiLCJ1bmRlZmluZWQiLCJpbml0aWFsU2VydmVyRGF0YVdyaXRlciIsImluaXRpYWxTZXJ2ZXJEYXRhTG9hZGVkIiwiaW5pdGlhbFNlcnZlckRhdGFGbHVzaGVkIiwiaW5pdGlhbEZvcm1TdGF0ZURhdGEiLCJuZXh0U2VydmVyRGF0YUNhbGxiYWNrIiwic2VnIiwiRXJyb3IiLCJlbnF1ZXVlIiwiZW5jb2RlIiwicHVzaCIsImJpbmFyeVN0cmluZyIsImF0b2IiLCJkZWNvZGVkQ2h1bmsiLCJVaW50OEFycmF5IiwibGVuZ3RoIiwiaSIsImNoYXJDb2RlQXQiLCJpc1N0cmVhbUVycm9yT3JVbmZpbmlzaGVkIiwiY3RyIiwiZGVzaXJlZFNpemUiLCJuZXh0U2VydmVyRGF0YVJlZ2lzdGVyV3JpdGVyIiwiZm9yRWFjaCIsInZhbCIsImVycm9yIiwiY2xvc2UiLCJET01Db250ZW50TG9hZGVkIiwicmVhZHlTdGF0ZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJzZXRUaW1lb3V0IiwibmV4dFNlcnZlckRhdGFMb2FkaW5nR2xvYmFsIiwic2VsZiIsIl9fbmV4dF9mIiwicmVhZGFibGUiLCJSZWFkYWJsZVN0cmVhbSIsInN0YXJ0IiwiY29udHJvbGxlciIsImluaXRpYWxTZXJ2ZXJSZXNwb25zZSIsImNhbGxTZXJ2ZXIiLCJmaW5kU291cmNlTWFwVVJMIiwiU2VydmVyUm9vdCIsInBlbmRpbmdBY3Rpb25RdWV1ZSIsImluaXRpYWxSU0NQYXlsb2FkIiwidXNlIiwiYWN0aW9uUXVldWUiLCJyb3V0ZXIiLCJBcHBSb3V0ZXIiLCJnbG9iYWxFcnJvclN0YXRlIiwiRyIsImFzc2V0UHJlZml4IiwicCIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsIm0iLCJNaXNzaW5nU2xvdENvbnRleHQiLCJ2YWx1ZSIsIlN0cmljdE1vZGVJZkVuYWJsZWQiLCJfX05FWFRfU1RSSUNUX01PREVfQVBQIiwiUmVhY3QiLCJTdHJpY3RNb2RlIiwiRnJhZ21lbnQiLCJSb290IiwiY2hpbGRyZW4iLCJfX05FWFRfVEVTVF9NT0RFIiwidXNlRWZmZWN0Iiwid2luZG93IiwiX19ORVhUX0hZRFJBVEVEIiwiX19ORVhUX0hZRFJBVEVEX0FUIiwicGVyZm9ybWFuY2UiLCJub3ciLCJfX05FWFRfSFlEUkFURURfQ0IiLCJvbkRlZmF1bHRUcmFuc2l0aW9uSW5kaWNhdG9yIiwicmVhY3RSb290T3B0aW9ucyIsIm9uUmVjb3ZlcmFibGVFcnJvciIsIm9uQ2F1Z2h0RXJyb3IiLCJvblVuY2F1Z2h0RXJyb3IiLCJpbnN0cnVtZW50YXRpb25Ib29rcyIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwidGhlbiIsInNldEFwcEJ1aWxkSWQiLCJiIiwiaW5pdGlhbFRpbWVzdGFtcCIsIkRhdGUiLCJjcmVhdGVNdXRhYmxlQWN0aW9uUXVldWUiLCJjcmVhdGVJbml0aWFsUm91dGVyU3RhdGUiLCJuYXZpZ2F0ZWRBdCIsImluaXRpYWxGbGlnaHREYXRhIiwiZiIsImluaXRpYWxDYW5vbmljYWxVcmxQYXJ0cyIsImMiLCJpbml0aWFsUGFyYWxsZWxSb3V0ZXMiLCJNYXAiLCJsb2NhdGlvbiIsImNvdWxkQmVJbnRlcmNlcHRlZCIsInBvc3Rwb25lZCIsInMiLCJwcmVyZW5kZXJlZCIsIlMiLCJlcnIiLCJyZWFjdEVsIiwiSGVhZE1hbmFnZXJDb250ZXh0IiwiUHJvdmlkZXIiLCJhcHBEaXIiLCJkb2N1bWVudEVsZW1lbnQiLCJpZCIsImVsZW1lbnQiLCJSb290TGV2ZWxEZXZPdmVybGF5RWxlbWVudCIsInJlcXVpcmUiLCJSZWFjdERPTUNsaWVudCIsImNyZWF0ZVJvb3QiLCJyZW5kZXIiLCJzdGFydFRyYW5zaXRpb24iLCJoeWRyYXRlUm9vdCIsImZvcm1TdGF0ZSIsImxpbmtHYyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/app-index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/app-link-gc.js":
/*!**********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/app-link-gc.js ***!
  \**********************************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"linkGc\", ({\n    enumerable: true,\n    get: function() {\n        return linkGc;\n    }\n}));\nfunction linkGc() {\n    // TODO-APP: Remove this logic when Float has GC built-in in development.\n    if (true) {\n        const callback = (mutationList)=>{\n            for (const mutation of mutationList){\n                if (mutation.type === 'childList') {\n                    for (const node of mutation.addedNodes){\n                        if ('tagName' in node && node.tagName === 'LINK') {\n                            var _link_dataset_precedence;\n                            const link = node;\n                            if ((_link_dataset_precedence = link.dataset.precedence) == null ? void 0 : _link_dataset_precedence.startsWith('next')) {\n                                const href = link.getAttribute('href');\n                                if (href) {\n                                    const [resource, version] = href.split('?v=', 2);\n                                    if (version) {\n                                        const currentOrigin = window.location.origin;\n                                        const allLinks = [\n                                            ...document.querySelectorAll('link[href^=\"' + resource + '\"]'),\n                                            // It's possible that the resource is a full URL or only pathname,\n                                            // so we need to remove the alternative href as well.\n                                            ...document.querySelectorAll('link[href^=\"' + (resource.startsWith(currentOrigin) ? resource.slice(currentOrigin.length) : currentOrigin + resource) + '\"]')\n                                        ];\n                                        for (const otherLink of allLinks){\n                                            var _otherLink_dataset_precedence;\n                                            if ((_otherLink_dataset_precedence = otherLink.dataset.precedence) == null ? void 0 : _otherLink_dataset_precedence.startsWith('next')) {\n                                                const otherHref = otherLink.getAttribute('href');\n                                                if (otherHref) {\n                                                    const [, otherVersion] = otherHref.split('?v=', 2);\n                                                    if (!otherVersion || +otherVersion < +version) {\n                                                        // Delay the removal of the stylesheet to avoid FOUC\n                                                        // caused by `@font-face` rules, as they seem to be\n                                                        // a couple of ticks delayed between the old and new\n                                                        // styles being swapped even if the font is cached.\n                                                        setTimeout(()=>{\n                                                            otherLink.remove();\n                                                        }, 5);\n                                                        const preloadLink = document.querySelector('link[rel=\"preload\"][as=\"style\"][href=\"' + otherHref + '\"]');\n                                                        if (preloadLink) {\n                                                            preloadLink.remove();\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        };\n        // Create an observer instance linked to the callback function\n        const observer = new MutationObserver(callback);\n        observer.observe(document.head, {\n            childList: true\n        });\n    }\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-link-gc.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE1LjUuMTJfcmVhY3QtZG9tQDE5LjIuNF9yZWFjdEAxOS4yLjRfX3JlYWN0QDE5LjIuNC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9hcHAtbGluay1nYy5qcyIsIm1hcHBpbmdzIjoiOzs7OzBDQUFnQkE7OztlQUFBQTs7O0FBQVQsU0FBU0E7SUFDZCx5RUFBeUU7SUFDekUsSUFBSUMsSUFBb0IsRUFBbUI7UUFDekMsTUFBTUcsV0FBVyxDQUFDQztZQUNoQixLQUFLLE1BQU1DLFlBQVlELGFBQWM7Z0JBQ25DLElBQUlDLFNBQVNDLElBQUksS0FBSyxhQUFhO29CQUNqQyxLQUFLLE1BQU1DLFFBQVFGLFNBQVNHLFVBQVUsQ0FBRTt3QkFDdEMsSUFDRSxhQUFhRCxRQUNaQSxLQUF5QkUsT0FBTyxLQUFLLFFBQ3RDO2dDQUVJQzs0QkFESixNQUFNQSxPQUFPSDs0QkFDYixLQUFJRywyQkFBQUEsS0FBS0MsT0FBTyxDQUFDQyxVQUFBQSxLQUFVLGdCQUF2QkYseUJBQXlCRyxVQUFVLENBQUMsU0FBUztnQ0FDL0MsTUFBTUMsT0FBT0osS0FBS0ssWUFBWSxDQUFDO2dDQUMvQixJQUFJRCxNQUFNO29DQUNSLE1BQU0sQ0FBQ0UsVUFBVUMsUUFBUSxHQUFHSCxLQUFLSSxLQUFLLENBQUMsT0FBTztvQ0FDOUMsSUFBSUQsU0FBUzt3Q0FDWCxNQUFNRSxnQkFBZ0JDLE9BQU9DLFFBQVEsQ0FBQ0MsTUFBTTt3Q0FDNUMsTUFBTUMsV0FBVzsrQ0FDWkMsU0FBU0MsZ0JBQWdCLENBQzFCLGlCQUFpQlQsV0FBVzs0Q0FFOUIsa0VBQWtFOzRDQUNsRSxxREFBcUQ7K0NBQ2xEUSxTQUFTQyxnQkFBZ0IsQ0FDMUIsaUJBQ0dULENBQUFBLFNBQVNILFVBQVUsQ0FBQ00saUJBQ2pCSCxTQUFTVSxLQUFLLENBQUNQLGNBQWNRLE1BQU0sSUFDbkNSLGdCQUFnQkgsUUFBQUEsQ0FBTyxHQUMzQjt5Q0FFTDt3Q0FFRCxLQUFLLE1BQU1ZLGFBQWFMLFNBQVU7Z0RBQzVCSzs0Q0FBSixLQUFJQSxnQ0FBQUEsVUFBVWpCLE9BQU8sQ0FBQ0MsVUFBQUEsS0FBVSxnQkFBNUJnQiw4QkFBOEJmLFVBQVUsQ0FBQyxTQUFTO2dEQUNwRCxNQUFNZ0IsWUFBWUQsVUFBVWIsWUFBWSxDQUFDO2dEQUN6QyxJQUFJYyxXQUFXO29EQUNiLE1BQU0sR0FBR0MsYUFBYSxHQUFHRCxVQUFVWCxLQUFLLENBQUMsT0FBTztvREFDaEQsSUFBSSxDQUFDWSxnQkFBZ0IsQ0FBQ0EsZUFBZSxDQUFDYixTQUFTO3dEQUM3QyxvREFBb0Q7d0RBQ3BELG1EQUFtRDt3REFDbkQsb0RBQW9EO3dEQUNwRCxtREFBbUQ7d0RBQ25EYyxXQUFXOzREQUNUSCxVQUFVSSxNQUFNO3dEQUNsQixHQUFHO3dEQUNILE1BQU1DLGNBQWNULFNBQVNVLGFBQWEsQ0FDdkMsMkNBQXdDTCxZQUFVO3dEQUVyRCxJQUFJSSxhQUFhOzREQUNmQSxZQUFZRCxNQUFNO3dEQUNwQjtvREFDRjtnREFDRjs0Q0FDRjt3Q0FDRjtvQ0FDRjtnQ0FDRjs0QkFDRjt3QkFDRjtvQkFDRjtnQkFDRjtZQUNGO1FBQ0Y7UUFFQSw4REFBOEQ7UUFDOUQsTUFBTUcsV0FBVyxJQUFJQyxpQkFBaUJqQztRQUN0Q2dDLFNBQVNFLE9BQU8sQ0FBQ2IsU0FBU2MsSUFBSSxFQUFFO1lBQzlCQyxXQUFXO1FBQ2I7SUFDRjtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvc2FiaW5lcmVzb2FnbGkvR2l0SHViL3NyYy9jbGllbnQvYXBwLWxpbmstZ2MudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGxpbmtHYygpIHtcbiAgLy8gVE9ETy1BUFA6IFJlbW92ZSB0aGlzIGxvZ2ljIHdoZW4gRmxvYXQgaGFzIEdDIGJ1aWx0LWluIGluIGRldmVsb3BtZW50LlxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNvbnN0IGNhbGxiYWNrID0gKG11dGF0aW9uTGlzdDogTXV0YXRpb25SZWNvcmRbXSkgPT4ge1xuICAgICAgZm9yIChjb25zdCBtdXRhdGlvbiBvZiBtdXRhdGlvbkxpc3QpIHtcbiAgICAgICAgaWYgKG11dGF0aW9uLnR5cGUgPT09ICdjaGlsZExpc3QnKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIG11dGF0aW9uLmFkZGVkTm9kZXMpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgJ3RhZ05hbWUnIGluIG5vZGUgJiZcbiAgICAgICAgICAgICAgKG5vZGUgYXMgSFRNTExpbmtFbGVtZW50KS50YWdOYW1lID09PSAnTElOSydcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBjb25zdCBsaW5rID0gbm9kZSBhcyBIVE1MTGlua0VsZW1lbnRcbiAgICAgICAgICAgICAgaWYgKGxpbmsuZGF0YXNldC5wcmVjZWRlbmNlPy5zdGFydHNXaXRoKCduZXh0JykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBocmVmID0gbGluay5nZXRBdHRyaWJ1dGUoJ2hyZWYnKVxuICAgICAgICAgICAgICAgIGlmIChocmVmKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBbcmVzb3VyY2UsIHZlcnNpb25dID0gaHJlZi5zcGxpdCgnP3Y9JywgMilcbiAgICAgICAgICAgICAgICAgIGlmICh2ZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRPcmlnaW4gPSB3aW5kb3cubG9jYXRpb24ub3JpZ2luXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFsbExpbmtzID0gW1xuICAgICAgICAgICAgICAgICAgICAgIC4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICAgICAgICAgICAgICAgICAgICAnbGlua1tocmVmXj1cIicgKyByZXNvdXJjZSArICdcIl0nXG4gICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBJdCdzIHBvc3NpYmxlIHRoYXQgdGhlIHJlc291cmNlIGlzIGEgZnVsbCBVUkwgb3Igb25seSBwYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBzbyB3ZSBuZWVkIHRvIHJlbW92ZSB0aGUgYWx0ZXJuYXRpdmUgaHJlZiBhcyB3ZWxsLlxuICAgICAgICAgICAgICAgICAgICAgIC4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICAgICAgICAgICAgICAgICAgICAnbGlua1tocmVmXj1cIicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAocmVzb3VyY2Uuc3RhcnRzV2l0aChjdXJyZW50T3JpZ2luKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gcmVzb3VyY2Uuc2xpY2UoY3VycmVudE9yaWdpbi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjdXJyZW50T3JpZ2luICsgcmVzb3VyY2UpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ1wiXSdcbiAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBdIGFzIEhUTUxMaW5rRWxlbWVudFtdXG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBvdGhlckxpbmsgb2YgYWxsTGlua3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAob3RoZXJMaW5rLmRhdGFzZXQucHJlY2VkZW5jZT8uc3RhcnRzV2l0aCgnbmV4dCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvdGhlckhyZWYgPSBvdGhlckxpbmsuZ2V0QXR0cmlidXRlKCdocmVmJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdGhlckhyZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgWywgb3RoZXJWZXJzaW9uXSA9IG90aGVySHJlZi5zcGxpdCgnP3Y9JywgMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvdGhlclZlcnNpb24gfHwgK290aGVyVmVyc2lvbiA8ICt2ZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVsYXkgdGhlIHJlbW92YWwgb2YgdGhlIHN0eWxlc2hlZXQgdG8gYXZvaWQgRk9VQ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhdXNlZCBieSBgQGZvbnQtZmFjZWAgcnVsZXMsIGFzIHRoZXkgc2VlbSB0byBiZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGEgY291cGxlIG9mIHRpY2tzIGRlbGF5ZWQgYmV0d2VlbiB0aGUgb2xkIGFuZCBuZXdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdHlsZXMgYmVpbmcgc3dhcHBlZCBldmVuIGlmIHRoZSBmb250IGlzIGNhY2hlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyTGluay5yZW1vdmUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIDUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJlbG9hZExpbmsgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYGxpbmtbcmVsPVwicHJlbG9hZFwiXVthcz1cInN0eWxlXCJdW2hyZWY9XCIke290aGVySHJlZn1cIl1gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmVsb2FkTGluaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlbG9hZExpbmsucmVtb3ZlKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgYW4gb2JzZXJ2ZXIgaW5zdGFuY2UgbGlua2VkIHRvIHRoZSBjYWxsYmFjayBmdW5jdGlvblxuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoY2FsbGJhY2spXG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudC5oZWFkLCB7XG4gICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgfSlcbiAgfVxufVxuIl0sIm5hbWVzIjpbImxpbmtHYyIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImNhbGxiYWNrIiwibXV0YXRpb25MaXN0IiwibXV0YXRpb24iLCJ0eXBlIiwibm9kZSIsImFkZGVkTm9kZXMiLCJ0YWdOYW1lIiwibGluayIsImRhdGFzZXQiLCJwcmVjZWRlbmNlIiwic3RhcnRzV2l0aCIsImhyZWYiLCJnZXRBdHRyaWJ1dGUiLCJyZXNvdXJjZSIsInZlcnNpb24iLCJzcGxpdCIsImN1cnJlbnRPcmlnaW4iLCJ3aW5kb3ciLCJsb2NhdGlvbiIsIm9yaWdpbiIsImFsbExpbmtzIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwic2xpY2UiLCJsZW5ndGgiLCJvdGhlckxpbmsiLCJvdGhlckhyZWYiLCJvdGhlclZlcnNpb24iLCJzZXRUaW1lb3V0IiwicmVtb3ZlIiwicHJlbG9hZExpbmsiLCJxdWVyeVNlbGVjdG9yIiwib2JzZXJ2ZXIiLCJNdXRhdGlvbk9ic2VydmVyIiwib2JzZXJ2ZSIsImhlYWQiLCJjaGlsZExpc3QiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/app-link-gc.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/app-router-instance.js":
/*!*****************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/app-router-instance.js ***!
  \*****************************************************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createMutableActionQueue: function() {\n        return createMutableActionQueue;\n    },\n    dispatchNavigateAction: function() {\n        return dispatchNavigateAction;\n    },\n    dispatchTraverseAction: function() {\n        return dispatchTraverseAction;\n    },\n    getCurrentAppRouterState: function() {\n        return getCurrentAppRouterState;\n    },\n    publicAppRouterInstance: function() {\n        return publicAppRouterInstance;\n    }\n});\nconst _routerreducertypes = __webpack_require__(/*! ./router-reducer/router-reducer-types */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nconst _routerreducer = __webpack_require__(/*! ./router-reducer/router-reducer */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/router-reducer/router-reducer.js\");\nconst _react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/compiled/react/index.js\");\nconst _isthenable = __webpack_require__(/*! ../../shared/lib/is-thenable */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/shared/lib/is-thenable.js\");\nconst _segmentcache = __webpack_require__(/*! ./segment-cache */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/segment-cache.js\");\nconst _useactionqueue = __webpack_require__(/*! ./use-action-queue */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/use-action-queue.js\");\nconst _addbasepath = __webpack_require__(/*! ../add-base-path */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/add-base-path.js\");\nconst _approuter = __webpack_require__(/*! ./app-router */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/app-router.js\");\nconst _prefetchreducer = __webpack_require__(/*! ./router-reducer/reducers/prefetch-reducer */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js\");\nconst _links = __webpack_require__(/*! ./links */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/links.js\");\nfunction runRemainingActions(actionQueue, setState) {\n    if (actionQueue.pending !== null) {\n        actionQueue.pending = actionQueue.pending.next;\n        if (actionQueue.pending !== null) {\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            runAction({\n                actionQueue,\n                action: actionQueue.pending,\n                setState\n            });\n        } else {\n            // No more actions are pending, check if a refresh is needed\n            if (actionQueue.needsRefresh) {\n                actionQueue.needsRefresh = false;\n                actionQueue.dispatch({\n                    type: _routerreducertypes.ACTION_REFRESH,\n                    origin: window.location.origin\n                }, setState);\n            }\n        }\n    }\n}\nasync function runAction(param) {\n    let { actionQueue, action, setState } = param;\n    const prevState = actionQueue.state;\n    actionQueue.pending = action;\n    const payload = action.payload;\n    const actionResult = actionQueue.action(prevState, payload);\n    function handleResult(nextState) {\n        // if we discarded this action, the state should also be discarded\n        if (action.discarded) {\n            return;\n        }\n        actionQueue.state = nextState;\n        runRemainingActions(actionQueue, setState);\n        action.resolve(nextState);\n    }\n    // if the action is a promise, set up a callback to resolve it\n    if ((0, _isthenable.isThenable)(actionResult)) {\n        actionResult.then(handleResult, (err)=>{\n            runRemainingActions(actionQueue, setState);\n            action.reject(err);\n        });\n    } else {\n        handleResult(actionResult);\n    }\n}\nfunction dispatchAction(actionQueue, payload, setState) {\n    let resolvers = {\n        resolve: setState,\n        reject: ()=>{}\n    };\n    // most of the action types are async with the exception of restore\n    // it's important that restore is handled quickly since it's fired on the popstate event\n    // and we don't want to add any delay on a back/forward nav\n    // this only creates a promise for the async actions\n    if (payload.type !== _routerreducertypes.ACTION_RESTORE) {\n        // Create the promise and assign the resolvers to the object.\n        const deferredPromise = new Promise((resolve, reject)=>{\n            resolvers = {\n                resolve,\n                reject\n            };\n        });\n        (0, _react.startTransition)(()=>{\n            // we immediately notify React of the pending promise -- the resolver is attached to the action node\n            // and will be called when the associated action promise resolves\n            setState(deferredPromise);\n        });\n    }\n    const newAction = {\n        payload,\n        next: null,\n        resolve: resolvers.resolve,\n        reject: resolvers.reject\n    };\n    // Check if the queue is empty\n    if (actionQueue.pending === null) {\n        // The queue is empty, so add the action and start it immediately\n        // Mark this action as the last in the queue\n        actionQueue.last = newAction;\n        runAction({\n            actionQueue,\n            action: newAction,\n            setState\n        });\n    } else if (payload.type === _routerreducertypes.ACTION_NAVIGATE || payload.type === _routerreducertypes.ACTION_RESTORE) {\n        // Navigations (including back/forward) take priority over any pending actions.\n        // Mark the pending action as discarded (so the state is never applied) and start the navigation action immediately.\n        actionQueue.pending.discarded = true;\n        // The rest of the current queue should still execute after this navigation.\n        // (Note that it can't contain any earlier navigations, because we always put those into `actionQueue.pending` by calling `runAction`)\n        newAction.next = actionQueue.pending.next;\n        // if the pending action was a server action, mark the queue as needing a refresh once events are processed\n        if (actionQueue.pending.payload.type === _routerreducertypes.ACTION_SERVER_ACTION) {\n            actionQueue.needsRefresh = true;\n        }\n        runAction({\n            actionQueue,\n            action: newAction,\n            setState\n        });\n    } else {\n        // The queue is not empty, so add the action to the end of the queue\n        // It will be started by runRemainingActions after the previous action finishes\n        if (actionQueue.last !== null) {\n            actionQueue.last.next = newAction;\n        }\n        actionQueue.last = newAction;\n    }\n}\nlet globalActionQueue = null;\nfunction createMutableActionQueue(initialState, instrumentationHooks) {\n    const actionQueue = {\n        state: initialState,\n        dispatch: (payload, setState)=>dispatchAction(actionQueue, payload, setState),\n        action: async (state, action)=>{\n            const result = (0, _routerreducer.reducer)(state, action);\n            return result;\n        },\n        pending: null,\n        last: null,\n        onRouterTransitionStart: instrumentationHooks !== null && typeof instrumentationHooks.onRouterTransitionStart === 'function' ? instrumentationHooks.onRouterTransitionStart : null\n    };\n    if (true) {\n        // The action queue is lazily created on hydration, but after that point\n        // it doesn't change. So we can store it in a global rather than pass\n        // it around everywhere via props/context.\n        if (globalActionQueue !== null) {\n            throw Object.defineProperty(new Error('Internal Next.js Error: createMutableActionQueue was called more ' + 'than once'), \"__NEXT_ERROR_CODE\", {\n                value: \"E624\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        globalActionQueue = actionQueue;\n    }\n    return actionQueue;\n}\nfunction getCurrentAppRouterState() {\n    return globalActionQueue !== null ? globalActionQueue.state : null;\n}\nfunction getAppRouterActionQueue() {\n    if (globalActionQueue === null) {\n        throw Object.defineProperty(new Error('Internal Next.js error: Router action dispatched before initialization.'), \"__NEXT_ERROR_CODE\", {\n            value: \"E668\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    return globalActionQueue;\n}\nfunction getProfilingHookForOnNavigationStart() {\n    if (globalActionQueue !== null) {\n        return globalActionQueue.onRouterTransitionStart;\n    }\n    return null;\n}\nfunction dispatchNavigateAction(href, navigateType, shouldScroll, linkInstanceRef) {\n    // TODO: This stuff could just go into the reducer. Leaving as-is for now\n    // since we're about to rewrite all the router reducer stuff anyway.\n    const url = new URL((0, _addbasepath.addBasePath)(href), location.href);\n    if (false) {}\n    (0, _links.setLinkForCurrentNavigation)(linkInstanceRef);\n    const onRouterTransitionStart = getProfilingHookForOnNavigationStart();\n    if (onRouterTransitionStart !== null) {\n        onRouterTransitionStart(href, navigateType);\n    }\n    (0, _useactionqueue.dispatchAppRouterAction)({\n        type: _routerreducertypes.ACTION_NAVIGATE,\n        url,\n        isExternalUrl: (0, _approuter.isExternalURL)(url),\n        locationSearch: location.search,\n        shouldScroll,\n        navigateType,\n        allowAliasing: true\n    });\n}\nfunction dispatchTraverseAction(href, tree) {\n    const onRouterTransitionStart = getProfilingHookForOnNavigationStart();\n    if (onRouterTransitionStart !== null) {\n        onRouterTransitionStart(href, 'traverse');\n    }\n    (0, _useactionqueue.dispatchAppRouterAction)({\n        type: _routerreducertypes.ACTION_RESTORE,\n        url: new URL(href),\n        tree\n    });\n}\nconst publicAppRouterInstance = {\n    back: ()=>window.history.back(),\n    forward: ()=>window.history.forward(),\n    prefetch:  false ? // cache. So we don't need to dispatch an action.\n    0 : (href, options)=>{\n        // Use the old prefetch implementation.\n        const actionQueue = getAppRouterActionQueue();\n        const url = (0, _approuter.createPrefetchURL)(href);\n        if (url !== null) {\n            var _options_kind;\n            // The prefetch reducer doesn't actually update any state or\n            // trigger a rerender. It just writes to a mutable cache. So we\n            // shouldn't bother calling setState/dispatch; we can just re-run\n            // the reducer directly using the current state.\n            // TODO: Refactor this away from a \"reducer\" so it's\n            // less confusing.\n            (0, _prefetchreducer.prefetchReducer)(actionQueue.state, {\n                type: _routerreducertypes.ACTION_PREFETCH,\n                url,\n                kind: (_options_kind = options == null ? void 0 : options.kind) != null ? _options_kind : _routerreducertypes.PrefetchKind.FULL\n            });\n        }\n    },\n    replace: (href, options)=>{\n        (0, _react.startTransition)(()=>{\n            var _options_scroll;\n            dispatchNavigateAction(href, 'replace', (_options_scroll = options == null ? void 0 : options.scroll) != null ? _options_scroll : true, null);\n        });\n    },\n    push: (href, options)=>{\n        (0, _react.startTransition)(()=>{\n            var _options_scroll;\n            dispatchNavigateAction(href, 'push', (_options_scroll = options == null ? void 0 : options.scroll) != null ? _options_scroll : true, null);\n        });\n    },\n    refresh: ()=>{\n        (0, _react.startTransition)(()=>{\n            (0, _useactionqueue.dispatchAppRouterAction)({\n                type: _routerreducertypes.ACTION_REFRESH,\n                origin: window.location.origin\n            });\n        });\n    },\n    hmrRefresh: ()=>{\n        if (false) {} else {\n            (0, _react.startTransition)(()=>{\n                (0, _useactionqueue.dispatchAppRouterAction)({\n                    type: _routerreducertypes.ACTION_HMR_REFRESH,\n                    origin: window.location.origin\n                });\n            });\n        }\n    }\n};\n// Exists for debugging purposes. Don't use in application code.\nif ( true && window.next) {\n    window.next.router = publicAppRouterInstance;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-router-instance.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE1LjUuMTJfcmVhY3QtZG9tQDE5LjIuNF9yZWFjdEAxOS4yLjRfX3JlYWN0QDE5LjIuNC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2FwcC1yb3V0ZXItaW5zdGFuY2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBbU5nQkEsd0JBQXdCO2VBQXhCQTs7SUEwREFDLHNCQUFzQjtlQUF0QkE7O0lBK0JBQyxzQkFBc0I7ZUFBdEJBOztJQW5EQUMsd0JBQXdCO2VBQXhCQTs7SUF1RUhDLHVCQUF1QjtlQUF2QkE7OztnREFwVE47MkNBQ2lCO21DQUNRO3dDQUNMOzBDQUtwQjs0Q0FDaUM7eUNBQ1o7dUNBQ3FCOzZDQUNqQjttQ0FNK0I7QUFrQy9ELFNBQVNDLG9CQUNQQyxXQUFpQyxFQUNqQ0MsUUFBOEI7SUFFOUIsSUFBSUQsWUFBWUUsT0FBTyxLQUFLLE1BQU07UUFDaENGLFlBQVlFLE9BQU8sR0FBR0YsWUFBWUUsT0FBTyxDQUFDQyxJQUFJO1FBQzlDLElBQUlILFlBQVlFLE9BQU8sS0FBSyxNQUFNO1lBQ2hDLG1FQUFtRTtZQUNuRUUsVUFBVTtnQkFDUko7Z0JBQ0FLLFFBQVFMLFlBQVlFLE9BQU87Z0JBQzNCRDtZQUNGO1FBQ0YsT0FBTztZQUNMLDREQUE0RDtZQUM1RCxJQUFJRCxZQUFZTSxZQUFZLEVBQUU7Z0JBQzVCTixZQUFZTSxZQUFZLEdBQUc7Z0JBQzNCTixZQUFZTyxRQUFRLENBQ2xCO29CQUNFQyxNQUFNQyxvQkFBQUEsY0FBYztvQkFDcEJDLFFBQVFDLE9BQU9DLFFBQVEsQ0FBQ0YsTUFBTTtnQkFDaEMsR0FDQVQ7WUFFSjtRQUNGO0lBQ0Y7QUFDRjtBQUVBLGVBQWVHLFVBQVUsS0FReEI7SUFSd0IsTUFDdkJKLFdBQVcsRUFDWEssTUFBTSxFQUNOSixRQUFRLEVBS1QsR0FSd0I7SUFTdkIsTUFBTVksWUFBWWIsWUFBWWMsS0FB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ZXMiOlsiL1VzZXJzL3NhYmluZXJlc29hZ2xpL3NyYy9jbGllbnQvY29tcG9uZW50cy9hcHAtcm91dGVyLWluc3RhbmNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIHR5cGUgQXBwUm91dGVyU3RhdGUsXG4gIHR5cGUgUmVkdWNlckFjdGlvbnMsXG4gIHR5cGUgUmVkdWNlclN0YXRlLFxuICBBQ1RJT05fUkVGUkVTSCxcbiAgQUNUSU9OX1NFUlZFUl9BQ1RJT04sXG4gIEFDVElPTl9OQVZJR0FURSxcbiAgQUNUSU9OX1JFU1RPUkUsXG4gIHR5cGUgTmF2aWdhdGVBY3Rpb24sXG4gIEFDVElPTl9ITVJfUkVGUkVTSCxcbiAgUHJlZmV0Y2hLaW5kLFxuICBBQ1RJT05fUFJFRkVUQ0gsXG59IGZyb20gJy4vcm91dGVyLXJlZHVjZXIvcm91dGVyLXJlZHVjZXItdHlwZXMnXG5pbXBvcnQgeyByZWR1Y2VyIH0gZnJvbSAnLi9yb3V0ZXItcmVkdWNlci9yb3V0ZXItcmVkdWNlcidcbmltcG9ydCB7IHN0YXJ0VHJhbnNpdGlvbiB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgaXNUaGVuYWJsZSB9IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvaXMtdGhlbmFibGUnXG5pbXBvcnQge1xuICBGZXRjaFN0cmF0ZWd5LFxuICBwcmVmZXRjaCBhcyBwcmVmZXRjaFdpdGhTZWdtZW50Q2FjaGUsXG4gIHR5cGUgUHJlZmV0Y2hUYXNrRmV0Y2hTdHJhdGVneSxcbn0gZnJvbSAnLi9zZWdtZW50LWNhY2hlJ1xuaW1wb3J0IHsgZGlzcGF0Y2hBcHBSb3V0ZXJBY3Rpb24gfSBmcm9tICcuL3VzZS1hY3Rpb24tcXVldWUnXG5pbXBvcnQgeyBhZGRCYXNlUGF0aCB9IGZyb20gJy4uL2FkZC1iYXNlLXBhdGgnXG5pbXBvcnQgeyBjcmVhdGVQcmVmZXRjaFVSTCwgaXNFeHRlcm5hbFVSTCB9IGZyb20gJy4vYXBwLXJvdXRlcidcbmltcG9ydCB7IHByZWZldGNoUmVkdWNlciB9IGZyb20gJy4vcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvcHJlZmV0Y2gtcmVkdWNlcidcbmltcG9ydCB0eXBlIHtcbiAgQXBwUm91dGVySW5zdGFuY2UsXG4gIE5hdmlnYXRlT3B0aW9ucyxcbiAgUHJlZmV0Y2hPcHRpb25zLFxufSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB7IHNldExpbmtGb3JDdXJyZW50TmF2aWdhdGlvbiwgdHlwZSBMaW5rSW5zdGFuY2UgfSBmcm9tICcuL2xpbmtzJ1xuaW1wb3J0IHR5cGUgeyBGbGlnaHRSb3V0ZXJTdGF0ZSB9IGZyb20gJy4uLy4uL3NlcnZlci9hcHAtcmVuZGVyL3R5cGVzJ1xuaW1wb3J0IHR5cGUgeyBDbGllbnRJbnN0cnVtZW50YXRpb25Ib29rcyB9IGZyb20gJy4uL2FwcC1pbmRleCdcbmltcG9ydCB0eXBlIHsgR2xvYmFsRXJyb3JDb21wb25lbnQgfSBmcm9tICcuL2J1aWx0aW4vZ2xvYmFsLWVycm9yJ1xuXG5leHBvcnQgdHlwZSBEaXNwYXRjaFN0YXRlUHJvbWlzZSA9IFJlYWN0LkRpc3BhdGNoPFJlZHVjZXJTdGF0ZT5cblxuZXhwb3J0IHR5cGUgQXBwUm91dGVyQWN0aW9uUXVldWUgPSB7XG4gIHN0YXRlOiBBcHBSb3V0ZXJTdGF0ZVxuICBkaXNwYXRjaDogKHBheWxvYWQ6IFJlZHVjZXJBY3Rpb25zLCBzZXRTdGF0ZTogRGlzcGF0Y2hTdGF0ZVByb21pc2UpID0+IHZvaWRcbiAgYWN0aW9uOiAoc3RhdGU6IEFwcFJvdXRlclN0YXRlLCBhY3Rpb246IFJlZHVjZXJBY3Rpb25zKSA9PiBSZWR1Y2VyU3RhdGVcblxuICBvblJvdXRlclRyYW5zaXRpb25TdGFydDpcbiAgICB8ICgodXJsOiBzdHJpbmcsIHR5cGU6ICdwdXNoJyB8ICdyZXBsYWNlJyB8ICd0cmF2ZXJzZScpID0+IHZvaWQpXG4gICAgfCBudWxsXG5cbiAgcGVuZGluZzogQWN0aW9uUXVldWVOb2RlIHwgbnVsbFxuICBuZWVkc1JlZnJlc2g/OiBib29sZWFuXG4gIGxhc3Q6IEFjdGlvblF1ZXVlTm9kZSB8IG51bGxcbn1cblxuZXhwb3J0IHR5cGUgR2xvYmFsRXJyb3JTdGF0ZSA9IFtcbiAgR2xvYmFsRXJyb3I6IEdsb2JhbEVycm9yQ29tcG9uZW50LFxuICBzdHlsZXM6IFJlYWN0LlJlYWN0Tm9kZSxcbl1cblxuZXhwb3J0IHR5cGUgQWN0aW9uUXVldWVOb2RlID0ge1xuICBwYXlsb2FkOiBSZWR1Y2VyQWN0aW9uc1xuICBuZXh0OiBBY3Rpb25RdWV1ZU5vZGUgfCBudWxsXG4gIHJlc29sdmU6ICh2YWx1ZTogUmVkdWNlclN0YXRlKSA9PiB2b2lkXG4gIHJlamVjdDogKGVycjogRXJyb3IpID0+IHZvaWRcbiAgZGlzY2FyZGVkPzogYm9vbGVhblxufVxuXG5mdW5jdGlvbiBydW5SZW1haW5pbmdBY3Rpb25zKFxuICBhY3Rpb25RdWV1ZTogQXBwUm91dGVyQWN0aW9uUXVldWUsXG4gIHNldFN0YXRlOiBEaXNwYXRjaFN0YXRlUHJvbWlzZVxuKSB7XG4gIGlmIChhY3Rpb25RdWV1ZS5wZW5kaW5nICE9PSBudWxsKSB7XG4gICAgYWN0aW9uUXVldWUucGVuZGluZyA9IGFjdGlvblF1ZXVlLnBlbmRpbmcubmV4dFxuICAgIGlmIChhY3Rpb25RdWV1ZS5wZW5kaW5nICE9PSBudWxsKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICBydW5BY3Rpb24oe1xuICAgICAgICBhY3Rpb25RdWV1ZSxcbiAgICAgICAgYWN0aW9uOiBhY3Rpb25RdWV1ZS5wZW5kaW5nLFxuICAgICAgICBzZXRTdGF0ZSxcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5vIG1vcmUgYWN0aW9ucyBhcmUgcGVuZGluZywgY2hlY2sgaWYgYSByZWZyZXNoIGlzIG5lZWRlZFxuICAgICAgaWYgKGFjdGlvblF1ZXVlLm5lZWRzUmVmcmVzaCkge1xuICAgICAgICBhY3Rpb25RdWV1ZS5uZWVkc1JlZnJlc2ggPSBmYWxzZVxuICAgICAgICBhY3Rpb25RdWV1ZS5kaXNwYXRjaChcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiBBQ1RJT05fUkVGUkVTSCxcbiAgICAgICAgICAgIG9yaWdpbjogd2luZG93LmxvY2F0aW9uLm9yaWdpbixcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldFN0YXRlXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gcnVuQWN0aW9uKHtcbiAgYWN0aW9uUXVldWUsXG4gIGFjdGlvbixcbiAgc2V0U3RhdGUsXG59OiB7XG4gIGFjdGlvblF1ZXVlOiBBcHBSb3V0ZXJBY3Rpb25RdWV1ZVxuICBhY3Rpb246IEFjdGlvblF1ZXVlTm9kZVxuICBzZXRTdGF0ZTogRGlzcGF0Y2hTdGF0ZVByb21pc2Vcbn0pIHtcbiAgY29uc3QgcHJldlN0YXRlID0gYWN0aW9uUXVldWUuc3RhdGVcblxuICBhY3Rpb25RdWV1ZS5wZW5kaW5nID0gYWN0aW9uXG5cbiAgY29uc3QgcGF5bG9hZCA9IGFjdGlvbi5wYXlsb2FkXG4gIGNvbnN0IGFjdGlvblJlc3VsdCA9IGFjdGlvblF1ZXVlLmFjdGlvbihwcmV2U3RhdGUsIHBheWxvYWQpXG5cbiAgZnVuY3Rpb24gaGFuZGxlUmVzdWx0KG5leHRTdGF0ZTogQXBwUm91dGVyU3RhdGUpIHtcbiAgICAvLyBpZiB3ZSBkaXNjYXJkZWQgdGhpcyBhY3Rpb24sIHRoZSBzdGF0ZSBzaG91bGQgYWxzbyBiZSBkaXNjYXJkZWRcbiAgICBpZiAoYWN0aW9uLmRpc2NhcmRlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgYWN0aW9uUXVldWUuc3RhdGUgPSBuZXh0U3RhdGVcblxuICAgIHJ1blJlbWFpbmluZ0FjdGlvbnMoYWN0aW9uUXVldWUsIHNldFN0YXRlKVxuICAgIGFjdGlvbi5yZXNvbHZlKG5leHRTdGF0ZSlcbiAgfVxuXG4gIC8vIGlmIHRoZSBhY3Rpb24gaXMgYSBwcm9taXNlLCBzZXQgdXAgYSBjYWxsYmFjayB0byByZXNvbHZlIGl0XG4gIGlmIChpc1RoZW5hYmxlKGFjdGlvblJlc3VsdCkpIHtcbiAgICBhY3Rpb25SZXN1bHQudGhlbihoYW5kbGVSZXN1bHQsIChlcnIpID0+IHtcbiAgICAgIHJ1blJlbWFpbmluZ0FjdGlvbnMoYWN0aW9uUXVldWUsIHNldFN0YXRlKVxuICAgICAgYWN0aW9uLnJlamVjdChlcnIpXG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICBoYW5kbGVSZXN1bHQoYWN0aW9uUmVzdWx0KVxuICB9XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoQWN0aW9uKFxuICBhY3Rpb25RdWV1ZTogQXBwUm91dGVyQWN0aW9uUXVldWUsXG4gIHBheWxvYWQ6IFJlZHVjZXJBY3Rpb25zLFxuICBzZXRTdGF0ZTogRGlzcGF0Y2hTdGF0ZVByb21pc2Vcbikge1xuICBsZXQgcmVzb2x2ZXJzOiB7XG4gICAgcmVzb2x2ZTogKHZhbHVlOiBSZWR1Y2VyU3RhdGUpID0+IHZvaWRcbiAgICByZWplY3Q6IChyZWFzb246IGFueSkgPT4gdm9pZFxuICB9ID0geyByZXNvbHZlOiBzZXRTdGF0ZSwgcmVqZWN0OiAoKSA9PiB7fSB9XG5cbiAgLy8gbW9zdCBvZiB0aGUgYWN0aW9uIHR5cGVzIGFyZSBhc3luYyB3aXRoIHRoZSBleGNlcHRpb24gb2YgcmVzdG9yZVxuICAvLyBpdCdzIGltcG9ydGFudCB0aGF0IHJlc3RvcmUgaXMgaGFuZGxlZCBxdWlja2x5IHNpbmNlIGl0J3MgZmlyZWQgb24gdGhlIHBvcHN0YXRlIGV2ZW50XG4gIC8vIGFuZCB3ZSBkb24ndCB3YW50IHRvIGFkZCBhbnkgZGVsYXkgb24gYSBiYWNrL2ZvcndhcmQgbmF2XG4gIC8vIHRoaXMgb25seSBjcmVhdGVzIGEgcHJvbWlzZSBmb3IgdGhlIGFzeW5jIGFjdGlvbnNcbiAgaWYgKHBheWxvYWQudHlwZSAhPT0gQUNUSU9OX1JFU1RPUkUpIHtcbiAgICAvLyBDcmVhdGUgdGhlIHByb21pc2UgYW5kIGFzc2lnbiB0aGUgcmVzb2x2ZXJzIHRvIHRoZSBvYmplY3QuXG4gICAgY29uc3QgZGVmZXJyZWRQcm9taXNlID0gbmV3IFByb21pc2U8QXBwUm91dGVyU3RhdGU+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHJlc29sdmVycyA9IHsgcmVzb2x2ZSwgcmVqZWN0IH1cbiAgICB9KVxuXG4gICAgc3RhcnRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgIC8vIHdlIGltbWVkaWF0ZWx5IG5vdGlmeSBSZWFjdCBvZiB0aGUgcGVuZGluZyBwcm9taXNlIC0tIHRoZSByZXNvbHZlciBpcyBhdHRhY2hlZCB0byB0aGUgYWN0aW9uIG5vZGVcbiAgICAgIC8vIGFuZCB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBhc3NvY2lhdGVkIGFjdGlvbiBwcm9taXNlIHJlc29sdmVzXG4gICAgICBzZXRTdGF0ZShkZWZlcnJlZFByb21pc2UpXG4gICAgfSlcbiAgfVxuXG4gIGNvbnN0IG5ld0FjdGlvbjogQWN0aW9uUXVldWVOb2RlID0ge1xuICAgIHBheWxvYWQsXG4gICAgbmV4dDogbnVsbCxcbiAgICByZXNvbHZlOiByZXNvbHZlcnMucmVzb2x2ZSxcbiAgICByZWplY3Q6IHJlc29sdmVycy5yZWplY3QsXG4gIH1cblxuICAvLyBDaGVjayBpZiB0aGUgcXVldWUgaXMgZW1wdHlcbiAgaWYgKGFjdGlvblF1ZXVlLnBlbmRpbmcgPT09IG51bGwpIHtcbiAgICAvLyBUaGUgcXVldWUgaXMgZW1wdHksIHNvIGFkZCB0aGUgYWN0aW9uIGFuZCBzdGFydCBpdCBpbW1lZGlhdGVseVxuICAgIC8vIE1hcmsgdGhpcyBhY3Rpb24gYXMgdGhlIGxhc3QgaW4gdGhlIHF1ZXVlXG4gICAgYWN0aW9uUXVldWUubGFzdCA9IG5ld0FjdGlvblxuXG4gICAgcnVuQWN0aW9uKHtcbiAgICAgIGFjdGlvblF1ZXVlLFxuICAgICAgYWN0aW9uOiBuZXdBY3Rpb24sXG4gICAgICBzZXRTdGF0ZSxcbiAgICB9KVxuICB9IGVsc2UgaWYgKFxuICAgIHBheWxvYWQudHlwZSA9PT0gQUNUSU9OX05BVklHQVRFIHx8XG4gICAgcGF5bG9hZC50eXBlID09PSBBQ1RJT05fUkVTVE9SRVxuICApIHtcbiAgICAvLyBOYXZpZ2F0aW9ucyAoaW5jbHVkaW5nIGJhY2svZm9yd2FyZCkgdGFrZSBwcmlvcml0eSBvdmVyIGFueSBwZW5kaW5nIGFjdGlvbnMuXG4gICAgLy8gTWFyayB0aGUgcGVuZGluZyBhY3Rpb24gYXMgZGlzY2FyZGVkIChzbyB0aGUgc3RhdGUgaXMgbmV2ZXIgYXBwbGllZCkgYW5kIHN0YXJ0IHRoZSBuYXZpZ2F0aW9uIGFjdGlvbiBpbW1lZGlhdGVseS5cbiAgICBhY3Rpb25RdWV1ZS5wZW5kaW5nLmRpc2NhcmRlZCA9IHRydWVcblxuICAgIC8vIFRoZSByZXN0IG9mIHRoZSBjdXJyZW50IHF1ZXVlIHNob3VsZCBzdGlsbCBleGVjdXRlIGFmdGVyIHRoaXMgbmF2aWdhdGlvbi5cbiAgICAvLyAoTm90ZSB0aGF0IGl0IGNhbid0IGNvbnRhaW4gYW55IGVhcmxpZXIgbmF2aWdhdGlvbnMsIGJlY2F1c2Ugd2UgYWx3YXlzIHB1dCB0aG9zZSBpbnRvIGBhY3Rpb25RdWV1ZS5wZW5kaW5nYCBieSBjYWxsaW5nIGBydW5BY3Rpb25gKVxuICAgIG5ld0FjdGlvbi5uZXh0ID0gYWN0aW9uUXVldWUucGVuZGluZy5uZXh0XG5cbiAgICAvLyBpZiB0aGUgcGVuZGluZyBhY3Rpb24gd2FzIGEgc2VydmVyIGFjdGlvbiwgbWFyayB0aGUgcXVldWUgYXMgbmVlZGluZyBhIHJlZnJlc2ggb25jZSBldmVudHMgYXJlIHByb2Nlc3NlZFxuICAgIGlmIChhY3Rpb25RdWV1ZS5wZW5kaW5nLnBheWxvYWQudHlwZSA9PT0gQUNUSU9OX1NFUlZFUl9BQ1RJT04pIHtcbiAgICAgIGFjdGlvblF1ZXVlLm5lZWRzUmVmcmVzaCA9IHRydWVcbiAgICB9XG5cbiAgICBydW5BY3Rpb24oe1xuICAgICAgYWN0aW9uUXVldWUsXG4gICAgICBhY3Rpb246IG5ld0FjdGlvbixcbiAgICAgIHNldFN0YXRlLFxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgLy8gVGhlIHF1ZXVlIGlzIG5vdCBlbXB0eSwgc28gYWRkIHRoZSBhY3Rpb24gdG8gdGhlIGVuZCBvZiB0aGUgcXVldWVcbiAgICAvLyBJdCB3aWxsIGJlIHN0YXJ0ZWQgYnkgcnVuUmVtYWluaW5nQWN0aW9ucyBhZnRlciB0aGUgcHJldmlvdXMgYWN0aW9uIGZpbmlzaGVzXG4gICAgaWYgKGFjdGlvblF1ZXVlLmxhc3QgIT09IG51bGwpIHtcbiAgICAgIGFjdGlvblF1ZXVlLmxhc3QubmV4dCA9IG5ld0FjdGlvblxuICAgIH1cbiAgICBhY3Rpb25RdWV1ZS5sYXN0ID0gbmV3QWN0aW9uXG4gIH1cbn1cblxubGV0IGdsb2JhbEFjdGlvblF1ZXVlOiBBcHBSb3V0ZXJBY3Rpb25RdWV1ZSB8IG51bGwgPSBudWxsXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVNdXRhYmxlQWN0aW9uUXVldWUoXG4gIGluaXRpYWxTdGF0ZTogQXBwUm91dGVyU3RhdGUsXG4gIGluc3RydW1lbnRhdGlvbkhvb2tzOiBDbGllbnRJbnN0cnVtZW50YXRpb25Ib29rcyB8IG51bGxcbik6IEFwcFJvdXRlckFjdGlvblF1ZXVlIHtcbiAgY29uc3QgYWN0aW9uUXVldWU6IEFwcFJvdXRlckFjdGlvblF1ZXVlID0ge1xuICAgIHN0YXRlOiBpbml0aWFsU3RhdGUsXG4gICAgZGlzcGF0Y2g6IChwYXlsb2FkOiBSZWR1Y2VyQWN0aW9ucywgc2V0U3RhdGU6IERpc3BhdGNoU3RhdGVQcm9taXNlKSA9PlxuICAgICAgZGlzcGF0Y2hBY3Rpb24oYWN0aW9uUXVldWUsIHBheWxvYWQsIHNldFN0YXRlKSxcbiAgICBhY3Rpb246IGFzeW5jIChzdGF0ZTogQXBwUm91dGVyU3RhdGUsIGFjdGlvbjogUmVkdWNlckFjdGlvbnMpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHJlZHVjZXIoc3RhdGUsIGFjdGlvbilcbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9LFxuICAgIHBlbmRpbmc6IG51bGwsXG4gICAgbGFzdDogbnVsbCxcbiAgICBvblJvdXRlclRyYW5zaXRpb25TdGFydDpcbiAgICAgIGluc3RydW1lbnRhdGlvbkhvb2tzICE9PSBudWxsICYmXG4gICAgICB0eXBlb2YgaW5zdHJ1bWVudGF0aW9uSG9va3Mub25Sb3V0ZXJUcmFuc2l0aW9uU3RhcnQgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyAvLyBUaGlzIHByb2ZpbGluZyBob29rIHdpbGwgYmUgY2FsbGVkIGF0IHRoZSBzdGFydCBvZiBldmVyeSBuYXZpZ2F0aW9uLlxuICAgICAgICAgIGluc3RydW1lbnRhdGlvbkhvb2tzLm9uUm91dGVyVHJhbnNpdGlvblN0YXJ0XG4gICAgICAgIDogbnVsbCxcbiAgfVxuXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIFRoZSBhY3Rpb24gcXVldWUgaXMgbGF6aWx5IGNyZWF0ZWQgb24gaHlkcmF0aW9uLCBidXQgYWZ0ZXIgdGhhdCBwb2ludFxuICAgIC8vIGl0IGRvZXNuJ3QgY2hhbmdlLiBTbyB3ZSBjYW4gc3RvcmUgaXQgaW4gYSBnbG9iYWwgcmF0aGVyIHRoYW4gcGFzc1xuICAgIC8vIGl0IGFyb3VuZCBldmVyeXdoZXJlIHZpYSBwcm9wcy9jb250ZXh0LlxuICAgIGlmIChnbG9iYWxBY3Rpb25RdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSW50ZXJuYWwgTmV4dC5qcyBFcnJvcjogY3JlYXRlTXV0YWJsZUFjdGlvblF1ZXVlIHdhcyBjYWxsZWQgbW9yZSAnICtcbiAgICAgICAgICAndGhhbiBvbmNlJ1xuICAgICAgKVxuICAgIH1cbiAgICBnbG9iYWxBY3Rpb25RdWV1ZSA9IGFjdGlvblF1ZXVlXG4gIH1cblxuICByZXR1cm4gYWN0aW9uUXVldWVcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEN1cnJlbnRBcHBSb3V0ZXJTdGF0ZSgpOiBBcHBSb3V0ZXJTdGF0ZSB8IG51bGwge1xuICByZXR1cm4gZ2xvYmFsQWN0aW9uUXVldWUgIT09IG51bGwgPyBnbG9iYWxBY3Rpb25RdWV1ZS5zdGF0ZSA6IG51bGxcbn1cblxuZnVuY3Rpb24gZ2V0QXBwUm91dGVyQWN0aW9uUXVldWUoKTogQXBwUm91dGVyQWN0aW9uUXVldWUge1xuICBpZiAoZ2xvYmFsQWN0aW9uUXVldWUgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnSW50ZXJuYWwgTmV4dC5qcyBlcnJvcjogUm91dGVyIGFjdGlvbiBkaXNwYXRjaGVkIGJlZm9yZSBpbml0aWFsaXphdGlvbi4nXG4gICAgKVxuICB9XG4gIHJldHVybiBnbG9iYWxBY3Rpb25RdWV1ZVxufVxuXG5mdW5jdGlvbiBnZXRQcm9maWxpbmdIb29rRm9yT25OYXZpZ2F0aW9uU3RhcnQoKSB7XG4gIGlmIChnbG9iYWxBY3Rpb25RdWV1ZSAhPT0gbnVsbCkge1xuICAgIHJldHVybiBnbG9iYWxBY3Rpb25RdWV1ZS5vblJvdXRlclRyYW5zaXRpb25TdGFydFxuICB9XG4gIHJldHVybiBudWxsXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXNwYXRjaE5hdmlnYXRlQWN0aW9uKFxuICBocmVmOiBzdHJpbmcsXG4gIG5hdmlnYXRlVHlwZTogTmF2aWdhdGVBY3Rpb25bJ25hdmlnYXRlVHlwZSddLFxuICBzaG91bGRTY3JvbGw6IGJvb2xlYW4sXG4gIGxpbmtJbnN0YW5jZVJlZjogTGlua0luc3RhbmNlIHwgbnVsbFxuKTogdm9pZCB7XG4gIC8vIFRPRE86IFRoaXMgc3R1ZmYgY291bGQganVzdCBnbyBpbnRvIHRoZSByZWR1Y2VyLiBMZWF2aW5nIGFzLWlzIGZvciBub3dcbiAgLy8gc2luY2Ugd2UncmUgYWJvdXQgdG8gcmV3cml0ZSBhbGwgdGhlIHJvdXRlciByZWR1Y2VyIHN0dWZmIGFueXdheS5cbiAgY29uc3QgdXJsID0gbmV3IFVSTChhZGRCYXNlUGF0aChocmVmKSwgbG9jYXRpb24uaHJlZilcbiAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9BUFBfTkFWX0ZBSUxfSEFORExJTkcpIHtcbiAgICB3aW5kb3cubmV4dC5fX3BlbmRpbmdVcmwgPSB1cmxcbiAgfVxuXG4gIHNldExpbmtGb3JDdXJyZW50TmF2aWdhdGlvbihsaW5rSW5zdGFuY2VSZWYpXG5cbiAgY29uc3Qgb25Sb3V0ZXJUcmFuc2l0aW9uU3RhcnQgPSBnZXRQcm9maWxpbmdIb29rRm9yT25OYXZpZ2F0aW9uU3RhcnQoKVxuICBpZiAob25Sb3V0ZXJUcmFuc2l0aW9uU3RhcnQgIT09IG51bGwpIHtcbiAgICBvblJvdXRlclRyYW5zaXRpb25TdGFydChocmVmLCBuYXZpZ2F0ZVR5cGUpXG4gIH1cblxuICBkaXNwYXRjaEFwcFJvdXRlckFjdGlvbih7XG4gICAgdHlwZTogQUNUSU9OX05BVklHQVRFLFxuICAgIHVybCxcbiAgICBpc0V4dGVybmFsVXJsOiBpc0V4dGVybmFsVVJMKHVybCksXG4gICAgbG9jYXRpb25TZWFyY2g6IGxvY2F0aW9uLnNlYXJjaCxcbiAgICBzaG91bGRTY3JvbGwsXG4gICAgbmF2aWdhdGVUeXBlLFxuICAgIGFsbG93QWxpYXNpbmc6IHRydWUsXG4gIH0pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXNwYXRjaFRyYXZlcnNlQWN0aW9uKFxuICBocmVmOiBzdHJpbmcsXG4gIHRyZWU6IEZsaWdodFJvdXRlclN0YXRlIHwgdW5kZWZpbmVkXG4pIHtcbiAgY29uc3Qgb25Sb3V0ZXJUcmFuc2l0aW9uU3RhcnQgPSBnZXRQcm9maWxpbmdIb29rRm9yT25OYXZpZ2F0aW9uU3RhcnQoKVxuICBpZiAob25Sb3V0ZXJUcmFuc2l0aW9uU3RhcnQgIT09IG51bGwpIHtcbiAgICBvblJvdXRlclRyYW5zaXRpb25TdGFydChocmVmLCAndHJhdmVyc2UnKVxuICB9XG4gIGRpc3BhdGNoQXBwUm91dGVyQWN0aW9uKHtcbiAgICB0eXBlOiBBQ1RJT05fUkVTVE9SRSxcbiAgICB1cmw6IG5ldyBVUkwoaHJlZiksXG4gICAgdHJlZSxcbiAgfSlcbn1cblxuLyoqXG4gKiBUaGUgYXBwIHJvdXRlciB0aGF0IGlzIGV4cG9zZWQgdGhyb3VnaCBgdXNlUm91dGVyYC4gVGhlc2UgYXJlIHB1YmxpYyBBUElcbiAqIG1ldGhvZHMuIEludGVybmFsIE5leHQuanMgY29kZSBzaG91bGQgY2FsbCB0aGUgbG93ZXIgbGV2ZWwgbWV0aG9kcyBkaXJlY3RseVxuICogKGFsdGhvdWdoIHRoZXJlJ3MgbG90cyBvZiBleGlzdGluZyBjb2RlIHRoYXQgZG9lc24ndCBkbyB0aGF0KS5cbiAqL1xuZXhwb3J0IGNvbnN0IHB1YmxpY0FwcFJvdXRlckluc3RhbmNlOiBBcHBSb3V0ZXJJbnN0YW5jZSA9IHtcbiAgYmFjazogKCkgPT4gd2luZG93Lmhpc3RvcnkuYmFjaygpLFxuICBmb3J3YXJkOiAoKSA9PiB3aW5kb3cuaGlzdG9yeS5mb3J3YXJkKCksXG4gIHByZWZldGNoOiBwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1NFR01FTlRfQ0FDSEVcbiAgICA/IC8vIFVubGlrZSB0aGUgb2xkIGltcGxlbWVudGF0aW9uLCB0aGUgU2VnbWVudCBDYWNoZSBkb2Vzbid0IHN0b3JlIGl0c1xuICAgICAgLy8gZGF0YSBpbiB0aGUgcm91dGVyIHJlZHVjZXIgc3RhdGU7IGl0IHdyaXRlcyBpbnRvIGEgZ2xvYmFsIG11dGFibGVcbiAgICAgIC8vIGNhY2hlLiBTbyB3ZSBkb24ndCBuZWVkIHRvIGRpc3BhdGNoIGFuIGFjdGlvbi5cbiAgICAgIChocmVmOiBzdHJpbmcsIG9wdGlvbnM/OiBQcmVmZXRjaE9wdGlvbnMpID0+IHtcbiAgICAgICAgY29uc3QgYWN0aW9uUXVldWUgPSBnZXRBcHBSb3V0ZXJBY3Rpb25RdWV1ZSgpXG4gICAgICAgIGNvbnN0IHByZWZldGNoS2luZCA9IG9wdGlvbnM/LmtpbmQgPz8gUHJlZmV0Y2hLaW5kLkFVVE9cblxuICAgICAgICAvLyBXZSBkb24ndCBjdXJyZW50bHkgb2ZmZXIgYSB3YXkgdG8gaXNzdWUgYSBydW50aW1lIHByZWZldGNoIHZpYSBgcm91dGVyLnByZWZldGNoKClgLlxuICAgICAgICAvLyBUaGlzIHdpbGwgYmUgcG9zc2libGUgd2hlbiB3ZSB1cGRhdGUgaXRzIEFQSSB0byBub3QgdGFrZSBhIFByZWZldGNoS2luZC5cbiAgICAgICAgbGV0IGZldGNoU3RyYXRlZ3k6IFByZWZldGNoVGFza0ZldGNoU3RyYXRlZ3lcbiAgICAgICAgc3dpdGNoIChwcmVmZXRjaEtpbmQpIHtcbiAgICAgICAgICBjYXNlIFByZWZldGNoS2luZC5BVVRPOiB7XG4gICAgICAgICAgICAvLyBXZSBkZWZhdWx0IHRvIFBQUi4gV2UnbGwgZGlzY292ZXIgd2hldGhlciBvciBub3QgdGhlIHJvdXRlIHN1cHBvcnRzIGl0IHdpdGggdGhlIGluaXRpYWwgcHJlZmV0Y2guXG4gICAgICAgICAgICBmZXRjaFN0cmF0ZWd5ID0gRmV0Y2hTdHJhdGVneS5QUFJcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgUHJlZmV0Y2hLaW5kLkZVTEw6IHtcbiAgICAgICAgICAgIGZldGNoU3RyYXRlZ3kgPSBGZXRjaFN0cmF0ZWd5LkZ1bGxcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgUHJlZmV0Y2hLaW5kLlRFTVBPUkFSWToge1xuICAgICAgICAgICAgLy8gVGhpcyBjb25jZXB0IGRvZXNuJ3QgZXhpc3QgaW4gdGhlIHNlZ21lbnQgY2FjaGUgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgcHJlZmV0Y2hLaW5kIHNhdGlzZmllcyBuZXZlclxuICAgICAgICAgICAgLy8gRGVzcGl0ZSB0eXBlc2NyaXB0IHRoaW5raW5nIHRoYXQgdGhpcyBjYW4ndCBoYXBwZW4sXG4gICAgICAgICAgICAvLyB3ZSBtaWdodCBnZXQgYW4gdW5leHBlY3RlZCB2YWx1ZSBmcm9tIHVzZXIgY29kZS5cbiAgICAgICAgICAgIC8vIFdlIGRvbid0IGtub3cgd2hhdCB0aGV5IHdhbnQsIGJ1dCB3ZSBrbm93IHRoZXkgd2FudCBhIHByZWZldGNoLFxuICAgICAgICAgICAgLy8gc28gdXNlIHRoZSBkZWZhdWx0LlxuICAgICAgICAgICAgZmV0Y2hTdHJhdGVneSA9IEZldGNoU3RyYXRlZ3kuUFBSXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcHJlZmV0Y2hXaXRoU2VnbWVudENhY2hlKFxuICAgICAgICAgIGhyZWYsXG4gICAgICAgICAgYWN0aW9uUXVldWUuc3RhdGUubmV4dFVybCxcbiAgICAgICAgICBhY3Rpb25RdWV1ZS5zdGF0ZS50cmVlLFxuICAgICAgICAgIGZldGNoU3RyYXRlZ3ksXG4gICAgICAgICAgb3B0aW9ucz8ub25JbnZhbGlkYXRlID8/IG51bGxcbiAgICAgICAgKVxuICAgICAgfVxuICAgIDogKGhyZWY6IHN0cmluZywgb3B0aW9ucz86IFByZWZldGNoT3B0aW9ucykgPT4ge1xuICAgICAgICAvLyBVc2UgdGhlIG9sZCBwcmVmZXRjaCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgY29uc3QgYWN0aW9uUXVldWUgPSBnZXRBcHBSb3V0ZXJBY3Rpb25RdWV1ZSgpXG4gICAgICAgIGNvbnN0IHVybCA9IGNyZWF0ZVByZWZldGNoVVJMKGhyZWYpXG4gICAgICAgIGlmICh1cmwgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBUaGUgcHJlZmV0Y2ggcmVkdWNlciBkb2Vzbid0IGFjdHVhbGx5IHVwZGF0ZSBhbnkgc3RhdGUgb3JcbiAgICAgICAgICAvLyB0cmlnZ2VyIGEgcmVyZW5kZXIuIEl0IGp1c3Qgd3JpdGVzIHRvIGEgbXV0YWJsZSBjYWNoZS4gU28gd2VcbiAgICAgICAgICAvLyBzaG91bGRuJ3QgYm90aGVyIGNhbGxpbmcgc2V0U3RhdGUvZGlzcGF0Y2g7IHdlIGNhbiBqdXN0IHJlLXJ1blxuICAgICAgICAgIC8vIHRoZSByZWR1Y2VyIGRpcmVjdGx5IHVzaW5nIHRoZSBjdXJyZW50IHN0YXRlLlxuICAgICAgICAgIC8vIFRPRE86IFJlZmFjdG9yIHRoaXMgYXdheSBmcm9tIGEgXCJyZWR1Y2VyXCIgc28gaXQnc1xuICAgICAgICAgIC8vIGxlc3MgY29uZnVzaW5nLlxuICAgICAgICAgIHByZWZldGNoUmVkdWNlcihhY3Rpb25RdWV1ZS5zdGF0ZSwge1xuICAgICAgICAgICAgdHlwZTogQUNUSU9OX1BSRUZFVENILFxuICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAga2luZDogb3B0aW9ucz8ua2luZCA/PyBQcmVmZXRjaEtpbmQuRlVMTCxcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9LFxuICByZXBsYWNlOiAoaHJlZjogc3RyaW5nLCBvcHRpb25zPzogTmF2aWdhdGVPcHRpb25zKSA9PiB7XG4gICAgc3RhcnRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgIGRpc3BhdGNoTmF2aWdhdGVBY3Rpb24oaHJlZiwgJ3JlcGxhY2UnLCBvcHRpb25zPy5zY3JvbGwgPz8gdHJ1ZSwgbnVsbClcbiAgICB9KVxuICB9LFxuICBwdXNoOiAoaHJlZjogc3RyaW5nLCBvcHRpb25zPzogTmF2aWdhdGVPcHRpb25zKSA9PiB7XG4gICAgc3RhcnRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgIGRpc3BhdGNoTmF2aWdhdGVBY3Rpb24oaHJlZiwgJ3B1c2gnLCBvcHRpb25zPy5zY3JvbGwgPz8gdHJ1ZSwgbnVsbClcbiAgICB9KVxuICB9LFxuICByZWZyZXNoOiAoKSA9PiB7XG4gICAgc3RhcnRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgIGRpc3BhdGNoQXBwUm91dGVyQWN0aW9uKHtcbiAgICAgICAgdHlwZTogQUNUSU9OX1JFRlJFU0gsXG4gICAgICAgIG9yaWdpbjogd2luZG93LmxvY2F0aW9uLm9yaWdpbixcbiAgICAgIH0pXG4gICAgfSlcbiAgfSxcbiAgaG1yUmVmcmVzaDogKCkgPT4ge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnaG1yUmVmcmVzaCBjYW4gb25seSBiZSB1c2VkIGluIGRldmVsb3BtZW50IG1vZGUuIFBsZWFzZSB1c2UgcmVmcmVzaCBpbnN0ZWFkLidcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgICAgZGlzcGF0Y2hBcHBSb3V0ZXJBY3Rpb24oe1xuICAgICAgICAgIHR5cGU6IEFDVElPTl9ITVJfUkVGUkVTSCxcbiAgICAgICAgICBvcmlnaW46IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4sXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH1cbiAgfSxcbn1cblxuLy8gRXhpc3RzIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMuIERvbid0IHVzZSBpbiBhcHBsaWNhdGlvbiBjb2RlLlxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5uZXh0KSB7XG4gIHdpbmRvdy5uZXh0LnJvdXRlciA9IHB1YmxpY0FwcFJvdXRlckluc3RhbmNlXG59XG4iXSwibmFtZXMiOlsiY3JlYXRlTXV0YWJsZUFjdGlvblF1ZXVlIiwiZGlzcGF0Y2hOYXZpZ2F0ZUFjdGlvbiIsImRpc3BhdGNoVHJhdmVyc2VBY3Rpb24iLCJnZXRDdXJyZW50QXBwUm91dGVyU3RhdGUiLCJwdWJsaWNBcHBSb3V0ZXJJbnN0YW5jZSIsInJ1blJlbWFpbmluZ0FjdGlvbnMiLCJhY3Rpb25RdWV1ZSIsInNldFN0YXRlIiwicGVuZGluZyIsIm5leHQiLCJydW5BY3Rpb24iLCJhY3Rpb24iLCJuZWVkc1JlZnJlc2giLCJkaXNwYXRjaCIsInR5cGUiLCJBQ1RJT05fUkVGUkVTSCIsIm9yaWdpbiIsIndpbmRvdyIsImxvY2F0aW9uIiwicHJldlN0YXRlIiwic3RhdGUiLCJwYXlsb2FkIiwiYWN0aW9uUmVzdWx0IiwiaGFuZGxlUmVzdWx0IiwibmV4dFN0YXRlIiwiZGlzY2FyZGVkIiwicmVzb2x2ZSIsImlzVGhlbmFibGUiLCJ0aGVuIiwiZXJyIiwicmVqZWN0IiwiZGlzcGF0Y2hBY3Rpb24iLCJyZXNvbHZlcnMiLCJBQ1RJT05fUkVTVE9SRSIsImRlZmVycmVkUHJvbWlzZSIsIlByb21pc2UiLCJzdGFydFRyYW5zaXRpb24iLCJuZXdBY3Rpb24iLCJsYXN0IiwiQUNUSU9OX05BVklHQVRFIiwiQUNUSU9OX1NFUlZFUl9BQ1RJT04iLCJnbG9iYWxBY3Rpb25RdWV1ZSIsImluaXRpYWxTdGF0ZSIsImluc3RydW1lbnRhdGlvbkhvb2tzIiwicmVzdWx0IiwicmVkdWNlciIsIm9uUm91dGVyVHJhbnNpdGlvblN0YXJ0IiwiRXJyb3IiLCJnZXRBcHBSb3V0ZXJBY3Rpb25RdWV1ZSIsImdldFByb2ZpbGluZ0hvb2tGb3JPbk5hdmlnYXRpb25TdGFydCIsImhyZWYiLCJuYXZpZ2F0ZVR5cGUiLCJzaG91bGRTY3JvbGwiLCJsaW5rSW5zdGFuY2VSZWYiLCJ1cmwiLCJVUkwiLCJhZGRCYXNlUGF0aCIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfQVBQX05BVl9GQUlMX0hBTkRMSU5HIiwiX19wZW5kaW5nVXJsIiwic2V0TGlua0ZvckN1cnJlbnROYXZpZ2F0aW9uIiwiZGlzcGF0Y2hBcHBSb3V0ZXJBY3Rpb24iLCJpc0V4dGVybmFsVXJsIiwiaXNFeHRlcm5hbFVSTCIsImxvY2F0aW9uU2VhcmNoIiwic2VhcmNoIiwiYWxsb3dBbGlhc2luZyIsInRyZWUiLCJiYWNrIiwiaGlzdG9yeSIsImZvcndhcmQiLCJwcmVmZXRjaCIsIl9fTkVYVF9DTElFTlRfU0VHTUVOVF9DQUNIRSIsIm9wdGlvbnMiLCJwcmVmZXRjaEtpbmQiLCJraW5kIiwiUHJlZmV0Y2hLaW5kIiwiQVVUTyIsImZldGNoU3RyYXRlZ3kiLCJGZXRjaFN0cmF0ZWd5IiwiUFBSIiwiRlVMTCIsIkZ1bGwiLCJURU1QT1JBUlkiLCJwcmVmZXRjaFdpdGhTZWdtZW50Q2FjaGUiLCJuZXh0VXJsIiwib25JbnZhbGlkYXRlIiwiY3JlYXRlUHJlZmV0Y2hVUkwiLCJwcmVmZXRjaFJlZHVjZXIiLCJBQ1RJT05fUFJFRkVUQ0giLCJyZXBsYWNlIiwic2Nyb2xsIiwicHVzaCIsInJlZnJlc2giLCJobXJSZWZyZXNoIiwiTk9ERV9FTlYiLCJBQ1RJT05fSE1SX1JFRlJFU0giLCJyb3V0ZXIiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/app-router-instance.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/app-router.js":
/*!********************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/app-router.js ***!
  \********************************************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nvar _s = $RefreshSig$();\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createEmptyCacheNode: function() {\n        return createEmptyCacheNode;\n    },\n    createPrefetchURL: function() {\n        return createPrefetchURL;\n    },\n    default: function() {\n        return AppRouter;\n    },\n    isExternalURL: function() {\n        return isExternalURL;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.15/node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.15/node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/compiled/react/index.js\"));\nconst _approutercontextsharedruntime = __webpack_require__(/*! ../../shared/lib/app-router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\");\nconst _routerreducertypes = __webpack_require__(/*! ./router-reducer/router-reducer-types */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nconst _createhreffromurl = __webpack_require__(/*! ./router-reducer/create-href-from-url */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\");\nconst _hooksclientcontextsharedruntime = __webpack_require__(/*! ../../shared/lib/hooks-client-context.shared-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/shared/lib/hooks-client-context.shared-runtime.js\");\nconst _useactionqueue = __webpack_require__(/*! ./use-action-queue */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/use-action-queue.js\");\nconst _isbot = __webpack_require__(/*! ../../shared/lib/router/utils/is-bot */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/shared/lib/router/utils/is-bot.js\");\nconst _addbasepath = __webpack_require__(/*! ../add-base-path */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/add-base-path.js\");\nconst _approuterannouncer = __webpack_require__(/*! ./app-router-announcer */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/app-router-announcer.js\");\nconst _redirectboundary = __webpack_require__(/*! ./redirect-boundary */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/redirect-boundary.js\");\nconst _findheadincache = __webpack_require__(/*! ./router-reducer/reducers/find-head-in-cache */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/router-reducer/reducers/find-head-in-cache.js\");\nconst _unresolvedthenable = __webpack_require__(/*! ./unresolved-thenable */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/unresolved-thenable.js\");\nconst _removebasepath = __webpack_require__(/*! ../remove-base-path */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/remove-base-path.js\");\nconst _hasbasepath = __webpack_require__(/*! ../has-base-path */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/has-base-path.js\");\nconst _computechangedpath = __webpack_require__(/*! ./router-reducer/compute-changed-path */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/router-reducer/compute-changed-path.js\");\nconst _navfailurehandler = __webpack_require__(/*! ./nav-failure-handler */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/nav-failure-handler.js\");\nconst _approuterinstance = __webpack_require__(/*! ./app-router-instance */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/app-router-instance.js\");\nconst _redirect = __webpack_require__(/*! ./redirect */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/redirect.js\");\nconst _redirecterror = __webpack_require__(/*! ./redirect-error */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/redirect-error.js\");\nconst _links = __webpack_require__(/*! ./links */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/links.js\");\nconst _rooterrorboundary = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./errors/root-error-boundary */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/errors/root-error-boundary.js\"));\nconst _globalerror = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./builtin/global-error */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/builtin/global-error.js\"));\nconst _boundarycomponents = __webpack_require__(/*! ../../lib/framework/boundary-components */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/lib/framework/boundary-components.js\");\nconst globalMutable = {};\nfunction isExternalURL(url) {\n    return url.origin !== window.location.origin;\n}\nfunction createPrefetchURL(href) {\n    // Don't prefetch for bots as they don't navigate.\n    if ((0, _isbot.isBot)(window.navigator.userAgent)) {\n        return null;\n    }\n    let url;\n    try {\n        url = new URL((0, _addbasepath.addBasePath)(href), window.location.href);\n    } catch (_) {\n        // TODO: Does this need to throw or can we just console.error instead? Does\n        // anyone rely on this throwing? (Seems unlikely.)\n        throw Object.defineProperty(new Error(\"Cannot prefetch '\" + href + \"' because it cannot be converted to a URL.\"), \"__NEXT_ERROR_CODE\", {\n            value: \"E234\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    // Don't prefetch during development (improves compilation performance)\n    if (true) {\n        return null;\n    }\n    // External urls can't be prefetched in the same way.\n    if (isExternalURL(url)) {\n        return null;\n    }\n    return url;\n}\nfunction HistoryUpdater(param) {\n    let { appRouterState } = param;\n    (0, _react.useInsertionEffect)(()=>{\n        if (false) {}\n        const { tree, pushRef, canonicalUrl } = appRouterState;\n        const historyState = {\n            ...pushRef.preserveCustomHistoryState ? window.history.state : {},\n            // Identifier is shortened intentionally.\n            // __NA is used to identify if the history entry can be handled by the app-router.\n            // __N is used to identify if the history entry can be handled by the old router.\n            __NA: true,\n            __PRIVATE_NEXTJS_INTERNALS_TREE: tree\n        };\n        if (pushRef.pendingPush && // Skip pushing an additional history entry if the canonicalUrl is the same as the current url.\n        // This mirrors the browser behavior for normal navigation.\n        (0, _createhreffromurl.createHrefFromUrl)(new URL(window.location.href)) !== canonicalUrl) {\n            // This intentionally mutates React state, pushRef is overwritten to ensure additional push/replace calls do not trigger an additional history entry.\n            pushRef.pendingPush = false;\n            window.history.pushState(historyState, '', canonicalUrl);\n        } else {\n            window.history.replaceState(historyState, '', canonicalUrl);\n        }\n    }, [\n        appRouterState\n    ]);\n    (0, _react.useEffect)(()=>{\n        // The Next-Url and the base tree may affect the result of a prefetch\n        // task. Re-prefetch all visible links with the updated values. In most\n        // cases, this will not result in any new network requests, only if\n        // the prefetch result actually varies on one of these inputs.\n        if (false) {}\n    }, [\n        appRouterState.nextUrl,\n        appRouterState.tree\n    ]);\n    return null;\n}\n_c = HistoryUpdater;\nfunction createEmptyCacheNode() {\n    return {\n        lazyData: null,\n        rsc: null,\n        prefetchRsc: null,\n        head: null,\n        prefetchHead: null,\n        parallelRoutes: new Map(),\n        loading: null,\n        navigatedAt: -1\n    };\n}\nfunction copyNextJsInternalHistoryState(data) {\n    if (data == null) data = {};\n    const currentState = window.history.state;\n    const __NA = currentState == null ? void 0 : currentState.__NA;\n    if (__NA) {\n        data.__NA = __NA;\n    }\n    const __PRIVATE_NEXTJS_INTERNALS_TREE = currentState == null ? void 0 : currentState.__PRIVATE_NEXTJS_INTERNALS_TREE;\n    if (__PRIVATE_NEXTJS_INTERNALS_TREE) {\n        data.__PRIVATE_NEXTJS_INTERNALS_TREE = __PRIVATE_NEXTJS_INTERNALS_TREE;\n    }\n    return data;\n}\nfunction Head(param) {\n    let { headCacheNode } = param;\n    // If this segment has a `prefetchHead`, it's the statically prefetched data.\n    // We should use that on initial render instead of `head`. Then we'll switch\n    // to `head` when the dynamic response streams in.\n    const head = headCacheNode !== null ? headCacheNode.head : null;\n    const prefetchHead = headCacheNode !== null ? headCacheNode.prefetchHead : null;\n    // If no prefetch data is available, then we go straight to rendering `head`.\n    const resolvedPrefetchRsc = prefetchHead !== null ? prefetchHead : head;\n    // We use `useDeferredValue` to handle switching between the prefetched and\n    // final values. The second argument is returned on initial render, then it\n    // re-renders with the first argument.\n    return (0, _react.useDeferredValue)(head, resolvedPrefetchRsc);\n}\n_c1 = Head;\n/**\n * The global router that wraps the application components.\n */ function Router(param) {\n    let { actionQueue, assetPrefix, globalError } = param;\n    const state = (0, _useactionqueue.useActionQueue)(actionQueue);\n    const { canonicalUrl } = state;\n    // Add memoized pathname/query for useSearchParams and usePathname.\n    const { searchParams, pathname } = (0, _react.useMemo)(()=>{\n        const url = new URL(canonicalUrl,  false ? 0 : window.location.href);\n        return {\n            // This is turned into a readonly class in `useSearchParams`\n            searchParams: url.searchParams,\n            pathname: (0, _hasbasepath.hasBasePath)(url.pathname) ? (0, _removebasepath.removeBasePath)(url.pathname) : url.pathname\n        };\n    }, [\n        canonicalUrl\n    ]);\n    if (true) {\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        const { cache, prefetchCache, tree } = state;\n        // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        (0, _react.useEffect)(()=>{\n            // Add `window.nd` for debugging purposes.\n            // This is not meant for use in applications as concurrent rendering will affect the cache/tree/router.\n            // @ts-ignore this is for debugging\n            window.nd = {\n                router: _approuterinstance.publicAppRouterInstance,\n                cache,\n                prefetchCache,\n                tree\n            };\n        }, [\n            cache,\n            prefetchCache,\n            tree\n        ]);\n    }\n    (0, _react.useEffect)(()=>{\n        // If the app is restored from bfcache, it's possible that\n        // pushRef.mpaNavigation is true, which would mean that any re-render of this component\n        // would trigger the mpa navigation logic again from the lines below.\n        // This will restore the router to the initial state in the event that the app is restored from bfcache.\n        function handlePageShow(event) {\n            var _window_history_state;\n            if (!event.persisted || !((_window_history_state = window.history.state) == null ? void 0 : _window_history_state.__PRIVATE_NEXTJS_INTERNALS_TREE)) {\n                return;\n            }\n            // Clear the pendingMpaPath value so that a subsequent MPA navigation to the same URL can be triggered.\n            // This is necessary because if the browser restored from bfcache, the pendingMpaPath would still be set to the value\n            // of the last MPA navigation.\n            globalMutable.pendingMpaPath = undefined;\n            (0, _useactionqueue.dispatchAppRouterAction)({\n                type: _routerreducertypes.ACTION_RESTORE,\n                url: new URL(window.location.href),\n                tree: window.history.state.__PRIVATE_NEXTJS_INTERNALS_TREE\n            });\n        }\n        window.addEventListener('pageshow', handlePageShow);\n        return ()=>{\n            window.removeEventListener('pageshow', handlePageShow);\n        };\n    }, []);\n    (0, _react.useEffect)(()=>{\n        // Ensure that any redirect errors that bubble up outside of the RedirectBoundary\n        // are caught and handled by the router.\n        function handleUnhandledRedirect(event) {\n            const error = 'reason' in event ? event.reason : event.error;\n            if ((0, _redirecterror.isRedirectError)(error)) {\n                event.preventDefault();\n                const url = (0, _redirect.getURLFromRedirectError)(error);\n                const redirectType = (0, _redirect.getRedirectTypeFromError)(error);\n                // TODO: This should access the router methods directly, rather than\n                // go through the public interface.\n                if (redirectType === _redirecterror.RedirectType.push) {\n                    _approuterinstance.publicAppRouterInstance.push(url, {});\n                } else {\n                    _approuterinstance.publicAppRouterInstance.replace(url, {});\n                }\n            }\n        }\n        window.addEventListener('error', handleUnhandledRedirect);\n        window.addEventListener('unhandledrejection', handleUnhandledRedirect);\n        return ()=>{\n            window.removeEventListener('error', handleUnhandledRedirect);\n            window.removeEventListener('unhandledrejection', handleUnhandledRedirect);\n        };\n    }, []);\n    // When mpaNavigation flag is set do a hard navigation to the new url.\n    // Infinitely suspend because we don't actually want to rerender any child\n    // components with the new URL and any entangled state updates shouldn't\n    // commit either (eg: useTransition isPending should stay true until the page\n    // unloads).\n    //\n    // This is a side effect in render. Don't try this at home, kids. It's\n    // probably safe because we know this is a singleton component and it's never\n    // in <Offscreen>. At least I hope so. (It will run twice in dev strict mode,\n    // but that's... fine?)\n    const { pushRef } = state;\n    if (pushRef.mpaNavigation) {\n        // if there's a re-render, we don't want to trigger another redirect if one is already in flight to the same URL\n        if (globalMutable.pendingMpaPath !== canonicalUrl) {\n            const location = window.location;\n            if (pushRef.pendingPush) {\n                location.assign(canonicalUrl);\n            } else {\n                location.replace(canonicalUrl);\n            }\n            globalMutable.pendingMpaPath = canonicalUrl;\n        }\n        // TODO-APP: Should we listen to navigateerror here to catch failed\n        // navigations somehow? And should we call window.stop() if a SPA navigation\n        // should interrupt an MPA one?\n        // NOTE: This is intentionally using `throw` instead of `use` because we're\n        // inside an externally mutable condition (pushRef.mpaNavigation), which\n        // violates the rules of hooks.\n        throw _unresolvedthenable.unresolvedThenable;\n    }\n    (0, _react.useEffect)(()=>{\n        const originalPushState = window.history.pushState.bind(window.history);\n        const originalReplaceState = window.history.replaceState.bind(window.history);\n        // Ensure the canonical URL in the Next.js Router is updated when the URL is changed so that `usePathname` and `useSearchParams` hold the pushed values.\n        const applyUrlFromHistoryPushReplace = (url)=>{\n            var _window_history_state;\n            const href = window.location.href;\n            const tree = (_window_history_state = window.history.state) == null ? void 0 : _window_history_state.__PRIVATE_NEXTJS_INTERNALS_TREE;\n            (0, _react.startTransition)(()=>{\n                (0, _useactionqueue.dispatchAppRouterAction)({\n                    type: _routerreducertypes.ACTION_RESTORE,\n                    url: new URL(url != null ? url : href, href),\n                    tree\n                });\n            });\n        };\n        /**\n     * Patch pushState to ensure external changes to the history are reflected in the Next.js Router.\n     * Ensures Next.js internal history state is copied to the new history entry.\n     * Ensures usePathname and useSearchParams hold the newly provided url.\n     */ window.history.pushState = function pushState(data, _unused, url) {\n            // Avoid a loop when Next.js internals trigger pushState/replaceState\n            if ((data == null ? void 0 : data.__NA) || (data == null ? void 0 : data._N)) {\n                return originalPushState(data, _unused, url);\n            }\n            data = copyNextJsInternalHistoryState(data);\n            if (url) {\n                applyUrlFromHistoryPushReplace(url);\n            }\n            return originalPushState(data, _unused, url);\n        };\n        /**\n     * Patch replaceState to ensure external changes to the history are reflected in the Next.js Router.\n     * Ensures Next.js internal history state is copied to the new history entry.\n     * Ensures usePathname and useSearchParams hold the newly provided url.\n     */ window.history.replaceState = function replaceState(data, _unused, url) {\n            // Avoid a loop when Next.js internals trigger pushState/replaceState\n            if ((data == null ? void 0 : data.__NA) || (data == null ? void 0 : data._N)) {\n                return originalReplaceState(data, _unused, url);\n            }\n            data = copyNextJsInternalHistoryState(data);\n            if (url) {\n                applyUrlFromHistoryPushReplace(url);\n            }\n            return originalReplaceState(data, _unused, url);\n        };\n        /**\n     * Handle popstate event, this is used to handle back/forward in the browser.\n     * By default dispatches ACTION_RESTORE, however if the history entry was not pushed/replaced by app-router it will reload the page.\n     * That case can happen when the old router injected the history entry.\n     */ const onPopState = (event)=>{\n            if (!event.state) {\n                // TODO-APP: this case only happens when pushState/replaceState was called outside of Next.js. It should probably reload the page in this case.\n                return;\n            }\n            // This case happens when the history entry was pushed by the `pages` router.\n            if (!event.state.__NA) {\n                window.location.reload();\n                return;\n            }\n            // TODO-APP: Ideally the back button should not use startTransition as it should apply the updates synchronously\n            // Without startTransition works if the cache is there for this path\n            (0, _react.startTransition)(()=>{\n                (0, _approuterinstance.dispatchTraverseAction)(window.location.href, event.state.__PRIVATE_NEXTJS_INTERNALS_TREE);\n            });\n        };\n        // Register popstate event to call onPopstate.\n        window.addEventListener('popstate', onPopState);\n        return ()=>{\n            window.history.pushState = originalPushState;\n            window.history.replaceState = originalReplaceState;\n            window.removeEventListener('popstate', onPopState);\n        };\n    }, []);\n    const { cache, tree, nextUrl, focusAndScrollRef } = state;\n    const matchingHead = (0, _react.useMemo)(()=>{\n        return (0, _findheadincache.findHeadInCache)(cache, tree[1]);\n    }, [\n        cache,\n        tree\n    ]);\n    // Add memoized pathParams for useParams.\n    const pathParams = (0, _react.useMemo)(()=>{\n        return (0, _computechangedpath.getSelectedParams)(tree);\n    }, [\n        tree\n    ]);\n    const layoutRouterContext = (0, _react.useMemo)(()=>{\n        return {\n            parentTree: tree,\n            parentCacheNode: cache,\n            parentSegmentPath: null,\n            // Root node always has `url`\n            // Provided in AppTreeContext to ensure it can be overwritten in layout-router\n            url: canonicalUrl\n        };\n    }, [\n        tree,\n        cache,\n        canonicalUrl\n    ]);\n    const globalLayoutRouterContext = (0, _react.useMemo)(()=>{\n        return {\n            tree,\n            focusAndScrollRef,\n            nextUrl\n        };\n    }, [\n        tree,\n        focusAndScrollRef,\n        nextUrl\n    ]);\n    let head;\n    if (matchingHead !== null) {\n        // The head is wrapped in an extra component so we can use\n        // `useDeferredValue` to swap between the prefetched and final versions of\n        // the head. (This is what LayoutRouter does for segment data, too.)\n        //\n        // The `key` is used to remount the component whenever the head moves to\n        // a different segment.\n        const [headCacheNode, headKey, headKeyWithoutSearchParams] = matchingHead;\n        head = /*#__PURE__*/ (0, _jsxruntime.jsx)(Head, {\n            headCacheNode: headCacheNode\n        },  false ? 0 : headKey);\n    } else {\n        head = null;\n    }\n    let content = /*#__PURE__*/ (0, _jsxruntime.jsxs)(_redirectboundary.RedirectBoundary, {\n        children: [\n            head,\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(_boundarycomponents.RootLayoutBoundary, {\n                children: cache.rsc\n            }),\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(_approuterannouncer.AppRouterAnnouncer, {\n                tree: tree\n            })\n        ]\n    });\n    if (true) {\n        // In development, we apply few error boundaries and hot-reloader:\n        // - DevRootHTTPAccessFallbackBoundary: avoid using navigation API like notFound() in root layout\n        // - HotReloader:\n        //  - hot-reload the app when the code changes\n        //  - render dev overlay\n        //  - catch runtime errors and display global-error when necessary\n        if (true) {\n            const { DevRootHTTPAccessFallbackBoundary } = __webpack_require__(/*! ./dev-root-http-access-fallback-boundary */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/dev-root-http-access-fallback-boundary.js\");\n            content = /*#__PURE__*/ (0, _jsxruntime.jsx)(DevRootHTTPAccessFallbackBoundary, {\n                children: content\n            });\n        }\n        const HotReloader = (__webpack_require__(/*! ../dev/hot-reloader/app/hot-reloader-app */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/dev/hot-reloader/app/hot-reloader-app.js\")[\"default\"]);\n        content = /*#__PURE__*/ (0, _jsxruntime.jsx)(HotReloader, {\n            assetPrefix: assetPrefix,\n            globalError: globalError,\n            children: content\n        });\n    } else {}\n    return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n        children: [\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(HistoryUpdater, {\n                appRouterState: state\n            }),\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(RuntimeStyles, {}),\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(_hooksclientcontextsharedruntime.PathParamsContext.Provider, {\n                value: pathParams,\n                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_hooksclientcontextsharedruntime.PathnameContext.Provider, {\n                    value: pathname,\n                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_hooksclientcontextsharedruntime.SearchParamsContext.Provider, {\n                        value: searchParams,\n                        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_approutercontextsharedruntime.GlobalLayoutRouterContext.Provider, {\n                            value: globalLayoutRouterContext,\n                            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_approutercontextsharedruntime.AppRouterContext.Provider, {\n                                value: _approuterinstance.publicAppRouterInstance,\n                                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_approutercontextsharedruntime.LayoutRouterContext.Provider, {\n                                    value: layoutRouterContext,\n                                    children: content\n                                })\n                            })\n                        })\n                    })\n                })\n            })\n        ]\n    });\n}\n_c2 = Router;\nfunction AppRouter(param) {\n    let { actionQueue, globalErrorState, assetPrefix } = param;\n    (0, _navfailurehandler.useNavFailureHandler)();\n    const router = /*#__PURE__*/ (0, _jsxruntime.jsx)(Router, {\n        actionQueue: actionQueue,\n        assetPrefix: assetPrefix,\n        globalError: globalErrorState\n    });\n    // At the very top level, use the default GlobalError component as the final fallback.\n    // When the app router itself fails, which means the framework itself fails, we show the default error.\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_rooterrorboundary.default, {\n        errorComponent: _globalerror.default,\n        children: router\n    });\n}\n_c3 = AppRouter;\nconst runtimeStyles = new Set();\nlet runtimeStyleChanged = new Set();\nglobalThis._N_E_STYLE_LOAD = function(href) {\n    let len = runtimeStyles.size;\n    runtimeStyles.add(href);\n    if (runtimeStyles.size !== len) {\n        runtimeStyleChanged.forEach((cb)=>cb());\n    }\n    // TODO figure out how to get a promise here\n    // But maybe it's not necessary as react would block rendering until it's loaded\n    return Promise.resolve();\n};\nfunction RuntimeStyles() {\n    _s();\n    const [, forceUpdate] = _react.default.useState(0);\n    const renderedStylesSize = runtimeStyles.size;\n    (0, _react.useEffect)(()=>{\n        const changed = ()=>forceUpdate((c)=>c + 1);\n        runtimeStyleChanged.add(changed);\n        if (renderedStylesSize !== runtimeStyles.size) {\n            changed();\n        }\n        return ()=>{\n            runtimeStyleChanged.delete(changed);\n        };\n    }, [\n        renderedStylesSize,\n        forceUpdate\n    ]);\n    const dplId =  false ? 0 : '';\n    return [\n        ...runtimeStyles\n    ].map((href, i)=>/*#__PURE__*/ (0, _jsxruntime.jsx)(\"link\", {\n            rel: \"stylesheet\",\n            href: \"\" + href + dplId,\n            // @ts-ignore\n            precedence: \"next\"\n        }, i));\n}\n_s(RuntimeStyles, \"Eht7Kgdrrgt5B4LSklQ7qDPo8Aw=\");\n_c4 = RuntimeStyles;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-router.js.map\nvar _c, _c1, _c2, _c3, _c4;\n$RefreshReg$(_c, \"HistoryUpdater\");\n$RefreshReg$(_c1, \"Head\");\n$RefreshReg$(_c2, \"Router\");\n$RefreshReg$(_c3, \"AppRouter\");\n$RefreshReg$(_c4, \"RuntimeStyles\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE1LjUuMTJfcmVhY3QtZG9tQDE5LjIuNF9yZWFjdEAxOS4yLjRfX3JlYWN0QDE5LjIuNC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2FwcC1yb3V0ZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7SUE2SWdCQSxvQkFBb0I7ZUFBcEJBOztJQTlFQUMsaUJBQWlCO2VBQWpCQTs7SUF3ZmhCLE9BMEJDO2VBMUJ1QkM7O0lBbmdCUkMsYUFBYTtlQUFiQTs7Ozs7OzZFQTVDVDsyREFLQTtnREFFd0I7K0NBRUc7NkRBSzNCOzRDQUNpRDttQ0FDbEM7eUNBQ007Z0RBQ087OENBQ0Y7NkNBQ0Q7Z0RBQ0c7NENBQ0o7eUNBQ0g7Z0RBQ007K0NBRUc7K0NBTTlCO3NDQUMyRDsyQ0FDcEI7bUNBQ2I7d0ZBQ0g7a0ZBQ0M7Z0RBQ0k7QUFFbkMsTUFBTUMsZ0JBRUYsQ0FBQztBQUVFLFNBQVNELGNBQWNFLEdBQVE7SUFDcEMsT0FBT0EsSUFBSUMsTUFBTSxLQUFLQyxPQUFPQyxRQUFRLENBQUNGLE1BQU07QUFDOUM7QUFTTyxTQUFTTCxrQkFBa0JRLElBQVk7SUFDNUMsa0RBQWtEO0lBQ2xELElBQUlDLENBQUFBLEdBQUFBLE9BQUFBLEtBQUFBLEVBQU1ILE9BQU9JLFNBQVMsQ0FBQ0MsU0FBUyxHQUFHO1FBQ3JDLE9BQU87SUFDVDtJQUVBLElBQUlQO0lBQ0osSUFBSTtRQUNGQSxNQUFNLElBQUlRLElBQUlDLENBQUFBLEdBQUFBLGFBQUFBLFdBQVcsRUFBQ0wsT0FBT0YsT0FBT0MsUUFBUSxDQUFDQyxJQUFJO0lBQ3ZELEVBQUUsT0FBT00sR0FBRztRQUNWLDJFQUEyRTtRQUMzRSxrREFBa0Q7UUFDbEQsTUFBTSxxQkFFTCxDQUZLLElBQUlDLE1BQ1Asc0JBQW1CUCxPQUFLLCtDQURyQjttQkFBQTt3QkFBQTswQkFBQTtRQUVOO0lBQ0Y7SUFFQSx1RUFB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LEdBQ25DLHFCQUFDQyxRQUFBQTtZQUVDQyxLQUFJO1lBQ0o5SixNQUFPLEtBQUVBLE9BQU95SjtZQUNoQixhQUFhO1lBQ2JNLFlBQVc7V0FKTkg7QUFVWDs7TUE3QlNsQyIsInNvdXJjZXMiOlsiL1VzZXJzL3NhYmluZXJlc29hZ2xpL3NyYy9jbGllbnQvY29tcG9uZW50cy9hcHAtcm91dGVyLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuaW1wb3J0IFJlYWN0LCB7XG4gIHVzZUVmZmVjdCxcbiAgdXNlTWVtbyxcbiAgc3RhcnRUcmFuc2l0aW9uLFxuICB1c2VJbnNlcnRpb25FZmZlY3QsXG4gIHVzZURlZmVycmVkVmFsdWUsXG59IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHtcbiAgQXBwUm91dGVyQ29udGV4dCxcbiAgTGF5b3V0Um91dGVyQ29udGV4dCxcbiAgR2xvYmFsTGF5b3V0Um91dGVyQ29udGV4dCxcbn0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgdHlwZSB7IENhY2hlTm9kZSB9IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHsgQUNUSU9OX1JFU1RPUkUgfSBmcm9tICcuL3JvdXRlci1yZWR1Y2VyL3JvdXRlci1yZWR1Y2VyLXR5cGVzJ1xuaW1wb3J0IHR5cGUgeyBBcHBSb3V0ZXJTdGF0ZSB9IGZyb20gJy4vcm91dGVyLXJlZHVjZXIvcm91dGVyLXJlZHVjZXItdHlwZXMnXG5pbXBvcnQgeyBjcmVhdGVIcmVmRnJvbVVybCB9IGZyb20gJy4vcm91dGVyLXJlZHVjZXIvY3JlYXRlLWhyZWYtZnJvbS11cmwnXG5pbXBvcnQge1xuICBTZWFyY2hQYXJhbXNDb250ZXh0LFxuICBQYXRobmFtZUNvbnRleHQsXG4gIFBhdGhQYXJhbXNDb250ZXh0LFxufSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL2hvb2tzLWNsaWVudC1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHsgZGlzcGF0Y2hBcHBSb3V0ZXJBY3Rpb24sIHVzZUFjdGlvblF1ZXVlIH0gZnJvbSAnLi91c2UtYWN0aW9uLXF1ZXVlJ1xuaW1wb3J0IHsgaXNCb3QgfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9pcy1ib3QnXG5pbXBvcnQgeyBhZGRCYXNlUGF0aCB9IGZyb20gJy4uL2FkZC1iYXNlLXBhdGgnXG5pbXBvcnQgeyBBcHBSb3V0ZXJBbm5vdW5jZXIgfSBmcm9tICcuL2FwcC1yb3V0ZXItYW5ub3VuY2VyJ1xuaW1wb3J0IHsgUmVkaXJlY3RCb3VuZGFyeSB9IGZyb20gJy4vcmVkaXJlY3QtYm91bmRhcnknXG5pbXBvcnQgeyBmaW5kSGVhZEluQ2FjaGUgfSBmcm9tICcuL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL2ZpbmQtaGVhZC1pbi1jYWNoZSdcbmltcG9ydCB7IHVucmVzb2x2ZWRUaGVuYWJsZSB9IGZyb20gJy4vdW5yZXNvbHZlZC10aGVuYWJsZSdcbmltcG9ydCB7IHJlbW92ZUJhc2VQYXRoIH0gZnJvbSAnLi4vcmVtb3ZlLWJhc2UtcGF0aCdcbmltcG9ydCB7IGhhc0Jhc2VQYXRoIH0gZnJvbSAnLi4vaGFzLWJhc2UtcGF0aCdcbmltcG9ydCB7IGdldFNlbGVjdGVkUGFyYW1zIH0gZnJvbSAnLi9yb3V0ZXItcmVkdWNlci9jb21wdXRlLWNoYW5nZWQtcGF0aCdcbmltcG9ydCB0eXBlIHsgRmxpZ2h0Um91dGVyU3RhdGUgfSBmcm9tICcuLi8uLi9zZXJ2ZXIvYXBwLXJlbmRlci90eXBlcydcbmltcG9ydCB7IHVzZU5hdkZhaWx1cmVIYW5kbGVyIH0gZnJvbSAnLi9uYXYtZmFpbHVyZS1oYW5kbGVyJ1xuaW1wb3J0IHtcbiAgZGlzcGF0Y2hUcmF2ZXJzZUFjdGlvbixcbiAgcHVibGljQXBwUm91dGVySW5zdGFuY2UsXG4gIHR5cGUgQXBwUm91dGVyQWN0aW9uUXVldWUsXG4gIHR5cGUgR2xvYmFsRXJyb3JTdGF0ZSxcbn0gZnJvbSAnLi9hcHAtcm91dGVyLWluc3RhbmNlJ1xuaW1wb3J0IHsgZ2V0UmVkaXJlY3RUeXBlRnJvbUVycm9yLCBnZXRVUkxGcm9tUmVkaXJlY3RFcnJvciB9IGZyb20gJy4vcmVkaXJlY3QnXG5pbXBvcnQgeyBpc1JlZGlyZWN0RXJyb3IsIFJlZGlyZWN0VHlwZSB9IGZyb20gJy4vcmVkaXJlY3QtZXJyb3InXG5pbXBvcnQgeyBwaW5nVmlzaWJsZUxpbmtzIH0gZnJvbSAnLi9saW5rcydcbmltcG9ydCBSb290RXJyb3JCb3VuZGFyeSBmcm9tICcuL2Vycm9ycy9yb290LWVycm9yLWJvdW5kYXJ5J1xuaW1wb3J0IERlZmF1bHRHbG9iYWxFcnJvciBmcm9tICcuL2J1aWx0aW4vZ2xvYmFsLWVycm9yJ1xuaW1wb3J0IHsgUm9vdExheW91dEJvdW5kYXJ5IH0gZnJvbSAnLi4vLi4vbGliL2ZyYW1ld29yay9ib3VuZGFyeS1jb21wb25lbnRzJ1xuXG5jb25zdCBnbG9iYWxNdXRhYmxlOiB7XG4gIHBlbmRpbmdNcGFQYXRoPzogc3RyaW5nXG59ID0ge31cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRXh0ZXJuYWxVUkwodXJsOiBVUkwpIHtcbiAgcmV0dXJuIHVybC5vcmlnaW4gIT09IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW5cbn1cblxuLyoqXG4gKiBHaXZlbiBhIGxpbmsgaHJlZiwgY29uc3RydWN0cyB0aGUgVVJMIHRoYXQgc2hvdWxkIGJlIHByZWZldGNoZWQuIFJldHVybnMgbnVsbFxuICogaW4gY2FzZXMgd2hlcmUgcHJlZmV0Y2hpbmcgc2hvdWxkIGJlIGRpc2FibGVkLCBsaWtlIGV4dGVybmFsIFVSTHMsIG9yXG4gKiBkdXJpbmcgZGV2ZWxvcG1lbnQuXG4gKiBAcGFyYW0gaHJlZiBUaGUgaHJlZiBwYXNzZWQgdG8gPExpbms+LCByb3V0ZXIucHJlZmV0Y2goKSwgb3Igc2ltaWxhclxuICogQHJldHVybnMgQSBVUkwgb2JqZWN0IHRvIHByZWZldGNoLCBvciBudWxsIGlmIHByZWZldGNoaW5nIHNob3VsZCBiZSBkaXNhYmxlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUHJlZmV0Y2hVUkwoaHJlZjogc3RyaW5nKTogVVJMIHwgbnVsbCB7XG4gIC8vIERvbid0IHByZWZldGNoIGZvciBib3RzIGFzIHRoZXkgZG9uJ3QgbmF2aWdhdGUuXG4gIGlmIChpc0JvdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgbGV0IHVybDogVVJMXG4gIHRyeSB7XG4gICAgdXJsID0gbmV3IFVSTChhZGRCYXNlUGF0aChocmVmKSwgd2luZG93LmxvY2F0aW9uLmhyZWYpXG4gIH0gY2F0Y2ggKF8pIHtcbiAgICAvLyBUT0RPOiBEb2VzIHRoaXMgbmVlZCB0byB0aHJvdyBvciBjYW4gd2UganVzdCBjb25zb2xlLmVycm9yIGluc3RlYWQ/IERvZXNcbiAgICAvLyBhbnlvbmUgcmVseSBvbiB0aGlzIHRocm93aW5nPyAoU2VlbXMgdW5saWtlbHkuKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBDYW5ub3QgcHJlZmV0Y2ggJyR7aHJlZn0nIGJlY2F1c2UgaXQgY2Fubm90IGJlIGNvbnZlcnRlZCB0byBhIFVSTC5gXG4gICAgKVxuICB9XG5cbiAgLy8gRG9uJ3QgcHJlZmV0Y2ggZHVyaW5nIGRldmVsb3BtZW50IChpbXByb3ZlcyBjb21waWxhdGlvbiBwZXJmb3JtYW5jZSlcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8vIEV4dGVybmFsIHVybHMgY2FuJ3QgYmUgcHJlZmV0Y2hlZCBpbiB0aGUgc2FtZSB3YXkuXG4gIGlmIChpc0V4dGVybmFsVVJMKHVybCkpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgcmV0dXJuIHVybFxufVxuXG5mdW5jdGlvbiBIaXN0b3J5VXBkYXRlcih7XG4gIGFwcFJvdXRlclN0YXRlLFxufToge1xuICBhcHBSb3V0ZXJTdGF0ZTogQXBwUm91dGVyU3RhdGVcbn0pIHtcbiAgdXNlSW5zZXJ0aW9uRWZmZWN0KCgpID0+IHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0FQUF9OQVZfRkFJTF9IQU5ETElORykge1xuICAgICAgLy8gY2xlYXIgcGVuZGluZyBVUkwgYXMgbmF2aWdhdGlvbiBpcyBubyBsb25nZXJcbiAgICAgIC8vIGluIGZsaWdodFxuICAgICAgd2luZG93Lm5leHQuX19wZW5kaW5nVXJsID0gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgY29uc3QgeyB0cmVlLCBwdXNoUmVmLCBjYW5vbmljYWxVcmwgfSA9IGFwcFJvdXRlclN0YXRlXG4gICAgY29uc3QgaGlzdG9yeVN0YXRlID0ge1xuICAgICAgLi4uKHB1c2hSZWYucHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGUgPyB3aW5kb3cuaGlzdG9yeS5zdGF0ZSA6IHt9KSxcbiAgICAgIC8vIElkZW50aWZpZXIgaXMgc2hvcnRlbmVkIGludGVudGlvbmFsbHkuXG4gICAgICAvLyBfX05BIGlzIHVzZWQgdG8gaWRlbnRpZnkgaWYgdGhlIGhpc3RvcnkgZW50cnkgY2FuIGJlIGhhbmRsZWQgYnkgdGhlIGFwcC1yb3V0ZXIuXG4gICAgICAvLyBfX04gaXMgdXNlZCB0byBpZGVudGlmeSBpZiB0aGUgaGlzdG9yeSBlbnRyeSBjYW4gYmUgaGFuZGxlZCBieSB0aGUgb2xkIHJvdXRlci5cbiAgICAgIF9fTkE6IHRydWUsXG4gICAgICBfX1BSSVZBVEVfTkVYVEpTX0lOVEVSTkFMU19UUkVFOiB0cmVlLFxuICAgIH1cbiAgICBpZiAoXG4gICAgICBwdXNoUmVmLnBlbmRpbmdQdXNoICYmXG4gICAgICAvLyBTa2lwIHB1c2hpbmcgYW4gYWRkaXRpb25hbCBoaXN0b3J5IGVudHJ5IGlmIHRoZSBjYW5vbmljYWxVcmwgaXMgdGhlIHNhbWUgYXMgdGhlIGN1cnJlbnQgdXJsLlxuICAgICAgLy8gVGhpcyBtaXJyb3JzIHRoZSBicm93c2VyIGJlaGF2aW9yIGZvciBub3JtYWwgbmF2aWdhdGlvbi5cbiAgICAgIGNyZWF0ZUhyZWZGcm9tVXJsKG5ldyBVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpKSAhPT0gY2Fub25pY2FsVXJsXG4gICAgKSB7XG4gICAgICAvLyBUaGlzIGludGVudGlvbmFsbHkgbXV0YXRlcyBSZWFjdCBzdGF0ZSwgcHVzaFJlZiBpcyBvdmVyd3JpdHRlbiB0byBlbnN1cmUgYWRkaXRpb25hbCBwdXNoL3JlcGxhY2UgY2FsbHMgZG8gbm90IHRyaWdnZXIgYW4gYWRkaXRpb25hbCBoaXN0b3J5IGVudHJ5LlxuICAgICAgcHVzaFJlZi5wZW5kaW5nUHVzaCA9IGZhbHNlXG4gICAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoaGlzdG9yeVN0YXRlLCAnJywgY2Fub25pY2FsVXJsKVxuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoaGlzdG9yeVN0YXRlLCAnJywgY2Fub25pY2FsVXJsKVxuICAgIH1cbiAgfSwgW2FwcFJvdXRlclN0YXRlXSlcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIFRoZSBOZXh0LVVybCBhbmQgdGhlIGJhc2UgdHJlZSBtYXkgYWZmZWN0IHRoZSByZXN1bHQgb2YgYSBwcmVmZXRjaFxuICAgIC8vIHRhc2suIFJlLXByZWZldGNoIGFsbCB2aXNpYmxlIGxpbmtzIHdpdGggdGhlIHVwZGF0ZWQgdmFsdWVzLiBJbiBtb3N0XG4gICAgLy8gY2FzZXMsIHRoaXMgd2lsbCBub3QgcmVzdWx0IGluIGFueSBuZXcgbmV0d29yayByZXF1ZXN0cywgb25seSBpZlxuICAgIC8vIHRoZSBwcmVmZXRjaCByZXN1bHQgYWN0dWFsbHkgdmFyaWVzIG9uIG9uZSBvZiB0aGVzZSBpbnB1dHMuXG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfU0VHTUVOVF9DQUNIRSkge1xuICAgICAgcGluZ1Zpc2libGVMaW5rcyhhcHBSb3V0ZXJTdGF0ZS5uZXh0VXJsLCBhcHBSb3V0ZXJTdGF0ZS50cmVlKVxuICAgIH1cbiAgfSwgW2FwcFJvdXRlclN0YXRlLm5leHRVcmwsIGFwcFJvdXRlclN0YXRlLnRyZWVdKVxuXG4gIHJldHVybiBudWxsXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFbXB0eUNhY2hlTm9kZSgpOiBDYWNoZU5vZGUge1xuICByZXR1cm4ge1xuICAgIGxhenlEYXRhOiBudWxsLFxuICAgIHJzYzogbnVsbCxcbiAgICBwcmVmZXRjaFJzYzogbnVsbCxcbiAgICBoZWFkOiBudWxsLFxuICAgIHByZWZldGNoSGVhZDogbnVsbCxcbiAgICBwYXJhbGxlbFJvdXRlczogbmV3IE1hcCgpLFxuICAgIGxvYWRpbmc6IG51bGwsXG4gICAgbmF2aWdhdGVkQXQ6IC0xLFxuICB9XG59XG5cbmZ1bmN0aW9uIGNvcHlOZXh0SnNJbnRlcm5hbEhpc3RvcnlTdGF0ZShkYXRhOiBhbnkpIHtcbiAgaWYgKGRhdGEgPT0gbnVsbCkgZGF0YSA9IHt9XG4gIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IHdpbmRvdy5oaXN0b3J5LnN0YXRlXG4gIGNvbnN0IF9fTkEgPSBjdXJyZW50U3RhdGU/Ll9fTkFcbiAgaWYgKF9fTkEpIHtcbiAgICBkYXRhLl9fTkEgPSBfX05BXG4gIH1cbiAgY29uc3QgX19QUklWQVRFX05FWFRKU19JTlRFUk5BTFNfVFJFRSA9XG4gICAgY3VycmVudFN0YXRlPy5fX1BSSVZBVEVfTkVYVEpTX0lOVEVSTkFMU19UUkVFXG4gIGlmIChfX1BSSVZBVEVfTkVYVEpTX0lOVEVSTkFMU19UUkVFKSB7XG4gICAgZGF0YS5fX1BSSVZBVEVfTkVYVEpTX0lOVEVSTkFMU19UUkVFID0gX19QUklWQVRFX05FWFRKU19JTlRFUk5BTFNfVFJFRVxuICB9XG5cbiAgcmV0dXJuIGRhdGFcbn1cblxuZnVuY3Rpb24gSGVhZCh7XG4gIGhlYWRDYWNoZU5vZGUsXG59OiB7XG4gIGhlYWRDYWNoZU5vZGU6IENhY2hlTm9kZSB8IG51bGxcbn0pOiBSZWFjdC5SZWFjdE5vZGUge1xuICAvLyBJZiB0aGlzIHNlZ21lbnQgaGFzIGEgYHByZWZldGNoSGVhZGAsIGl0J3MgdGhlIHN0YXRpY2FsbHkgcHJlZmV0Y2hlZCBkYXRhLlxuICAvLyBXZSBzaG91bGQgdXNlIHRoYXQgb24gaW5pdGlhbCByZW5kZXIgaW5zdGVhZCBvZiBgaGVhZGAuIFRoZW4gd2UnbGwgc3dpdGNoXG4gIC8vIHRvIGBoZWFkYCB3aGVuIHRoZSBkeW5hbWljIHJlc3BvbnNlIHN0cmVhbXMgaW4uXG4gIGNvbnN0IGhlYWQgPSBoZWFkQ2FjaGVOb2RlICE9PSBudWxsID8gaGVhZENhY2hlTm9kZS5oZWFkIDogbnVsbFxuICBjb25zdCBwcmVmZXRjaEhlYWQgPVxuICAgIGhlYWRDYWNoZU5vZGUgIT09IG51bGwgPyBoZWFkQ2FjaGVOb2RlLnByZWZldGNoSGVhZCA6IG51bGxcblxuICAvLyBJZiBubyBwcmVmZXRjaCBkYXRhIGlzIGF2YWlsYWJsZSwgdGhlbiB3ZSBnbyBzdHJhaWdodCB0byByZW5kZXJpbmcgYGhlYWRgLlxuICBjb25zdCByZXNvbHZlZFByZWZldGNoUnNjID0gcHJlZmV0Y2hIZWFkICE9PSBudWxsID8gcHJlZmV0Y2hIZWFkIDogaGVhZFxuXG4gIC8vIFdlIHVzZSBgdXNlRGVmZXJyZWRWYWx1ZWAgdG8gaGFuZGxlIHN3aXRjaGluZyBiZXR3ZWVuIHRoZSBwcmVmZXRjaGVkIGFuZFxuICAvLyBmaW5hbCB2YWx1ZXMuIFRoZSBzZWNvbmQgYXJndW1lbnQgaXMgcmV0dXJuZWQgb24gaW5pdGlhbCByZW5kZXIsIHRoZW4gaXRcbiAgLy8gcmUtcmVuZGVycyB3aXRoIHRoZSBmaXJzdCBhcmd1bWVudC5cbiAgcmV0dXJuIHVzZURlZmVycmVkVmFsdWUoaGVhZCwgcmVzb2x2ZWRQcmVmZXRjaFJzYylcbn1cblxuLyoqXG4gKiBUaGUgZ2xvYmFsIHJvdXRlciB0aGF0IHdyYXBzIHRoZSBhcHBsaWNhdGlvbiBjb21wb25lbnRzLlxuICovXG5mdW5jdGlvbiBSb3V0ZXIoe1xuICBhY3Rpb25RdWV1ZSxcbiAgYXNzZXRQcmVmaXgsXG4gIGdsb2JhbEVycm9yLFxufToge1xuICBhY3Rpb25RdWV1ZTogQXBwUm91dGVyQWN0aW9uUXVldWVcbiAgYXNzZXRQcmVmaXg6IHN0cmluZ1xuICBnbG9iYWxFcnJvcjogR2xvYmFsRXJyb3JTdGF0ZVxufSkge1xuICBjb25zdCBzdGF0ZSA9IHVzZUFjdGlvblF1ZXVlKGFjdGlvblF1ZXVlKVxuICBjb25zdCB7IGNhbm9uaWNhbFVybCB9ID0gc3RhdGVcbiAgLy8gQWRkIG1lbW9pemVkIHBhdGhuYW1lL3F1ZXJ5IGZvciB1c2VTZWFyY2hQYXJhbXMgYW5kIHVzZVBhdGhuYW1lLlxuICBjb25zdCB7IHNlYXJjaFBhcmFtcywgcGF0aG5hbWUgfSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoXG4gICAgICBjYW5vbmljYWxVcmwsXG4gICAgICB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/ICdodHRwOi8vbicgOiB3aW5kb3cubG9jYXRpb24uaHJlZlxuICAgIClcblxuICAgIHJldHVybiB7XG4gICAgICAvLyBUaGlzIGlzIHR1cm5lZCBpbnRvIGEgcmVhZG9ubHkgY2xhc3MgaW4gYHVzZVNlYXJjaFBhcmFtc2BcbiAgICAgIHNlYXJjaFBhcmFtczogdXJsLnNlYXJjaFBhcmFtcyxcbiAgICAgIHBhdGhuYW1lOiBoYXNCYXNlUGF0aCh1cmwucGF0aG5hbWUpXG4gICAgICAgID8gcmVtb3ZlQmFzZVBhdGgodXJsLnBhdGhuYW1lKVxuICAgICAgICA6IHVybC5wYXRobmFtZSxcbiAgICB9XG4gIH0sIFtjYW5vbmljYWxVcmxdKVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgY29uc3QgeyBjYWNoZSwgcHJlZmV0Y2hDYWNoZSwgdHJlZSB9ID0gc3RhdGVcblxuICAgIC8vIFRoaXMgaG9vayBpcyBpbiBhIGNvbmRpdGlvbmFsIGJ1dCB0aGF0IGlzIG9rIGJlY2F1c2UgYHByb2Nlc3MuZW52Lk5PREVfRU5WYCBuZXZlciBjaGFuZ2VzXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIC8vIEFkZCBgd2luZG93Lm5kYCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLlxuICAgICAgLy8gVGhpcyBpcyBub3QgbWVhbnQgZm9yIHVzZSBpbiBhcHBsaWNhdGlvbnMgYXMgY29uY3VycmVudCByZW5kZXJpbmcgd2lsbCBhZmZlY3QgdGhlIGNhY2hlL3RyZWUvcm91dGVyLlxuICAgICAgLy8gQHRzLWlnbm9yZSB0aGlzIGlzIGZvciBkZWJ1Z2dpbmdcbiAgICAgIHdpbmRvdy5uZCA9IHtcbiAgICAgICAgcm91dGVyOiBwdWJsaWNBcHBSb3V0ZXJJbnN0YW5jZSxcbiAgICAgICAgY2FjaGUsXG4gICAgICAgIHByZWZldGNoQ2FjaGUsXG4gICAgICAgIHRyZWUsXG4gICAgICB9XG4gICAgfSwgW2NhY2hlLCBwcmVmZXRjaENhY2hlLCB0cmVlXSlcbiAgfVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gSWYgdGhlIGFwcCBpcyByZXN0b3JlZCBmcm9tIGJmY2FjaGUsIGl0J3MgcG9zc2libGUgdGhhdFxuICAgIC8vIHB1c2hSZWYubXBhTmF2aWdhdGlvbiBpcyB0cnVlLCB3aGljaCB3b3VsZCBtZWFuIHRoYXQgYW55IHJlLXJlbmRlciBvZiB0aGlzIGNvbXBvbmVudFxuICAgIC8vIHdvdWxkIHRyaWdnZXIgdGhlIG1wYSBuYXZpZ2F0aW9uIGxvZ2ljIGFnYWluIGZyb20gdGhlIGxpbmVzIGJlbG93LlxuICAgIC8vIFRoaXMgd2lsbCByZXN0b3JlIHRoZSByb3V0ZXIgdG8gdGhlIGluaXRpYWwgc3RhdGUgaW4gdGhlIGV2ZW50IHRoYXQgdGhlIGFwcCBpcyByZXN0b3JlZCBmcm9tIGJmY2FjaGUuXG4gICAgZnVuY3Rpb24gaGFuZGxlUGFnZVNob3coZXZlbnQ6IFBhZ2VUcmFuc2l0aW9uRXZlbnQpIHtcbiAgICAgIGlmIChcbiAgICAgICAgIWV2ZW50LnBlcnNpc3RlZCB8fFxuICAgICAgICAhd2luZG93Lmhpc3Rvcnkuc3RhdGU/Ll9fUFJJVkFURV9ORVhUSlNfSU5URVJOQUxTX1RSRUVcbiAgICAgICkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gQ2xlYXIgdGhlIHBlbmRpbmdNcGFQYXRoIHZhbHVlIHNvIHRoYXQgYSBzdWJzZXF1ZW50IE1QQSBuYXZpZ2F0aW9uIHRvIHRoZSBzYW1lIFVSTCBjYW4gYmUgdHJpZ2dlcmVkLlxuICAgICAgLy8gVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBpZiB0aGUgYnJvd3NlciByZXN0b3JlZCBmcm9tIGJmY2FjaGUsIHRoZSBwZW5kaW5nTXBhUGF0aCB3b3VsZCBzdGlsbCBiZSBzZXQgdG8gdGhlIHZhbHVlXG4gICAgICAvLyBvZiB0aGUgbGFzdCBNUEEgbmF2aWdhdGlvbi5cbiAgICAgIGdsb2JhbE11dGFibGUucGVuZGluZ01wYVBhdGggPSB1bmRlZmluZWRcblxuICAgICAgZGlzcGF0Y2hBcHBSb3V0ZXJBY3Rpb24oe1xuICAgICAgICB0eXBlOiBBQ1RJT05fUkVTVE9SRSxcbiAgICAgICAgdXJsOiBuZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKSxcbiAgICAgICAgdHJlZTogd2luZG93Lmhpc3Rvcnkuc3RhdGUuX19QUklWQVRFX05FWFRKU19JTlRFUk5BTFNfVFJFRSxcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BhZ2VzaG93JywgaGFuZGxlUGFnZVNob3cpXG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BhZ2VzaG93JywgaGFuZGxlUGFnZVNob3cpXG4gICAgfVxuICB9LCBbXSlcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIEVuc3VyZSB0aGF0IGFueSByZWRpcmVjdCBlcnJvcnMgdGhhdCBidWJibGUgdXAgb3V0c2lkZSBvZiB0aGUgUmVkaXJlY3RCb3VuZGFyeVxuICAgIC8vIGFyZSBjYXVnaHQgYW5kIGhhbmRsZWQgYnkgdGhlIHJvdXRlci5cbiAgICBmdW5jdGlvbiBoYW5kbGVVbmhhbmRsZWRSZWRpcmVjdChcbiAgICAgIGV2ZW50OiBFcnJvckV2ZW50IHwgUHJvbWlzZVJlamVjdGlvbkV2ZW50XG4gICAgKSB7XG4gICAgICBjb25zdCBlcnJvciA9ICdyZWFzb24nIGluIGV2ZW50ID8gZXZlbnQucmVhc29uIDogZXZlbnQuZXJyb3JcbiAgICAgIGlmIChpc1JlZGlyZWN0RXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgY29uc3QgdXJsID0gZ2V0VVJMRnJvbVJlZGlyZWN0RXJyb3IoZXJyb3IpXG4gICAgICAgIGNvbnN0IHJlZGlyZWN0VHlwZSA9IGdldFJlZGlyZWN0VHlwZUZyb21FcnJvcihlcnJvcilcbiAgICAgICAgLy8gVE9ETzogVGhpcyBzaG91bGQgYWNjZXNzIHRoZSByb3V0ZXIgbWV0aG9kcyBkaXJlY3RseSwgcmF0aGVyIHRoYW5cbiAgICAgICAgLy8gZ28gdGhyb3VnaCB0aGUgcHVibGljIGludGVyZmFjZS5cbiAgICAgICAgaWYgKHJlZGlyZWN0VHlwZSA9PT0gUmVkaXJlY3RUeXBlLnB1c2gpIHtcbiAgICAgICAgICBwdWJsaWNBcHBSb3V0ZXJJbnN0YW5jZS5wdXNoKHVybCwge30pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHVibGljQXBwUm91dGVySW5zdGFuY2UucmVwbGFjZSh1cmwsIHt9KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGhhbmRsZVVuaGFuZGxlZFJlZGlyZWN0KVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd1bmhhbmRsZWRyZWplY3Rpb24nLCBoYW5kbGVVbmhhbmRsZWRSZWRpcmVjdClcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBoYW5kbGVVbmhhbmRsZWRSZWRpcmVjdClcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd1bmhhbmRsZWRyZWplY3Rpb24nLCBoYW5kbGVVbmhhbmRsZWRSZWRpcmVjdClcbiAgICB9XG4gIH0sIFtdKVxuXG4gIC8vIFdoZW4gbXBhTmF2aWdhdGlvbiBmbGFnIGlzIHNldCBkbyBhIGhhcmQgbmF2aWdhdGlvbiB0byB0aGUgbmV3IHVybC5cbiAgLy8gSW5maW5pdGVseSBzdXNwZW5kIGJlY2F1c2Ugd2UgZG9uJ3QgYWN0dWFsbHkgd2FudCB0byByZXJlbmRlciBhbnkgY2hpbGRcbiAgLy8gY29tcG9uZW50cyB3aXRoIHRoZSBuZXcgVVJMIGFuZCBhbnkgZW50YW5nbGVkIHN0YXRlIHVwZGF0ZXMgc2hvdWxkbid0XG4gIC8vIGNvbW1pdCBlaXRoZXIgKGVnOiB1c2VUcmFuc2l0aW9uIGlzUGVuZGluZyBzaG91bGQgc3RheSB0cnVlIHVudGlsIHRoZSBwYWdlXG4gIC8vIHVubG9hZHMpLlxuICAvL1xuICAvLyBUaGlzIGlzIGEgc2lkZSBlZmZlY3QgaW4gcmVuZGVyLiBEb24ndCB0cnkgdGhpcyBhdCBob21lLCBraWRzLiBJdCdzXG4gIC8vIHByb2JhYmx5IHNhZmUgYmVjYXVzZSB3ZSBrbm93IHRoaXMgaXMgYSBzaW5nbGV0b24gY29tcG9uZW50IGFuZCBpdCdzIG5ldmVyXG4gIC8vIGluIDxPZmZzY3JlZW4+LiBBdCBsZWFzdCBJIGhvcGUgc28uIChJdCB3aWxsIHJ1biB0d2ljZSBpbiBkZXYgc3RyaWN0IG1vZGUsXG4gIC8vIGJ1dCB0aGF0J3MuLi4gZmluZT8pXG4gIGNvbnN0IHsgcHVzaFJlZiB9ID0gc3RhdGVcbiAgaWYgKHB1c2hSZWYubXBhTmF2aWdhdGlvbikge1xuICAgIC8vIGlmIHRoZXJlJ3MgYSByZS1yZW5kZXIsIHdlIGRvbid0IHdhbnQgdG8gdHJpZ2dlciBhbm90aGVyIHJlZGlyZWN0IGlmIG9uZSBpcyBhbHJlYWR5IGluIGZsaWdodCB0byB0aGUgc2FtZSBVUkxcbiAgICBpZiAoZ2xvYmFsTXV0YWJsZS5wZW5kaW5nTXBhUGF0aCAhPT0gY2Fub25pY2FsVXJsKSB7XG4gICAgICBjb25zdCBsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvblxuICAgICAgaWYgKHB1c2hSZWYucGVuZGluZ1B1c2gpIHtcbiAgICAgICAgbG9jYXRpb24uYXNzaWduKGNhbm9uaWNhbFVybClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvY2F0aW9uLnJlcGxhY2UoY2Fub25pY2FsVXJsKVxuICAgICAgfVxuXG4gICAgICBnbG9iYWxNdXRhYmxlLnBlbmRpbmdNcGFQYXRoID0gY2Fub25pY2FsVXJsXG4gICAgfVxuICAgIC8vIFRPRE8tQVBQOiBTaG91bGQgd2UgbGlzdGVuIHRvIG5hdmlnYXRlZXJyb3IgaGVyZSB0byBjYXRjaCBmYWlsZWRcbiAgICAvLyBuYXZpZ2F0aW9ucyBzb21laG93PyBBbmQgc2hvdWxkIHdlIGNhbGwgd2luZG93LnN0b3AoKSBpZiBhIFNQQSBuYXZpZ2F0aW9uXG4gICAgLy8gc2hvdWxkIGludGVycnVwdCBhbiBNUEEgb25lP1xuICAgIC8vIE5PVEU6IFRoaXMgaXMgaW50ZW50aW9uYWxseSB1c2luZyBgdGhyb3dgIGluc3RlYWQgb2YgYHVzZWAgYmVjYXVzZSB3ZSdyZVxuICAgIC8vIGluc2lkZSBhbiBleHRlcm5hbGx5IG11dGFibGUgY29uZGl0aW9uIChwdXNoUmVmLm1wYU5hdmlnYXRpb24pLCB3aGljaFxuICAgIC8vIHZpb2xhdGVzIHRoZSBydWxlcyBvZiBob29rcy5cbiAgICB0aHJvdyB1bnJlc29sdmVkVGhlbmFibGVcbiAgfVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3Qgb3JpZ2luYWxQdXNoU3RhdGUgPSB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUuYmluZCh3aW5kb3cuaGlzdG9yeSlcbiAgICBjb25zdCBvcmlnaW5hbFJlcGxhY2VTdGF0ZSA9IHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZS5iaW5kKFxuICAgICAgd2luZG93Lmhpc3RvcnlcbiAgICApXG5cbiAgICAvLyBFbnN1cmUgdGhlIGNhbm9uaWNhbCBVUkwgaW4gdGhlIE5leHQuanMgUm91dGVyIGlzIHVwZGF0ZWQgd2hlbiB0aGUgVVJMIGlzIGNoYW5nZWQgc28gdGhhdCBgdXNlUGF0aG5hbWVgIGFuZCBgdXNlU2VhcmNoUGFyYW1zYCBob2xkIHRoZSBwdXNoZWQgdmFsdWVzLlxuICAgIGNvbnN0IGFwcGx5VXJsRnJvbUhpc3RvcnlQdXNoUmVwbGFjZSA9IChcbiAgICAgIHVybDogc3RyaW5nIHwgVVJMIHwgbnVsbCB8IHVuZGVmaW5lZFxuICAgICkgPT4ge1xuICAgICAgY29uc3QgaHJlZiA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmXG4gICAgICBjb25zdCB0cmVlOiBGbGlnaHRSb3V0ZXJTdGF0ZSB8IHVuZGVmaW5lZCA9XG4gICAgICAgIHdpbmRvdy5oaXN0b3J5LnN0YXRlPy5fX1BSSVZBVEVfTkVYVEpTX0lOVEVSTkFMU19UUkVFXG5cbiAgICAgIHN0YXJ0VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICAgIGRpc3BhdGNoQXBwUm91dGVyQWN0aW9uKHtcbiAgICAgICAgICB0eXBlOiBBQ1RJT05fUkVTVE9SRSxcbiAgICAgICAgICB1cmw6IG5ldyBVUkwodXJsID8/IGhyZWYsIGhyZWYpLFxuICAgICAgICAgIHRyZWUsXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhdGNoIHB1c2hTdGF0ZSB0byBlbnN1cmUgZXh0ZXJuYWwgY2hhbmdlcyB0byB0aGUgaGlzdG9yeSBhcmUgcmVmbGVjdGVkIGluIHRoZSBOZXh0LmpzIFJvdXRlci5cbiAgICAgKiBFbnN1cmVzIE5leHQuanMgaW50ZXJuYWwgaGlzdG9yeSBzdGF0ZSBpcyBjb3BpZWQgdG8gdGhlIG5ldyBoaXN0b3J5IGVudHJ5LlxuICAgICAqIEVuc3VyZXMgdXNlUGF0aG5hbWUgYW5kIHVzZVNlYXJjaFBhcmFtcyBob2xkIHRoZSBuZXdseSBwcm92aWRlZCB1cmwuXG4gICAgICovXG4gICAgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlID0gZnVuY3Rpb24gcHVzaFN0YXRlKFxuICAgICAgZGF0YTogYW55LFxuICAgICAgX3VudXNlZDogc3RyaW5nLFxuICAgICAgdXJsPzogc3RyaW5nIHwgVVJMIHwgbnVsbFxuICAgICk6IHZvaWQge1xuICAgICAgLy8gQXZvaWQgYSBsb29wIHdoZW4gTmV4dC5qcyBpbnRlcm5hbHMgdHJpZ2dlciBwdXNoU3RhdGUvcmVwbGFjZVN0YXRlXG4gICAgICBpZiAoZGF0YT8uX19OQSB8fCBkYXRhPy5fTikge1xuICAgICAgICByZXR1cm4gb3JpZ2luYWxQdXNoU3RhdGUoZGF0YSwgX3VudXNlZCwgdXJsKVxuICAgICAgfVxuXG4gICAgICBkYXRhID0gY29weU5leHRKc0ludGVybmFsSGlzdG9yeVN0YXRlKGRhdGEpXG5cbiAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgYXBwbHlVcmxGcm9tSGlzdG9yeVB1c2hSZXBsYWNlKHVybClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9yaWdpbmFsUHVzaFN0YXRlKGRhdGEsIF91bnVzZWQsIHVybClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXRjaCByZXBsYWNlU3RhdGUgdG8gZW5zdXJlIGV4dGVybmFsIGNoYW5nZXMgdG8gdGhlIGhpc3RvcnkgYXJlIHJlZmxlY3RlZCBpbiB0aGUgTmV4dC5qcyBSb3V0ZXIuXG4gICAgICogRW5zdXJlcyBOZXh0LmpzIGludGVybmFsIGhpc3Rvcnkgc3RhdGUgaXMgY29waWVkIHRvIHRoZSBuZXcgaGlzdG9yeSBlbnRyeS5cbiAgICAgKiBFbnN1cmVzIHVzZVBhdGhuYW1lIGFuZCB1c2VTZWFyY2hQYXJhbXMgaG9sZCB0aGUgbmV3bHkgcHJvdmlkZWQgdXJsLlxuICAgICAqL1xuICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSA9IGZ1bmN0aW9uIHJlcGxhY2VTdGF0ZShcbiAgICAgIGRhdGE6IGFueSxcbiAgICAgIF91bnVzZWQ6IHN0cmluZyxcbiAgICAgIHVybD86IHN0cmluZyB8IFVSTCB8IG51bGxcbiAgICApOiB2b2lkIHtcbiAgICAgIC8vIEF2b2lkIGEgbG9vcCB3aGVuIE5leHQuanMgaW50ZXJuYWxzIHRyaWdnZXIgcHVzaFN0YXRlL3JlcGxhY2VTdGF0ZVxuICAgICAgaWYgKGRhdGE/Ll9fTkEgfHwgZGF0YT8uX04pIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsUmVwbGFjZVN0YXRlKGRhdGEsIF91bnVzZWQsIHVybClcbiAgICAgIH1cbiAgICAgIGRhdGEgPSBjb3B5TmV4dEpzSW50ZXJuYWxIaXN0b3J5U3RhdGUoZGF0YSlcblxuICAgICAgaWYgKHVybCkge1xuICAgICAgICBhcHBseVVybEZyb21IaXN0b3J5UHVzaFJlcGxhY2UodXJsKVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9yaWdpbmFsUmVwbGFjZVN0YXRlKGRhdGEsIF91bnVzZWQsIHVybClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgcG9wc3RhdGUgZXZlbnQsIHRoaXMgaXMgdXNlZCB0byBoYW5kbGUgYmFjay9mb3J3YXJkIGluIHRoZSBicm93c2VyLlxuICAgICAqIEJ5IGRlZmF1bHQgZGlzcGF0Y2hlcyBBQ1RJT05fUkVTVE9SRSwgaG93ZXZlciBpZiB0aGUgaGlzdG9yeSBlbnRyeSB3YXMgbm90IHB1c2hlZC9yZXBsYWNlZCBieSBhcHAtcm91dGVyIGl0IHdpbGwgcmVsb2FkIHRoZSBwYWdlLlxuICAgICAqIFRoYXQgY2FzZSBjYW4gaGFwcGVuIHdoZW4gdGhlIG9sZCByb3V0ZXIgaW5qZWN0ZWQgdGhlIGhpc3RvcnkgZW50cnkuXG4gICAgICovXG4gICAgY29uc3Qgb25Qb3BTdGF0ZSA9IChldmVudDogUG9wU3RhdGVFdmVudCkgPT4ge1xuICAgICAgaWYgKCFldmVudC5zdGF0ZSkge1xuICAgICAgICAvLyBUT0RPLUFQUDogdGhpcyBjYXNlIG9ubHkgaGFwcGVucyB3aGVuIHB1c2hTdGF0ZS9yZXBsYWNlU3RhdGUgd2FzIGNhbGxlZCBvdXRzaWRlIG9mIE5leHQuanMuIEl0IHNob3VsZCBwcm9iYWJseSByZWxvYWQgdGhlIHBhZ2UgaW4gdGhpcyBjYXNlLlxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gVGhpcyBjYXNlIGhhcHBlbnMgd2hlbiB0aGUgaGlzdG9yeSBlbnRyeSB3YXMgcHVzaGVkIGJ5IHRoZSBgcGFnZXNgIHJvdXRlci5cbiAgICAgIGlmICghZXZlbnQuc3RhdGUuX19OQSkge1xuICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIFRPRE8tQVBQOiBJZGVhbGx5IHRoZSBiYWNrIGJ1dHRvbiBzaG91bGQgbm90IHVzZSBzdGFydFRyYW5zaXRpb24gYXMgaXQgc2hvdWxkIGFwcGx5IHRoZSB1cGRhdGVzIHN5bmNocm9ub3VzbHlcbiAgICAgIC8vIFdpdGhvdXQgc3RhcnRUcmFuc2l0aW9uIHdvcmtzIGlmIHRoZSBjYWNoZSBpcyB0aGVyZSBmb3IgdGhpcyBwYXRoXG4gICAgICBzdGFydFRyYW5zaXRpb24oKCkgPT4ge1xuICAgICAgICBkaXNwYXRjaFRyYXZlcnNlQWN0aW9uKFxuICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmLFxuICAgICAgICAgIGV2ZW50LnN0YXRlLl9fUFJJVkFURV9ORVhUSlNfSU5URVJOQUxTX1RSRUVcbiAgICAgICAgKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyBSZWdpc3RlciBwb3BzdGF0ZSBldmVudCB0byBjYWxsIG9uUG9wc3RhdGUuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgb25Qb3BTdGF0ZSlcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlID0gb3JpZ2luYWxQdXNoU3RhdGVcbiAgICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSA9IG9yaWdpbmFsUmVwbGFjZVN0YXRlXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCBvblBvcFN0YXRlKVxuICAgIH1cbiAgfSwgW10pXG5cbiAgY29uc3QgeyBjYWNoZSwgdHJlZSwgbmV4dFVybCwgZm9jdXNBbmRTY3JvbGxSZWYgfSA9IHN0YXRlXG5cbiAgY29uc3QgbWF0Y2hpbmdIZWFkID0gdXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIGZpbmRIZWFkSW5DYWNoZShjYWNoZSwgdHJlZVsxXSlcbiAgfSwgW2NhY2hlLCB0cmVlXSlcblxuICAvLyBBZGQgbWVtb2l6ZWQgcGF0aFBhcmFtcyBmb3IgdXNlUGFyYW1zLlxuICBjb25zdCBwYXRoUGFyYW1zID0gdXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIGdldFNlbGVjdGVkUGFyYW1zKHRyZWUpXG4gIH0sIFt0cmVlXSlcblxuICBjb25zdCBsYXlvdXRSb3V0ZXJDb250ZXh0ID0gdXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhcmVudFRyZWU6IHRyZWUsXG4gICAgICBwYXJlbnRDYWNoZU5vZGU6IGNhY2hlLFxuICAgICAgcGFyZW50U2VnbWVudFBhdGg6IG51bGwsXG4gICAgICAvLyBSb290IG5vZGUgYWx3YXlzIGhhcyBgdXJsYFxuICAgICAgLy8gUHJvdmlkZWQgaW4gQXBwVHJlZUNvbnRleHQgdG8gZW5zdXJlIGl0IGNhbiBiZSBvdmVyd3JpdHRlbiBpbiBsYXlvdXQtcm91dGVyXG4gICAgICB1cmw6IGNhbm9uaWNhbFVybCxcbiAgICB9XG4gIH0sIFt0cmVlLCBjYWNoZSwgY2Fub25pY2FsVXJsXSlcblxuICBjb25zdCBnbG9iYWxMYXlvdXRSb3V0ZXJDb250ZXh0ID0gdXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRyZWUsXG4gICAgICBmb2N1c0FuZFNjcm9sbFJlZixcbiAgICAgIG5leHRVcmwsXG4gICAgfVxuICB9LCBbdHJlZSwgZm9jdXNBbmRTY3JvbGxSZWYsIG5leHRVcmxdKVxuXG4gIGxldCBoZWFkXG4gIGlmIChtYXRjaGluZ0hlYWQgIT09IG51bGwpIHtcbiAgICAvLyBUaGUgaGVhZCBpcyB3cmFwcGVkIGluIGFuIGV4dHJhIGNvbXBvbmVudCBzbyB3ZSBjYW4gdXNlXG4gICAgLy8gYHVzZURlZmVycmVkVmFsdWVgIHRvIHN3YXAgYmV0d2VlbiB0aGUgcHJlZmV0Y2hlZCBhbmQgZmluYWwgdmVyc2lvbnMgb2ZcbiAgICAvLyB0aGUgaGVhZC4gKFRoaXMgaXMgd2hhdCBMYXlvdXRSb3V0ZXIgZG9lcyBmb3Igc2VnbWVudCBkYXRhLCB0b28uKVxuICAgIC8vXG4gICAgLy8gVGhlIGBrZXlgIGlzIHVzZWQgdG8gcmVtb3VudCB0aGUgY29tcG9uZW50IHdoZW5ldmVyIHRoZSBoZWFkIG1vdmVzIHRvXG4gICAgLy8gYSBkaWZmZXJlbnQgc2VnbWVudC5cbiAgICBjb25zdCBbaGVhZENhY2hlTm9kZSwgaGVhZEtleSwgaGVhZEtleVdpdGhvdXRTZWFyY2hQYXJhbXNdID0gbWF0Y2hpbmdIZWFkXG5cbiAgICBoZWFkID0gKFxuICAgICAgPEhlYWRcbiAgICAgICAga2V5PXtcbiAgICAgICAgICAvLyBOZWNlc3NhcnkgZm9yIFBQUjogb21pdCBzZWFyY2ggcGFyYW1zIGZyb20gdGhlIGtleSB0byBtYXRjaCBwcmVyZW5kZXJlZCBrZXlzXG4gICAgICAgICAgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBoZWFkS2V5V2l0aG91dFNlYXJjaFBhcmFtcyA6IGhlYWRLZXlcbiAgICAgICAgfVxuICAgICAgICBoZWFkQ2FjaGVOb2RlPXtoZWFkQ2FjaGVOb2RlfVxuICAgICAgLz5cbiAgICApXG4gIH0gZWxzZSB7XG4gICAgaGVhZCA9IG51bGxcbiAgfVxuXG4gIGxldCBjb250ZW50ID0gKFxuICAgIDxSZWRpcmVjdEJvdW5kYXJ5PlxuICAgICAge2hlYWR9XG4gICAgICB7LyogUm9vdExheW91dEJvdW5kYXJ5IGVuYWJsZXMgZGV0ZWN0aW9uIG9mIFN1c3BlbnNlIGJvdW5kYXJpZXMgYXJvdW5kIHRoZSByb290IGxheW91dC5cbiAgICAgICAgICBXaGVuIHVzZXJzIHdyYXAgdGhlaXIgbGF5b3V0IGluIDxTdXNwZW5zZT4sIHRoaXMgY3JlYXRlcyB0aGUgY29tcG9uZW50IHN0YWNrIHBhdHRlcm5cbiAgICAgICAgICBcIlN1c3BlbnNlIC0+IFJvb3RMYXlvdXRCb3VuZGFyeVwiIHdoaWNoIGR5bmFtaWMtcmVuZGVyaW5nLnRzIHVzZXMgdG8gYWxsb3cgZHluYW1pYyByZW5kZXJpbmcuICovfVxuICAgICAgPFJvb3RMYXlvdXRCb3VuZGFyeT57Y2FjaGUucnNjfTwvUm9vdExheW91dEJvdW5kYXJ5PlxuICAgICAgPEFwcFJvdXRlckFubm91bmNlciB0cmVlPXt0cmVlfSAvPlxuICAgIDwvUmVkaXJlY3RCb3VuZGFyeT5cbiAgKVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gSW4gZGV2ZWxvcG1lbnQsIHdlIGFwcGx5IGZldyBlcnJvciBib3VuZGFyaWVzIGFuZCBob3QtcmVsb2FkZXI6XG4gICAgLy8gLSBEZXZSb290SFRUUEFjY2Vzc0ZhbGxiYWNrQm91bmRhcnk6IGF2b2lkIHVzaW5nIG5hdmlnYXRpb24gQVBJIGxpa2Ugbm90Rm91bmQoKSBpbiByb290IGxheW91dFxuICAgIC8vIC0gSG90UmVsb2FkZXI6XG4gICAgLy8gIC0gaG90LXJlbG9hZCB0aGUgYXBwIHdoZW4gdGhlIGNvZGUgY2hhbmdlc1xuICAgIC8vICAtIHJlbmRlciBkZXYgb3ZlcmxheVxuICAgIC8vICAtIGNhdGNoIHJ1bnRpbWUgZXJyb3JzIGFuZCBkaXNwbGF5IGdsb2JhbC1lcnJvciB3aGVuIG5lY2Vzc2FyeVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc3QgeyBEZXZSb290SFRUUEFjY2Vzc0ZhbGxiYWNrQm91bmRhcnkgfSA9XG4gICAgICAgIHJlcXVpcmUoJy4vZGV2LXJvb3QtaHR0cC1hY2Nlc3MtZmFsbGJhY2stYm91bmRhcnknKSBhcyB0eXBlb2YgaW1wb3J0KCcuL2Rldi1yb290LWh0dHAtYWNjZXNzLWZhbGxiYWNrLWJvdW5kYXJ5JylcbiAgICAgIGNvbnRlbnQgPSAoXG4gICAgICAgIDxEZXZSb290SFRUUEFjY2Vzc0ZhbGxiYWNrQm91bmRhcnk+XG4gICAgICAgICAge2NvbnRlbnR9XG4gICAgICAgIDwvRGV2Um9vdEhUVFBBY2Nlc3NGYWxsYmFja0JvdW5kYXJ5PlxuICAgICAgKVxuICAgIH1cbiAgICBjb25zdCBIb3RSZWxvYWRlcjogdHlwZW9mIGltcG9ydCgnLi4vZGV2L2hvdC1yZWxvYWRlci9hcHAvaG90LXJlbG9hZGVyLWFwcCcpLmRlZmF1bHQgPVxuICAgICAgKFxuICAgICAgICByZXF1aXJlKCcuLi9kZXYvaG90LXJlbG9hZGVyL2FwcC9ob3QtcmVsb2FkZXItYXBwJykgYXMgdHlwZW9mIGltcG9ydCgnLi4vZGV2L2hvdC1yZWxvYWRlci9hcHAvaG90LXJlbG9hZGVyLWFwcCcpXG4gICAgICApLmRlZmF1bHRcblxuICAgIGNvbnRlbnQgPSAoXG4gICAgICA8SG90UmVsb2FkZXIgYXNzZXRQcmVmaXg9e2Fzc2V0UHJlZml4fSBnbG9iYWxFcnJvcj17Z2xvYmFsRXJyb3J9PlxuICAgICAgICB7Y29udGVudH1cbiAgICAgIDwvSG90UmVsb2FkZXI+XG4gICAgKVxuICB9IGVsc2Uge1xuICAgIGNvbnRlbnQgPSAoXG4gICAgICA8Um9vdEVycm9yQm91bmRhcnlcbiAgICAgICAgZXJyb3JDb21wb25lbnQ9e2dsb2JhbEVycm9yWzBdfVxuICAgICAgICBlcnJvclN0eWxlcz17Z2xvYmFsRXJyb3JbMV19XG4gICAgICA+XG4gICAgICAgIHtjb250ZW50fVxuICAgICAgPC9Sb290RXJyb3JCb3VuZGFyeT5cbiAgICApXG4gIH1cblxuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICA8SGlzdG9yeVVwZGF0ZXIgYXBwUm91dGVyU3RhdGU9e3N0YXRlfSAvPlxuICAgICAgPFJ1bnRpbWVTdHlsZXMgLz5cbiAgICAgIDxQYXRoUGFyYW1zQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17cGF0aFBhcmFtc30+XG4gICAgICAgIDxQYXRobmFtZUNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3BhdGhuYW1lfT5cbiAgICAgICAgICA8U2VhcmNoUGFyYW1zQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17c2VhcmNoUGFyYW1zfT5cbiAgICAgICAgICAgIDxHbG9iYWxMYXlvdXRSb3V0ZXJDb250ZXh0LlByb3ZpZGVyXG4gICAgICAgICAgICAgIHZhbHVlPXtnbG9iYWxMYXlvdXRSb3V0ZXJDb250ZXh0fVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICB7LyogVE9ETzogV2Ugc2hvdWxkIGJlIGFibGUgdG8gcmVtb3ZlIHRoaXMgY29udGV4dC4gdXNlUm91dGVyXG4gICAgICAgICAgICAgICAgICBzaG91bGQgaW1wb3J0IGZyb20gYXBwLXJvdXRlci1pbnN0YW5jZSBpbnN0ZWFkLiBJdCdzIG9ubHlcbiAgICAgICAgICAgICAgICAgIG5lY2Vzc2FyeSBiZWNhdXNlIHVzZVJvdXRlciBpcyBzaGFyZWQgYmV0d2VlbiBQYWdlcyBhbmRcbiAgICAgICAgICAgICAgICAgIEFwcCBSb3V0ZXIuIFdlIHNob3VsZCBmb3JrIHRoYXQgbW9kdWxlLCB0aGVuIHJlbW92ZSB0aGlzXG4gICAgICAgICAgICAgICAgICBjb250ZXh0IHByb3ZpZGVyLiAqL31cbiAgICAgICAgICAgICAgPEFwcFJvdXRlckNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3B1YmxpY0FwcFJvdXRlckluc3RhbmNlfT5cbiAgICAgICAgICAgICAgICA8TGF5b3V0Um91dGVyQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17bGF5b3V0Um91dGVyQ29udGV4dH0+XG4gICAgICAgICAgICAgICAgICB7Y29udGVudH1cbiAgICAgICAgICAgICAgICA8L0xheW91dFJvdXRlckNvbnRleHQuUHJvdmlkZXI+XG4gICAgICAgICAgICAgIDwvQXBwUm91dGVyQ29udGV4dC5Qcm92aWRlcj5cbiAgICAgICAgICAgIDwvR2xvYmFsTGF5b3V0Um91dGVyQ29udGV4dC5Qcm92aWRlcj5cbiAgICAgICAgICA8L1NlYXJjaFBhcmFtc0NvbnRleHQuUHJvdmlkZXI+XG4gICAgICAgIDwvUGF0aG5hbWVDb250ZXh0LlByb3ZpZGVyPlxuICAgICAgPC9QYXRoUGFyYW1zQ29udGV4dC5Qcm92aWRlcj5cbiAgICA8Lz5cbiAgKVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBBcHBSb3V0ZXIoe1xuICBhY3Rpb25RdWV1ZSxcbiAgZ2xvYmFsRXJyb3JTdGF0ZSxcbiAgYXNzZXRQcmVmaXgsXG59OiB7XG4gIGFjdGlvblF1ZXVlOiBBcHBSb3V0ZXJBY3Rpb25RdWV1ZVxuICBnbG9iYWxFcnJvclN0YXRlOiBHbG9iYWxFcnJvclN0YXRlXG4gIGFzc2V0UHJlZml4OiBzdHJpbmdcbn0pIHtcbiAgdXNlTmF2RmFpbHVyZUhhbmRsZXIoKVxuXG4gIGNvbnN0IHJvdXRlciA9IChcbiAgICA8Um91dGVyXG4gICAgICBhY3Rpb25RdWV1ZT17YWN0aW9uUXVldWV9XG4gICAgICBhc3NldFByZWZpeD17YXNzZXRQcmVmaXh9XG4gICAgICBnbG9iYWxFcnJvcj17Z2xvYmFsRXJyb3JTdGF0ZX1cbiAgICAvPlxuICApXG5cbiAgLy8gQXQgdGhlIHZlcnkgdG9wIGxldmVsLCB1c2UgdGhlIGRlZmF1bHQgR2xvYmFsRXJyb3IgY29tcG9uZW50IGFzIHRoZSBmaW5hbCBmYWxsYmFjay5cbiAgLy8gV2hlbiB0aGUgYXBwIHJvdXRlciBpdHNlbGYgZmFpbHMsIHdoaWNoIG1lYW5zIHRoZSBmcmFtZXdvcmsgaXRzZWxmIGZhaWxzLCB3ZSBzaG93IHRoZSBkZWZhdWx0IGVycm9yLlxuICByZXR1cm4gKFxuICAgIDxSb290RXJyb3JCb3VuZGFyeSBlcnJvckNvbXBvbmVudD17RGVmYXVsdEdsb2JhbEVycm9yfT5cbiAgICAgIHtyb3V0ZXJ9XG4gICAgPC9Sb290RXJyb3JCb3VuZGFyeT5cbiAgKVxufVxuXG5jb25zdCBydW50aW1lU3R5bGVzID0gbmV3IFNldDxzdHJpbmc+KClcbmxldCBydW50aW1lU3R5bGVDaGFuZ2VkID0gbmV3IFNldDwoKSA9PiB2b2lkPigpXG5cbmdsb2JhbFRoaXMuX05fRV9TVFlMRV9MT0FEID0gZnVuY3Rpb24gKGhyZWY6IHN0cmluZykge1xuICBsZXQgbGVuID0gcnVudGltZVN0eWxlcy5zaXplXG4gIHJ1bnRpbWVTdHlsZXMuYWRkKGhyZWYpXG4gIGlmIChydW50aW1lU3R5bGVzLnNpemUgIT09IGxlbikge1xuICAgIHJ1bnRpbWVTdHlsZUNoYW5nZWQuZm9yRWFjaCgoY2IpID0+IGNiKCkpXG4gIH1cbiAgLy8gVE9ETyBmaWd1cmUgb3V0IGhvdyB0byBnZXQgYSBwcm9taXNlIGhlcmVcbiAgLy8gQnV0IG1heWJlIGl0J3Mgbm90IG5lY2Vzc2FyeSBhcyByZWFjdCB3b3VsZCBibG9jayByZW5kZXJpbmcgdW50aWwgaXQncyBsb2FkZWRcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG59XG5cbmZ1bmN0aW9uIFJ1bnRpbWVTdHlsZXMoKSB7XG4gIGNvbnN0IFssIGZvcmNlVXBkYXRlXSA9IFJlYWN0LnVzZVN0YXRlKDApXG4gIGNvbnN0IHJlbmRlcmVkU3R5bGVzU2l6ZSA9IHJ1bnRpbWVTdHlsZXMuc2l6ZVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGNoYW5nZWQgPSAoKSA9PiBmb3JjZVVwZGF0ZSgoYykgPT4gYyArIDEpXG4gICAgcnVudGltZVN0eWxlQ2hhbmdlZC5hZGQoY2hhbmdlZClcbiAgICBpZiAocmVuZGVyZWRTdHlsZXNTaXplICE9PSBydW50aW1lU3R5bGVzLnNpemUpIHtcbiAgICAgIGNoYW5nZWQoKVxuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgcnVudGltZVN0eWxlQ2hhbmdlZC5kZWxldGUoY2hhbmdlZClcbiAgICB9XG4gIH0sIFtyZW5kZXJlZFN0eWxlc1NpemUsIGZvcmNlVXBkYXRlXSlcblxuICBjb25zdCBkcGxJZCA9IHByb2Nlc3MuZW52Lk5FWFRfREVQTE9ZTUVOVF9JRFxuICAgID8gYD9kcGw9JHtwcm9jZXNzLmVudi5ORVhUX0RFUExPWU1FTlRfSUR9YFxuICAgIDogJydcbiAgcmV0dXJuIFsuLi5ydW50aW1lU3R5bGVzXS5tYXAoKGhyZWYsIGkpID0+IChcbiAgICA8bGlua1xuICAgICAga2V5PXtpfVxuICAgICAgcmVsPVwic3R5bGVzaGVldFwiXG4gICAgICBocmVmPXtgJHtocmVmfSR7ZHBsSWR9YH1cbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHByZWNlZGVuY2U9XCJuZXh0XCJcbiAgICAgIC8vIFRPRE8gZmlndXJlIG91dCBjcm9zc09yaWdpbiBhbmQgbm9uY2VcbiAgICAgIC8vIGNyb3NzT3JpZ2luPXtUT0RPfVxuICAgICAgLy8gbm9uY2U9e1RPRE99XG4gICAgLz5cbiAgKSlcbn1cbiJdLCJuYW1lcyI6WyJjcmVhdGVFbXB0eUNhY2hlTm9kZSIsImNyZWF0ZVByZWZldGNoVVJMIiwiQXBwUm91dGVyIiwiaXNFeHRlcm5hbFVSTCIsImdsb2JhbE11dGFibGUiLCJ1cmwiLCJvcmlnaW4iLCJ3aW5kb3ciLCJsb2NhdGlvbiIsImhyZWYiLCJpc0JvdCIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsIlVSTCIsImFkZEJhc2VQYXRoIiwiXyIsIkVycm9yIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiSGlzdG9yeVVwZGF0ZXIiLCJhcHBSb3V0ZXJTdGF0ZSIsInVzZUluc2VydGlvbkVmZmVjdCIsIl9fTkVYVF9BUFBfTkFWX0ZBSUxfSEFORExJTkciLCJuZXh0IiwiX19wZW5kaW5nVXJsIiwidW5kZWZpbmVkIiwidHJlZSIsInB1c2hSZWYiLCJjYW5vbmljYWxVcmwiLCJoaXN0b3J5U3RhdGUiLCJwcmVzZXJ2ZUN1c3RvbUhpc3RvcnlTdGF0ZSIsImhpc3RvcnkiLCJzdGF0ZSIsIl9fTkEiLCJfX1BSSVZBVEVfTkVYVEpTX0lOVEVSTkFMU19UUkVFIiwicGVuZGluZ1B1c2giLCJjcmVhdGVIcmVmRnJvbVVybCIsInB1c2hTdGF0ZSIsInJlcGxhY2VTdGF0ZSIsInVzZUVmZmVjdCIsIl9fTkVYVF9DTElFTlRfU0VHTUVOVF9DQUNIRSIsInBpbmdWaXNpYmxlTGlua3MiLCJuZXh0VXJsIiwibGF6eURhdGEiLCJyc2MiLCJwcmVmZXRjaFJzYyIsImhlYWQiLCJwcmVmZXRjaEhlYWQiLCJwYXJhbGxlbFJvdXRlcyIsIk1hcCIsImxvYWRpbmciLCJuYXZpZ2F0ZWRBdCIsImNvcHlOZXh0SnNJbnRlcm5hbEhpc3RvcnlTdGF0ZSIsImRhdGEiLCJjdXJyZW50U3RhdGUiLCJIZWFkIiwiaGVhZENhY2hlTm9kZSIsInJlc29sdmVkUHJlZmV0Y2hSc2MiLCJ1c2VEZWZlcnJlZFZhbHVlIiwiUm91dGVyIiwiYWN0aW9uUXVldWUiLCJhc3NldFByZWZpeCIsImdsb2JhbEVycm9yIiwidXNlQWN0aW9uUXVldWUiLCJzZWFyY2hQYXJhbXMiLCJwYXRobmFtZSIsInVzZU1lbW8iLCJoYXNCYXNlUGF0aCIsInJlbW92ZUJhc2VQYXRoIiwiY2FjaGUiLCJwcmVmZXRjaENhY2hlIiwibmQiLCJyb3V0ZXIiLCJwdWJsaWNBcHBSb3V0ZXJJbnN0YW5jZSIsImhhbmRsZVBhZ2VTaG93IiwiZXZlbnQiLCJwZXJzaXN0ZWQiLCJwZW5kaW5nTXBhUGF0aCIsImRpc3BhdGNoQXBwUm91dGVyQWN0aW9uIiwidHlwZSIsIkFDVElPTl9SRVNUT1JFIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJoYW5kbGVVbmhhbmRsZWRSZWRpcmVjdCIsImVycm9yIiwicmVhc29uIiwiaXNSZWRpcmVjdEVycm9yIiwicHJldmVudERlZmF1bHQiLCJnZXRVUkxGcm9tUmVkaXJlY3RFcnJvciIsInJlZGlyZWN0VHlwZSIsImdldFJlZGlyZWN0VHlwZUZyb21FcnJvciIsIlJlZGlyZWN0VHlwZSIsInB1c2giLCJyZXBsYWNlIiwibXBhTmF2aWdhdGlvbiIsImFzc2lnbiIsInVucmVzb2x2ZWRUaGVuYWJsZSIsIm9yaWdpbmFsUHVzaFN0YXRlIiwiYmluZCIsIm9yaWdpbmFsUmVwbGFjZVN0YXRlIiwiYXBwbHlVcmxGcm9tSGlzdG9yeVB1c2hSZXBsYWNlIiwic3RhcnRUcmFuc2l0aW9uIiwiX3VudXNlZCIsIl9OIiwib25Qb3BTdGF0ZSIsInJlbG9hZCIsImRpc3BhdGNoVHJhdmVyc2VBY3Rpb24iLCJmb2N1c0FuZFNjcm9sbFJlZiIsIm1hdGNoaW5nSGVhZCIsImZpbmRIZWFkSW5DYWNoZSIsInBhdGhQYXJhbXMiLCJnZXRTZWxlY3RlZFBhcmFtcyIsImxheW91dFJvdXRlckNvbnRleHQiLCJwYXJlbnRUcmVlIiwicGFyZW50Q2FjaGVOb2RlIiwicGFyZW50U2VnbWVudFBhdGgiLCJnbG9iYWxMYXlvdXRSb3V0ZXJDb250ZXh0IiwiaGVhZEtleSIsImhlYWRLZXlXaXRob3V0U2VhcmNoUGFyYW1zIiwiY29udGVudCIsIlJlZGlyZWN0Qm91bmRhcnkiLCJSb290TGF5b3V0Qm91bmRhcnkiLCJBcHBSb3V0ZXJBbm5vdW5jZXIiLCJEZXZSb290SFRUUEFjY2Vzc0ZhbGxiYWNrQm91bmRhcnkiLCJyZXF1aXJlIiwiSG90UmVsb2FkZXIiLCJkZWZhdWx0IiwiUm9vdEVycm9yQm91bmRhcnkiLCJlcnJvckNvbXBvbmVudCIsImVycm9yU3R5bGVzIiwiUnVudGltZVN0eWxlcyIsIlBhdGhQYXJhbXNDb250ZXh0IiwiUHJvdmlkZXIiLCJ2YWx1ZSIsIlBhdGhuYW1lQ29udGV4dCIsIlNlYXJjaFBhcmFtc0NvbnRleHQiLCJHbG9iYWxMYXlvdXRSb3V0ZXJDb250ZXh0IiwiQXBwUm91dGVyQ29udGV4dCIsIkxheW91dFJvdXRlckNvbnRleHQiLCJnbG9iYWxFcnJvclN0YXRlIiwidXNlTmF2RmFpbHVyZUhhbmRsZXIiLCJEZWZhdWx0R2xvYmFsRXJyb3IiLCJydW50aW1lU3R5bGVzIiwiU2V0IiwicnVudGltZVN0eWxlQ2hhbmdlZCIsImdsb2JhbFRoaXMiLCJfTl9FX1NUWUxFX0xPQUQiLCJsZW4iLCJzaXplIiwiYWRkIiwiZm9yRWFjaCIsImNiIiwiUHJvbWlzZSIsInJlc29sdmUiLCJmb3JjZVVwZGF0ZSIsIlJlYWN0IiwidXNlU3RhdGUiLCJyZW5kZXJlZFN0eWxlc1NpemUiLCJjaGFuZ2VkIiwiYyIsImRlbGV0ZSIsImRwbElkIiwiTkVYVF9ERVBMT1lNRU5UX0lEIiwibWFwIiwiaSIsImxpbmsiLCJyZWwiLCJwcmVjZWRlbmNlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/app-router.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/http-access-fallback/error-boundary.js":
/*!*********************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/http-access-fallback/error-boundary.js ***!
  \*********************************************************************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"HTTPAccessFallbackBoundary\", ({\n    enumerable: true,\n    get: function() {\n        return HTTPAccessFallbackBoundary;\n    }\n}));\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.15/node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/compiled/react/index.js\"));\nconst _navigationuntracked = __webpack_require__(/*! ../navigation-untracked */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/navigation-untracked.js\");\nconst _httpaccessfallback = __webpack_require__(/*! ./http-access-fallback */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/http-access-fallback/http-access-fallback.js\");\nconst _warnonce = __webpack_require__(/*! ../../../shared/lib/utils/warn-once */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/shared/lib/utils/warn-once.js\");\nconst _approutercontextsharedruntime = __webpack_require__(/*! ../../../shared/lib/app-router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\");\nclass HTTPAccessFallbackErrorBoundary extends _react.default.Component {\n    componentDidCatch() {\n        if ( true && this.props.missingSlots && this.props.missingSlots.size > 0 && // A missing children slot is the typical not-found case, so no need to warn\n        !this.props.missingSlots.has('children')) {\n            let warningMessage = 'No default component was found for a parallel route rendered on this page. Falling back to nearest NotFound boundary.\\n' + 'Learn more: https://nextjs.org/docs/app/building-your-application/routing/parallel-routes#defaultjs\\n\\n';\n            const formattedSlots = Array.from(this.props.missingSlots).sort((a, b)=>a.localeCompare(b)).map((slot)=>\"@\" + slot).join(', ');\n            warningMessage += 'Missing slots: ' + formattedSlots;\n            (0, _warnonce.warnOnce)(warningMessage);\n        }\n    }\n    static getDerivedStateFromError(error) {\n        if ((0, _httpaccessfallback.isHTTPAccessFallbackError)(error)) {\n            const httpStatus = (0, _httpaccessfallback.getAccessFallbackHTTPStatus)(error);\n            return {\n                triggeredStatus: httpStatus\n            };\n        }\n        // Re-throw if error is not for 404\n        throw error;\n    }\n    static getDerivedStateFromProps(props, state) {\n        /**\n     * Handles reset of the error boundary when a navigation happens.\n     * Ensures the error boundary does not stay enabled when navigating to a new page.\n     * Approach of setState in render is safe as it checks the previous pathname and then overrides\n     * it as outlined in https://react.dev/reference/react/useState#storing-information-from-previous-renders\n     */ if (props.pathname !== state.previousPathname && state.triggeredStatus) {\n            return {\n                triggeredStatus: undefined,\n                previousPathname: props.pathname\n            };\n        }\n        return {\n            triggeredStatus: state.triggeredStatus,\n            previousPathname: props.pathname\n        };\n    }\n    render() {\n        const { notFound, forbidden, unauthorized, children } = this.props;\n        const { triggeredStatus } = this.state;\n        const errorComponents = {\n            [_httpaccessfallback.HTTPAccessErrorStatus.NOT_FOUND]: notFound,\n            [_httpaccessfallback.HTTPAccessErrorStatus.FORBIDDEN]: forbidden,\n            [_httpaccessfallback.HTTPAccessErrorStatus.UNAUTHORIZED]: unauthorized\n        };\n        if (triggeredStatus) {\n            const isNotFound = triggeredStatus === _httpaccessfallback.HTTPAccessErrorStatus.NOT_FOUND && notFound;\n            const isForbidden = triggeredStatus === _httpaccessfallback.HTTPAccessErrorStatus.FORBIDDEN && forbidden;\n            const isUnauthorized = triggeredStatus === _httpaccessfallback.HTTPAccessErrorStatus.UNAUTHORIZED && unauthorized;\n            // If there's no matched boundary in this layer, keep throwing the error by rendering the children\n            if (!(isNotFound || isForbidden || isUnauthorized)) {\n                return children;\n            }\n            return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n                children: [\n                    /*#__PURE__*/ (0, _jsxruntime.jsx)(\"meta\", {\n                        name: \"robots\",\n                        content: \"noindex\"\n                    }),\n                     true && /*#__PURE__*/ (0, _jsxruntime.jsx)(\"meta\", {\n                        name: \"boundary-next-error\",\n                        content: (0, _httpaccessfallback.getAccessFallbackErrorTypeByStatus)(triggeredStatus)\n                    }),\n                    errorComponents[triggeredStatus]\n                ]\n            });\n        }\n        return children;\n    }\n    constructor(props){\n        super(props);\n        this.state = {\n            triggeredStatus: undefined,\n            previousPathname: props.pathname\n        };\n    }\n}\nfunction HTTPAccessFallbackBoundary(param) {\n    let { notFound, forbidden, unauthorized, children } = param;\n    // When we're rendering the missing params shell, this will return null. This\n    // is because we won't be rendering any not found boundaries or error\n    // boundaries for the missing params shell. When this runs on the client\n    // (where these error can occur), we will get the correct pathname.\n    const pathname = (0, _navigationuntracked.useUntrackedPathname)();\n    const missingSlots = (0, _react.useContext)(_approutercontextsharedruntime.MissingSlotContext);\n    const hasErrorFallback = !!(notFound || forbidden || unauthorized);\n    if (hasErrorFallback) {\n        return /*#__PURE__*/ (0, _jsxruntime.jsx)(HTTPAccessFallbackErrorBoundary, {\n            pathname: pathname,\n            notFound: notFound,\n            forbidden: forbidden,\n            unauthorized: unauthorized,\n            missingSlots: missingSlots,\n            children: children\n        });\n    }\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_jsxruntime.Fragment, {\n        children: children\n    });\n}\n_c = HTTPAccessFallbackBoundary;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=error-boundary.js.map\nvar _c;\n$RefreshReg$(_c, \"HTTPAccessFallbackBoundary\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE1LjUuMTJfcmVhY3QtZG9tQDE5LjIuNF9yZWFjdEAxOS4yLjRfX3JlYWN0QDE5LjIuNC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2h0dHAtYWNjZXNzLWZhbGxiYWNrL2Vycm9yLWJvdW5kYXJ5LmpzIiwibWFwcGluZ3MiOiI7Ozs7OERBdUpnQkE7OztlQUFBQTs7Ozs7NkVBMUlrQjtpREFDRztnREFNOUI7c0NBQ2tCOzJEQUNVO0FBcUJuQyxNQUFNQyx3Q0FBd0NDLE9BQUFBLE9BQUssQ0FBQ0MsU0FBUztJQVkzREMsb0JBQTBCO1FBQ3hCLElBQ0VDLEtBQW9CLElBQ3BCLElBQUksQ0FBQ0csS0FBSyxDQUFDQyxZQUFZLElBQ3ZCLElBQUksQ0FBQ0QsS0FBSyxDQUFDQyxZQUFZLENBQUNDLElBQUksR0FBRyxLQUMvQiw0RUFBNEU7UUFDNUUsQ0FBQyxJQUFJLENBQUNGLEtBQUssQ0FBQ0MsWUFBWSxDQUFDRSxHQUFHLENBQUMsYUFDN0I7WUFDQSxJQUFJQyxpQkFDRiw0SEFDQTtZQUVGLE1BQU1DLGlCQUFpQkMsTUFBTUMsSUFBSSxDQUFDLElBQUksQ0FBQ1AsS0FBSyxDQUFDQyxZQUFZLEVBQ3RETyxJQUFJLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTUQsRUFBRUUsYUFBYSxDQUFDRCxJQUMvQkUsR0FBRyxDQUFDLENBQUNDLE9BQVUsTUFBR0EsTUFDbEJDLElBQUksQ0FBQztZQUVSVixrQkFBa0Isb0JBQW9CQztZQUV0Q1UsQ0FBQUEsR0FBQUEsVUFBQUEsUUFBQUEsRUFBU1g7UUFDWDtJQUNGO0lBRUEsT0FBT1kseUJBQXlCQyxLQUFVLEVBQUU7UUFDMUMsSUFBSUMsQ0FBQUEsR0FBQUEsb0JBQUFBLHlCQUF5QixFQUFDRCxRQUFRO1lBQ3BDLE1BQU1FLGFBQWFDLENBQUFBLEdBQUFBLG9CQUFBQSwyQkFBQUEsRUFBNEJIO1lBQy9DLE9BQU87Z0JBQ0xJLGlCQUFpQkY7WUFDbkI7UUFDRjtRQUNBLG1DQUFtQztRQUNuQyxNQUFNRjtJQUNSO0lBRUEsT0FBT0sseUJBQ0x0QixLQUEyQyxFQUMzQ3VCLEtBQThCLEVBQ0U7UUFDaEM7Ozs7O0tBS0MsR0FDRCxJQUFJdkIsTUFBTXdCLFFBQVEsS0FBS0QsTUFBTUUsZ0JBQWdCLElBQUlGLE1BQU1GLGVBQWUsRUFBRTtZQUN0RSxPQUFPO2dCQUNMQSxpQkFBaUJLO2dCQUNqQkQsa0JBQWtCekIsTUFBTXdCLFFBQVE7WUFDbEM7UUFDRjtRQUNBLE9BQU87WUFDTEgsaUJBQWlCRSxNQUFNRixlQUFlO1lBQ3RDSSxrQkFBa0J6QixNQUFNd0IsUUFBUTtRQUNsQztJQUNGO0lBRUFHLFNBQVM7UUFDUCxNQUFNLEVBQUVDLFFBQVEsRUFBRUMsU0FBUyxFQUFFQyxZQUFZLEVBQUVDLFFBQVEsRUFBRSxHQUFHLElBQUksQ0FBQy9CLEtBQUs7UUFDbEUsTUFBTSxFQUFFcUIsZUFBZSxFQUFFLEdBQUcsSUFBSSxDQUFDRSxLQUFLO1FBQ3RDLE1BQU1TLGtCQUFrQjtZQUN0QixDQUFDQyxvQkFBQUEscUJBQXFCLENBQUNDLFNBQVMsQ0FBQyxFQUFFTjtZQUNuQyxDQUFDSyxvQkFBQUEscUJBQXFCLENBQUNFLFNBQVMsQ0FBQyxFQUFFTjtZQUNuQyxDQUFDSSxvQkFBQUEscUJBQXFCLENBQUNHLFlBQVksQ0FBQyxFQUFFTjtRQUN4QztRQUVBLElBQUlULGlCQUFpQjtZQUNuQixNQUFNZ0IsYUFDSmhCLG9CQUFvQlksb0JBQUFBLHFCQUFxQixDQUFDQyxTQUFTLElBQUlOO1lBQ3pELE1BQU1VLGNBQ0pqQixvQkFBb0JZLG9CQUFBQSxxQkFBcUIsQ0FBQ0UsU0FBUyxJQUFJTjtZQUN6RCxNQUFNVSxpQkFDSmxCLG9CQUFvQlksb0JBQUFBLHFCQUFxQixDQUFDRyxZQUFZLElBQUlOO1lBRTVELGtHQUFrRztZQUNsRyxJQUFJLENBQUVPLENBQUFBLGNBQWNDLGVBQWVDLGNBQUFBLENBQWEsRUFBSTtnQkFDbEQsT0FBT1I7WUFDVDtZQUVBLHFCQUNFOztrQ0FDRSxxQkFBQ1MsUUFBQUE7d0JBQUtDLE1BQUs7d0JBQVNDLFNBQVE7O3lCQUNXLElBQWIsY0FDeEIscUJBQUNGLFFBQUFBO3dCQUNDQyxNQUFLO3dCQUNMQyxTQUFTQyxDQUFBQSxHQUFBQSxvQkFBQUEsa0NBQUFBLEVBQW1DdEI7O29CQUcvQ1csZUFBZSxDQUFDWCxnQkFBZ0I7OztRQUd2QztRQUVBLE9BQU9VO0lBQ1Q7SUFyR0FhLFlBQVk1QyxLQUEyQyxDQUFFO1FBQ3ZELEtBQUssQ0FBQ0E7UUFDTixJQUFJLENBQUN1QixLQUFLLEdBQUc7WUFDWEYsaUJBQWlCSztZQUNqQkQsa0JBQWtCekIsTUFBTXdCLFFBQVE7UUFDbEM7SUFDRjtBQWdHRjtBQUVPLG9DQUFvQyxLQUtUO0lBTFMsTUFDekNJLFFBQVEsRUFDUkMsU0FBUyxFQUNUQyxZQUFZLEVBQ1pDLFFBQVEsRUFDd0IsR0FMUztJQU16Qyw2RUFBNkU7SUFDN0UscUVBQXFFO0lBQ3JFLHdFQUF3RTtJQUN4RSxtRUFBbUU7SUFDbkUsTUFBTVAsV0FBV3FCLENBQUFBLEdBQUFBLHFCQUFBQSxvQkFBQUE7SUFDakIsTUFBTTVDLGVBQWU2QyxDQUFBQSxHQUFBQSxPQUFBQSxVQUFBQSxFQUFXQywrQkFBQUEsa0JBQWtCO0lBQ2xELE1BQU1DLG1CQUFtQixDQUFDLENBQUVwQixDQUFBQSxZQUFZQyxhQUFhQyxZQUFBQSxDQUFXO0lBRWhFLElBQUlrQixrQkFBa0I7UUFDcEIscUJBQ0UscUJBQUN2RCxpQ0FBQUE7WUFDQytCLFVBQVVBO1lBQ1ZJLFVBQVVBO1lBQ1ZDLFdBQVdBO1lBQ1hDLGNBQWNBO1lBQ2Q3QixjQUFjQTtzQkFFYjhCOztJQUdQO0lBRUEscUJBQU87a0JBQUdBOztBQUNaO0tBN0JnQnZDIiwic291cmNlcyI6WyIvVXNlcnMvc3JjL2NsaWVudC9jb21wb25lbnRzL2h0dHAtYWNjZXNzLWZhbGxiYWNrL2Vycm9yLWJvdW5kYXJ5LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuLyoqXG4gKiBIVFRQQWNjZXNzRmFsbGJhY2tCb3VuZGFyeSBpcyBhIGJvdW5kYXJ5IHRoYXQgY2F0Y2hlcyBlcnJvcnMgYW5kIHJlbmRlcnMgYVxuICogZmFsbGJhY2sgY29tcG9uZW50IGZvciBIVFRQIGVycm9ycy5cbiAqXG4gKiBJdCByZWNlaXZlcyB0aGUgc3RhdHVzIGNvZGUsIGFuZCBkZXRlcm1pbmUgaWYgaXQgc2hvdWxkIHJlbmRlciBmYWxsYmFja3MgZm9yIGZldyBIVFRQIDR4eCBlcnJvcnMuXG4gKlxuICogZS5nLiA0MDRcbiAqIDQwNCByZXByZXNlbnRzIG5vdCBmb3VuZCwgYW5kIHRoZSBmYWxsYmFjayBjb21wb25lbnQgcGFpciBjb250YWlucyB0aGUgY29tcG9uZW50IGFuZCBpdHMgc3R5bGVzLlxuICpcbiAqL1xuXG5pbXBvcnQgUmVhY3QsIHsgdXNlQ29udGV4dCB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgdXNlVW50cmFja2VkUGF0aG5hbWUgfSBmcm9tICcuLi9uYXZpZ2F0aW9uLXVudHJhY2tlZCdcbmltcG9ydCB7XG4gIEhUVFBBY2Nlc3NFcnJvclN0YXR1cyxcbiAgZ2V0QWNjZXNzRmFsbGJhY2tIVFRQU3RhdHVzLFxuICBnZXRBY2Nlc3NGYWxsYmFja0Vycm9yVHlwZUJ5U3RhdHVzLFxuICBpc0hUVFBBY2Nlc3NGYWxsYmFja0Vycm9yLFxufSBmcm9tICcuL2h0dHAtYWNjZXNzLWZhbGxiYWNrJ1xuaW1wb3J0IHsgd2Fybk9uY2UgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvbGliL3V0aWxzL3dhcm4tb25jZSdcbmltcG9ydCB7IE1pc3NpbmdTbG90Q29udGV4dCB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuXG5pbnRlcmZhY2UgSFRUUEFjY2Vzc0ZhbGxiYWNrQm91bmRhcnlQcm9wcyB7XG4gIG5vdEZvdW5kPzogUmVhY3QuUmVhY3ROb2RlXG4gIGZvcmJpZGRlbj86IFJlYWN0LlJlYWN0Tm9kZVxuICB1bmF1dGhvcml6ZWQ/OiBSZWFjdC5SZWFjdE5vZGVcbiAgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZVxuICBtaXNzaW5nU2xvdHM/OiBTZXQ8c3RyaW5nPlxufVxuXG5pbnRlcmZhY2UgSFRUUEFjY2Vzc0ZhbGxiYWNrRXJyb3JCb3VuZGFyeVByb3BzXG4gIGV4dGVuZHMgSFRUUEFjY2Vzc0ZhbGxiYWNrQm91bmRhcnlQcm9wcyB7XG4gIHBhdGhuYW1lOiBzdHJpbmcgfCBudWxsXG4gIG1pc3NpbmdTbG90cz86IFNldDxzdHJpbmc+XG59XG5cbmludGVyZmFjZSBIVFRQQWNjZXNzQm91bmRhcnlTdGF0ZSB7XG4gIHRyaWdnZXJlZFN0YXR1czogbnVtYmVyIHwgdW5kZWZpbmVkXG4gIHByZXZpb3VzUGF0aG5hbWU6IHN0cmluZyB8IG51bGxcbn1cblxuY2xhc3MgSFRUUEFjY2Vzc0ZhbGxiYWNrRXJyb3JCb3VuZGFyeSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxcbiAgSFRUUEFjY2Vzc0ZhbGxiYWNrRXJyb3JCb3VuZGFyeVByb3BzLFxuICBIVFRQQWNjZXNzQm91bmRhcnlTdGF0ZVxuPiB7XG4gIGNvbnN0cnVjdG9yKHByb3BzOiBIVFRQQWNjZXNzRmFsbGJhY2tFcnJvckJvdW5kYXJ5UHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcylcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgdHJpZ2dlcmVkU3RhdHVzOiB1bmRlZmluZWQsXG4gICAgICBwcmV2aW91c1BhdGhuYW1lOiBwcm9wcy5wYXRobmFtZSxcbiAgICB9XG4gIH1cblxuICBjb21wb25lbnREaWRDYXRjaCgpOiB2b2lkIHtcbiAgICBpZiAoXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJlxuICAgICAgdGhpcy5wcm9wcy5taXNzaW5nU2xvdHMgJiZcbiAgICAgIHRoaXMucHJvcHMubWlzc2luZ1Nsb3RzLnNpemUgPiAwICYmXG4gICAgICAvLyBBIG1pc3NpbmcgY2hpbGRyZW4gc2xvdCBpcyB0aGUgdHlwaWNhbCBub3QtZm91bmQgY2FzZSwgc28gbm8gbmVlZCB0byB3YXJuXG4gICAgICAhdGhpcy5wcm9wcy5taXNzaW5nU2xvdHMuaGFzKCdjaGlsZHJlbicpXG4gICAgKSB7XG4gICAgICBsZXQgd2FybmluZ01lc3NhZ2UgPVxuICAgICAgICAnTm8gZGVmYXVsdCBjb21wb25lbnQgd2FzIGZvdW5kIGZvciBhIHBhcmFsbGVsIHJvdXRlIHJlbmRlcmVkIG9uIHRoaXMgcGFnZS4gRmFsbGluZyBiYWNrIHRvIG5lYXJlc3QgTm90Rm91bmQgYm91bmRhcnkuXFxuJyArXG4gICAgICAgICdMZWFybiBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYnVpbGRpbmcteW91ci1hcHBsaWNhdGlvbi9yb3V0aW5nL3BhcmFsbGVsLXJvdXRlcyNkZWZhdWx0anNcXG5cXG4nXG5cbiAgICAgIGNvbnN0IGZvcm1hdHRlZFNsb3RzID0gQXJyYXkuZnJvbSh0aGlzLnByb3BzLm1pc3NpbmdTbG90cylcbiAgICAgICAgLnNvcnQoKGEsIGIpID0+IGEubG9jYWxlQ29tcGFyZShiKSlcbiAgICAgICAgLm1hcCgoc2xvdCkgPT4gYEAke3Nsb3R9YClcbiAgICAgICAgLmpvaW4oJywgJylcblxuICAgICAgd2FybmluZ01lc3NhZ2UgKz0gJ01pc3Npbmcgc2xvdHM6ICcgKyBmb3JtYXR0ZWRTbG90c1xuXG4gICAgICB3YXJuT25jZSh3YXJuaW5nTWVzc2FnZSlcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yOiBhbnkpIHtcbiAgICBpZiAoaXNIVFRQQWNjZXNzRmFsbGJhY2tFcnJvcihlcnJvcikpIHtcbiAgICAgIGNvbnN0IGh0dHBTdGF0dXMgPSBnZXRBY2Nlc3NGYWxsYmFja0hUVFBTdGF0dXMoZXJyb3IpXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0cmlnZ2VyZWRTdGF0dXM6IGh0dHBTdGF0dXMsXG4gICAgICB9XG4gICAgfVxuICAgIC8vIFJlLXRocm93IGlmIGVycm9yIGlzIG5vdCBmb3IgNDA0XG4gICAgdGhyb3cgZXJyb3JcbiAgfVxuXG4gIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoXG4gICAgcHJvcHM6IEhUVFBBY2Nlc3NGYWxsYmFja0Vycm9yQm91bmRhcnlQcm9wcyxcbiAgICBzdGF0ZTogSFRUUEFjY2Vzc0JvdW5kYXJ5U3RhdGVcbiAgKTogSFRUUEFjY2Vzc0JvdW5kYXJ5U3RhdGUgfCBudWxsIHtcbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHJlc2V0IG9mIHRoZSBlcnJvciBib3VuZGFyeSB3aGVuIGEgbmF2aWdhdGlvbiBoYXBwZW5zLlxuICAgICAqIEVuc3VyZXMgdGhlIGVycm9yIGJvdW5kYXJ5IGRvZXMgbm90IHN0YXkgZW5hYmxlZCB3aGVuIG5hdmlnYXRpbmcgdG8gYSBuZXcgcGFnZS5cbiAgICAgKiBBcHByb2FjaCBvZiBzZXRTdGF0ZSBpbiByZW5kZXIgaXMgc2FmZSBhcyBpdCBjaGVja3MgdGhlIHByZXZpb3VzIHBhdGhuYW1lIGFuZCB0aGVuIG92ZXJyaWRlc1xuICAgICAqIGl0IGFzIG91dGxpbmVkIGluIGh0dHBzOi8vcmVhY3QuZGV2L3JlZmVyZW5jZS9yZWFjdC91c2VTdGF0ZSNzdG9yaW5nLWluZm9ybWF0aW9uLWZyb20tcHJldmlvdXMtcmVuZGVyc1xuICAgICAqL1xuICAgIGlmIChwcm9wcy5wYXRobmFtZSAhPT0gc3RhdGUucHJldmlvdXNQYXRobmFtZSAmJiBzdGF0ZS50cmlnZ2VyZWRTdGF0dXMpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRyaWdnZXJlZFN0YXR1czogdW5kZWZpbmVkLFxuICAgICAgICBwcmV2aW91c1BhdGhuYW1lOiBwcm9wcy5wYXRobmFtZSxcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHRyaWdnZXJlZFN0YXR1czogc3RhdGUudHJpZ2dlcmVkU3RhdHVzLFxuICAgICAgcHJldmlvdXNQYXRobmFtZTogcHJvcHMucGF0aG5hbWUsXG4gICAgfVxuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgbm90Rm91bmQsIGZvcmJpZGRlbiwgdW5hdXRob3JpemVkLCBjaGlsZHJlbiB9ID0gdGhpcy5wcm9wc1xuICAgIGNvbnN0IHsgdHJpZ2dlcmVkU3RhdHVzIH0gPSB0aGlzLnN0YXRlXG4gICAgY29uc3QgZXJyb3JDb21wb25lbnRzID0ge1xuICAgICAgW0hUVFBBY2Nlc3NFcnJvclN0YXR1cy5OT1RfRk9VTkRdOiBub3RGb3VuZCxcbiAgICAgIFtIVFRQQWNjZXNzRXJyb3JTdGF0dXMuRk9SQklEREVOXTogZm9yYmlkZGVuLFxuICAgICAgW0hUVFBBY2Nlc3NFcnJvclN0YXR1cy5VTkFVVEhPUklaRURdOiB1bmF1dGhvcml6ZWQsXG4gICAgfVxuXG4gICAgaWYgKHRyaWdnZXJlZFN0YXR1cykge1xuICAgICAgY29uc3QgaXNOb3RGb3VuZCA9XG4gICAgICAgIHRyaWdnZXJlZFN0YXR1cyA9PT0gSFRUUEFjY2Vzc0Vycm9yU3RhdHVzLk5PVF9GT1VORCAmJiBub3RGb3VuZFxuICAgICAgY29uc3QgaXNGb3JiaWRkZW4gPVxuICAgICAgICB0cmlnZ2VyZWRTdGF0dXMgPT09IEhUVFBBY2Nlc3NFcnJvclN0YXR1cy5GT1JCSURERU4gJiYgZm9yYmlkZGVuXG4gICAgICBjb25zdCBpc1VuYXV0aG9yaXplZCA9XG4gICAgICAgIHRyaWdnZXJlZFN0YXR1cyA9PT0gSFRUUEFjY2Vzc0Vycm9yU3RhdHVzLlVOQVVUSE9SSVpFRCAmJiB1bmF1dGhvcml6ZWRcblxuICAgICAgLy8gSWYgdGhlcmUncyBubyBtYXRjaGVkIGJvdW5kYXJ5IGluIHRoaXMgbGF5ZXIsIGtlZXAgdGhyb3dpbmcgdGhlIGVycm9yIGJ5IHJlbmRlcmluZyB0aGUgY2hpbGRyZW5cbiAgICAgIGlmICghKGlzTm90Rm91bmQgfHwgaXNGb3JiaWRkZW4gfHwgaXNVbmF1dGhvcml6ZWQpKSB7XG4gICAgICAgIHJldHVybiBjaGlsZHJlblxuICAgICAgfVxuXG4gICAgICByZXR1cm4gKFxuICAgICAgICA8PlxuICAgICAgICAgIDxtZXRhIG5hbWU9XCJyb2JvdHNcIiBjb250ZW50PVwibm9pbmRleFwiIC8+XG4gICAgICAgICAge3Byb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmIChcbiAgICAgICAgICAgIDxtZXRhXG4gICAgICAgICAgICAgIG5hbWU9XCJib3VuZGFyeS1uZXh0LWVycm9yXCJcbiAgICAgICAgICAgICAgY29udGVudD17Z2V0QWNjZXNzRmFsbGJhY2tFcnJvclR5cGVCeVN0YXR1cyh0cmlnZ2VyZWRTdGF0dXMpfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICApfVxuICAgICAgICAgIHtlcnJvckNvbXBvbmVudHNbdHJpZ2dlcmVkU3RhdHVzXX1cbiAgICAgICAgPC8+XG4gICAgICApXG4gICAgfVxuXG4gICAgcmV0dXJuIGNoaWxkcmVuXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEhUVFBBY2Nlc3NGYWxsYmFja0JvdW5kYXJ5KHtcbiAgbm90Rm91bmQsXG4gIGZvcmJpZGRlbixcbiAgdW5hdXRob3JpemVkLFxuICBjaGlsZHJlbixcbn06IEhUVFBBY2Nlc3NGYWxsYmFja0JvdW5kYXJ5UHJvcHMpIHtcbiAgLy8gV2hlbiB3ZSdyZSByZW5kZXJpbmcgdGhlIG1pc3NpbmcgcGFyYW1zIHNoZWxsLCB0aGlzIHdpbGwgcmV0dXJuIG51bGwuIFRoaXNcbiAgLy8gaXMgYmVjYXVzZSB3ZSB3b24ndCBiZSByZW5kZXJpbmcgYW55IG5vdCBmb3VuZCBib3VuZGFyaWVzIG9yIGVycm9yXG4gIC8vIGJvdW5kYXJpZXMgZm9yIHRoZSBtaXNzaW5nIHBhcmFtcyBzaGVsbC4gV2hlbiB0aGlzIHJ1bnMgb24gdGhlIGNsaWVudFxuICAvLyAod2hlcmUgdGhlc2UgZXJyb3IgY2FuIG9jY3VyKSwgd2Ugd2lsbCBnZXQgdGhlIGNvcnJlY3QgcGF0aG5hbWUuXG4gIGNvbnN0IHBhdGhuYW1lID0gdXNlVW50cmFja2VkUGF0aG5hbWUoKVxuICBjb25zdCBtaXNzaW5nU2xvdHMgPSB1c2VDb250ZXh0KE1pc3NpbmdTbG90Q29udGV4dClcbiAgY29uc3QgaGFzRXJyb3JGYWxsYmFjayA9ICEhKG5vdEZvdW5kIHx8IGZvcmJpZGRlbiB8fCB1bmF1dGhvcml6ZWQpXG5cbiAgaWYgKGhhc0Vycm9yRmFsbGJhY2spIHtcbiAgICByZXR1cm4gKFxuICAgICAgPEhUVFBBY2Nlc3NGYWxsYmFja0Vycm9yQm91bmRhcnlcbiAgICAgICAgcGF0aG5hbWU9e3BhdGhuYW1lfVxuICAgICAgICBub3RGb3VuZD17bm90Rm91bmR9XG4gICAgICAgIGZvcmJpZGRlbj17Zm9yYmlkZGVufVxuICAgICAgICB1bmF1dGhvcml6ZWQ9e3VuYXV0aG9yaXplZH1cbiAgICAgICAgbWlzc2luZ1Nsb3RzPXttaXNzaW5nU2xvdHN9XG4gICAgICA+XG4gICAgICAgIHtjaGlsZHJlbn1cbiAgICAgIDwvSFRUUEFjY2Vzc0ZhbGxiYWNrRXJyb3JCb3VuZGFyeT5cbiAgICApXG4gIH1cblxuICByZXR1cm4gPD57Y2hpbGRyZW59PC8+XG59XG4iXSwibmFtZXMiOlsiSFRUUEFjY2Vzc0ZhbGxiYWNrQm91bmRhcnkiLCJIVFRQQWNjZXNzRmFsbGJhY2tFcnJvckJvdW5kYXJ5IiwiUmVhY3QiLCJDb21wb25lbnQiLCJjb21wb25lbnREaWRDYXRjaCIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsInByb3BzIiwibWlzc2luZ1Nsb3RzIiwic2l6ZSIsImhhcyIsIndhcm5pbmdNZXNzYWdlIiwiZm9ybWF0dGVkU2xvdHMiLCJBcnJheSIsImZyb20iLCJzb3J0IiwiYSIsImIiLCJsb2NhbGVDb21wYXJlIiwibWFwIiwic2xvdCIsImpvaW4iLCJ3YXJuT25jZSIsImdldERlcml2ZWRTdGF0ZUZyb21FcnJvciIsImVycm9yIiwiaXNIVFRQQWNjZXNzRmFsbGJhY2tFcnJvciIsImh0dHBTdGF0dXMiLCJnZXRBY2Nlc3NGYWxsYmFja0hUVFBTdGF0dXMiLCJ0cmlnZ2VyZWRTdGF0dXMiLCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJzdGF0ZSIsInBhdGhuYW1lIiwicHJldmlvdXNQYXRobmFtZSIsInVuZGVmaW5lZCIsInJlbmRlciIsIm5vdEZvdW5kIiwiZm9yYmlkZGVuIiwidW5hdXRob3JpemVkIiwiY2hpbGRyZW4iLCJlcnJvckNvbXBvbmVudHMiLCJIVFRQQWNjZXNzRXJyb3JTdGF0dXMiLCJOT1RfRk9VTkQiLCJGT1JCSURERU4iLCJVTkFVVEhPUklaRUQiLCJpc05vdEZvdW5kIiwiaXNGb3JiaWRkZW4iLCJpc1VuYXV0aG9yaXplZCIsIm1ldGEiLCJuYW1lIiwiY29udGVudCIsImdldEFjY2Vzc0ZhbGxiYWNrRXJyb3JUeXBlQnlTdGF0dXMiLCJjb25zdHJ1Y3RvciIsInVzZVVudHJhY2tlZFBhdGhuYW1lIiwidXNlQ29udGV4dCIsIk1pc3NpbmdTbG90Q29udGV4dCIsImhhc0Vycm9yRmFsbGJhY2siXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/http-access-fallback/error-boundary.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/links.js":
/*!***************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/links.js ***!
  \***************************************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    IDLE_LINK_STATUS: function() {\n        return IDLE_LINK_STATUS;\n    },\n    PENDING_LINK_STATUS: function() {\n        return PENDING_LINK_STATUS;\n    },\n    mountFormInstance: function() {\n        return mountFormInstance;\n    },\n    mountLinkInstance: function() {\n        return mountLinkInstance;\n    },\n    onLinkVisibilityChanged: function() {\n        return onLinkVisibilityChanged;\n    },\n    onNavigationIntent: function() {\n        return onNavigationIntent;\n    },\n    pingVisibleLinks: function() {\n        return pingVisibleLinks;\n    },\n    setLinkForCurrentNavigation: function() {\n        return setLinkForCurrentNavigation;\n    },\n    unmountLinkForCurrentNavigation: function() {\n        return unmountLinkForCurrentNavigation;\n    },\n    unmountPrefetchableInstance: function() {\n        return unmountPrefetchableInstance;\n    }\n});\nconst _approuterinstance = __webpack_require__(/*! ./app-router-instance */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/app-router-instance.js\");\nconst _approuter = __webpack_require__(/*! ./app-router */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/app-router.js\");\nconst _segmentcache = __webpack_require__(/*! ./segment-cache */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/segment-cache.js\");\nconst _react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/compiled/react/index.js\");\nconst _routerreducertypes = __webpack_require__(/*! ./router-reducer/router-reducer-types */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nconst _invarianterror = __webpack_require__(/*! ../../shared/lib/invariant-error */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/shared/lib/invariant-error.js\");\n// Tracks the most recently navigated link instance. When null, indicates\n// the current navigation was not initiated by a link click.\nlet linkForMostRecentNavigation = null;\nconst PENDING_LINK_STATUS = {\n    pending: true\n};\nconst IDLE_LINK_STATUS = {\n    pending: false\n};\nfunction setLinkForCurrentNavigation(link) {\n    (0, _react.startTransition)(()=>{\n        linkForMostRecentNavigation == null ? void 0 : linkForMostRecentNavigation.setOptimisticLinkStatus(IDLE_LINK_STATUS);\n        link == null ? void 0 : link.setOptimisticLinkStatus(PENDING_LINK_STATUS);\n        linkForMostRecentNavigation = link;\n    });\n}\nfunction unmountLinkForCurrentNavigation(link) {\n    if (linkForMostRecentNavigation === link) {\n        linkForMostRecentNavigation = null;\n    }\n}\n// Use a WeakMap to associate a Link instance with its DOM element. This is\n// used by the IntersectionObserver to track the link's visibility.\nconst prefetchable = typeof WeakMap === 'function' ? new WeakMap() : new Map();\n// A Set of the currently visible links. We re-prefetch visible links after a\n// cache invalidation, or when the current URL changes. It's a separate data\n// structure from the WeakMap above because only the visible links need to\n// be enumerated.\nconst prefetchableAndVisible = new Set();\n// A single IntersectionObserver instance shared by all <Link> components.\nconst observer = typeof IntersectionObserver === 'function' ? new IntersectionObserver(handleIntersect, {\n    rootMargin: '200px'\n}) : null;\nfunction observeVisibility(element, instance) {\n    const existingInstance = prefetchable.get(element);\n    if (existingInstance !== undefined) {\n        // This shouldn't happen because each <Link> component should have its own\n        // anchor tag instance, but it's defensive coding to avoid a memory leak in\n        // case there's a logical error somewhere else.\n        unmountPrefetchableInstance(element);\n    }\n    // Only track prefetchable links that have a valid prefetch URL\n    prefetchable.set(element, instance);\n    if (observer !== null) {\n        observer.observe(element);\n    }\n}\nfunction coercePrefetchableUrl(href) {\n    try {\n        return (0, _approuter.createPrefetchURL)(href);\n    } catch (e) {\n        // createPrefetchURL sometimes throws an error if an invalid URL is\n        // provided, though I'm not sure if it's actually necessary.\n        // TODO: Consider removing the throw from the inner function, or change it\n        // to reportError. Or maybe the error isn't even necessary for automatic\n        // prefetches, just navigations.\n        const reportErrorFn = typeof reportError === 'function' ? reportError : console.error;\n        reportErrorFn(\"Cannot prefetch '\" + href + \"' because it cannot be converted to a URL.\");\n        return null;\n    }\n}\nfunction mountLinkInstance(element, href, router, fetchStrategy, prefetchEnabled, setOptimisticLinkStatus) {\n    if (prefetchEnabled) {\n        const prefetchURL = coercePrefetchableUrl(href);\n        if (prefetchURL !== null) {\n            const instance = {\n                router,\n                fetchStrategy,\n                isVisible: false,\n                prefetchTask: null,\n                prefetchHref: prefetchURL.href,\n                setOptimisticLinkStatus\n            };\n            // We only observe the link's visibility if it's prefetchable. For\n            // example, this excludes links to external URLs.\n            observeVisibility(element, instance);\n            return instance;\n        }\n    }\n    // If the link is not prefetchable, we still create an instance so we can\n    // track its optimistic state (i.e. useLinkStatus).\n    const instance = {\n        router,\n        fetchStrategy,\n        isVisible: false,\n        prefetchTask: null,\n        prefetchHref: null,\n        setOptimisticLinkStatus\n    };\n    return instance;\n}\nfunction mountFormInstance(element, href, router, fetchStrategy) {\n    const prefetchURL = coercePrefetchableUrl(href);\n    if (prefetchURL === null) {\n        // This href is not prefetchable, so we don't track it.\n        // TODO: We currently observe/unobserve a form every time its href changes.\n        // For Links, this isn't a big deal because the href doesn't usually change,\n        // but for forms it's extremely common. We should optimize this.\n        return;\n    }\n    const instance = {\n        router,\n        fetchStrategy,\n        isVisible: false,\n        prefetchTask: null,\n        prefetchHref: prefetchURL.href,\n        setOptimisticLinkStatus: null\n    };\n    observeVisibility(element, instance);\n}\nfunction unmountPrefetchableInstance(element) {\n    const instance = prefetchable.get(element);\n    if (instance !== undefined) {\n        prefetchable.delete(element);\n        prefetchableAndVisible.delete(instance);\n        const prefetchTask = instance.prefetchTask;\n        if (prefetchTask !== null) {\n            (0, _segmentcache.cancelPrefetchTask)(prefetchTask);\n        }\n    }\n    if (observer !== null) {\n        observer.unobserve(element);\n    }\n}\nfunction handleIntersect(entries) {\n    for (const entry of entries){\n        // Some extremely old browsers or polyfills don't reliably support\n        // isIntersecting so we check intersectionRatio instead. (Do we care? Not\n        // really. But whatever this is fine.)\n        const isVisible = entry.intersectionRatio > 0;\n        onLinkVisibilityChanged(entry.target, isVisible);\n    }\n}\nfunction onLinkVisibilityChanged(element, isVisible) {\n    if (true) {\n        // Prefetching on viewport is disabled in development for performance\n        // reasons, because it requires compiling the target page.\n        // TODO: Investigate re-enabling this.\n        return;\n    }\n    const instance = prefetchable.get(element);\n    if (instance === undefined) {\n        return;\n    }\n    instance.isVisible = isVisible;\n    if (isVisible) {\n        prefetchableAndVisible.add(instance);\n    } else {\n        prefetchableAndVisible.delete(instance);\n    }\n    rescheduleLinkPrefetch(instance, _segmentcache.PrefetchPriority.Default);\n}\nfunction onNavigationIntent(element, unstable_upgradeToDynamicPrefetch) {\n    const instance = prefetchable.get(element);\n    if (instance === undefined) {\n        return;\n    }\n    // Prefetch the link on hover/touchstart.\n    if (instance !== undefined) {\n        if (false) {}\n        rescheduleLinkPrefetch(instance, _segmentcache.PrefetchPriority.Intent);\n    }\n}\nfunction rescheduleLinkPrefetch(instance, priority) {\n    const existingPrefetchTask = instance.prefetchTask;\n    if (!instance.isVisible) {\n        // Cancel any in-progress prefetch task. (If it already finished then this\n        // is a no-op.)\n        if (existingPrefetchTask !== null) {\n            (0, _segmentcache.cancelPrefetchTask)(existingPrefetchTask);\n        }\n        // We don't need to reset the prefetchTask to null upon cancellation; an\n        // old task object can be rescheduled with reschedulePrefetchTask. This is a\n        // micro-optimization but also makes the code simpler (don't need to\n        // worry about whether an old task object is stale).\n        return;\n    }\n    if (true) {\n        // The old prefetch implementation does not have different priority levels.\n        // Just schedule a new prefetch task.\n        prefetchWithOldCacheImplementation(instance);\n        return;\n    }\n    const appRouterState = (0, _approuterinstance.getCurrentAppRouterState)();\n    if (appRouterState !== null) {\n        const treeAtTimeOfPrefetch = appRouterState.tree;\n        if (existingPrefetchTask === null) {\n            // Initiate a prefetch task.\n            const nextUrl = appRouterState.nextUrl;\n            const cacheKey = (0, _segmentcache.createCacheKey)(instance.prefetchHref, nextUrl);\n            instance.prefetchTask = (0, _segmentcache.schedulePrefetchTask)(cacheKey, treeAtTimeOfPrefetch, instance.fetchStrategy, priority, null);\n        } else {\n            // We already have an old task object that we can reschedule. This is\n            // effectively the same as canceling the old task and creating a new one.\n            (0, _segmentcache.reschedulePrefetchTask)(existingPrefetchTask, treeAtTimeOfPrefetch, instance.fetchStrategy, priority);\n        }\n    }\n}\nfunction pingVisibleLinks(nextUrl, tree) {\n    // For each currently visible link, cancel the existing prefetch task (if it\n    // exists) and schedule a new one. This is effectively the same as if all the\n    // visible links left and then re-entered the viewport.\n    //\n    // This is called when the Next-Url or the base tree changes, since those\n    // may affect the result of a prefetch task. It's also called after a\n    // cache invalidation.\n    for (const instance of prefetchableAndVisible){\n        const task = instance.prefetchTask;\n        if (task !== null && !(0, _segmentcache.isPrefetchTaskDirty)(task, nextUrl, tree)) {\n            continue;\n        }\n        // Something changed. Cancel the existing prefetch task and schedule a\n        // new one.\n        if (task !== null) {\n            (0, _segmentcache.cancelPrefetchTask)(task);\n        }\n        const cacheKey = (0, _segmentcache.createCacheKey)(instance.prefetchHref, nextUrl);\n        instance.prefetchTask = (0, _segmentcache.schedulePrefetchTask)(cacheKey, tree, instance.fetchStrategy, _segmentcache.PrefetchPriority.Default, null);\n    }\n}\nfunction prefetchWithOldCacheImplementation(instance) {\n    // This is the path used when the Segment Cache is not enabled.\n    if (false) {}\n    const doPrefetch = async ()=>{\n        // note that `appRouter.prefetch()` is currently sync,\n        // so we have to wrap this call in an async function to be able to catch() errors below.\n        let prefetchKind;\n        switch(instance.fetchStrategy){\n            case _segmentcache.FetchStrategy.PPR:\n                {\n                    prefetchKind = _routerreducertypes.PrefetchKind.AUTO;\n                    break;\n                }\n            case _segmentcache.FetchStrategy.Full:\n                {\n                    prefetchKind = _routerreducertypes.PrefetchKind.FULL;\n                    break;\n                }\n            case _segmentcache.FetchStrategy.PPRRuntime:\n                {\n                    // We can only get here if Client Segment Cache is off, and in that case\n                    // it shouldn't be possible for a link to request a runtime prefetch.\n                    throw Object.defineProperty(new _invarianterror.InvariantError('FetchStrategy.PPRRuntime should never be used when `experimental.clientSegmentCache` is disabled'), \"__NEXT_ERROR_CODE\", {\n                        value: \"E772\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n            default:\n                {\n                    instance.fetchStrategy;\n                    // Unreachable, but otherwise typescript will consider the variable unassigned\n                    prefetchKind = undefined;\n                }\n        }\n        return instance.router.prefetch(instance.prefetchHref, {\n            kind: prefetchKind\n        });\n    };\n    // Prefetch the page if asked (only in the client)\n    // We need to handle a prefetch error here since we may be\n    // loading with priority which can reject but we don't\n    // want to force navigation since this is only a prefetch\n    doPrefetch().catch((err)=>{\n        if (true) {\n            // rethrow to show invalid URL errors\n            throw err;\n        }\n    });\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=links.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE1LjUuMTJfcmVhY3QtZG9tQDE5LjIuNF9yZWFjdEAxOS4yLjRfX3JlYWN0QDE5LjIuNC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2xpbmtzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztJQW9FYUEsZ0JBQWdCO2VBQWhCQTs7SUFIQUMsbUJBQW1CO2VBQW5CQTs7SUFvSEdDLGlCQUFpQjtlQUFqQkE7O0lBdENBQyxpQkFBaUI7ZUFBakJBOztJQXdGQUMsdUJBQXVCO2VBQXZCQTs7SUFzQkFDLGtCQUFrQjtlQUFsQkE7O0lBMEVBQyxnQkFBZ0I7ZUFBaEJBOztJQTdQQUMsMkJBQTJCO2VBQTNCQTs7SUFTQUMsK0JBQStCO2VBQS9CQTs7SUEySEFDLDJCQUEyQjtlQUEzQkE7OzsrQ0E1TXlCO3VDQUNQOzBDQUszQjttQ0FTeUI7Z0RBQ0g7NENBQ0U7QUF5Qy9CLHlFQUF5RTtBQUN6RSw0REFBNEQ7QUFDNUQsSUFBSUMsOEJBQW1EO0FBR2hELE1BQU1ULHNCQUFzQjtJQUFFVSxTQUFTO0FBQUs7QUFHNUMsTUFBTVgsbUJBQW1CO0lBQUVXLFNBQVM7QUFBTTtBQU0xQyxTQUFTSiw0QkFBNEJLLElBQXlCO0lBQ25FQyxDQUFBQSxHQUFBQSxPQUFBQSxlQUFBQSxFQUFnQjtRQUNkSCwrQkFBQUEsT0FBQUEsS0FBQUEsSUFBQUEsNEJBQTZCSSx1QkFBdUIsQ0FBQ2Q7UUFDckRZLFFBQUFBLE9BQUFBLEtBQUFBLElBQUFBLEtBQU1FLHVCQUF1QixDQUFDYjtRQUM5QlMsOEJBQThCRTtJQUNoQztBQUNGO0FBR08sU0FBU0osZ0NBQWdDSSxJQUFrQjtJQUNoRSxJQUFJRixnQ0FBZ0NFLE1BQU07UUFDeENGLDhCQUE4QjtJQUNoQztBQUNGO0FBRUEsMkVBQTJFO0FBQzNFLG1FQUFtRTtBQUNuRSxNQUFNSyxlQUdKLE9BQU9DLFlBQVksYUFBYSxJQUFJQSxZ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QWtEO0lBQ2xELDBEQUEwRDtJQUMxRCxzREFBc0Q7SUFDdEQseURBQXlEO0lBQ3pERCxhQUFhVSxLQUFLLENBQUMsQ0FBQ0M7UUFDbEIsSUF2UkYsSUF1UjBCLEVBQW1CO1lBQ3pDLHFDQUFxQztZQUNyQyxNQUFNQTtRQUNSO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL3NhYmluZXJlc29hZ2xpL3NyYy9jbGllbnQvY29tcG9uZW50cy9saW5rcy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IEZsaWdodFJvdXRlclN0YXRlIH0gZnJvbSAnLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvdHlwZXMnXG5pbXBvcnQgdHlwZSB7IEFwcFJvdXRlckluc3RhbmNlIH0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgeyBnZXRDdXJyZW50QXBwUm91dGVyU3RhdGUgfSBmcm9tICcuL2FwcC1yb3V0ZXItaW5zdGFuY2UnXG5pbXBvcnQgeyBjcmVhdGVQcmVmZXRjaFVSTCB9IGZyb20gJy4vYXBwLXJvdXRlcidcbmltcG9ydCB7XG4gIEZldGNoU3RyYXRlZ3ksXG4gIGlzUHJlZmV0Y2hUYXNrRGlydHksXG4gIHR5cGUgUHJlZmV0Y2hUYXNrRmV0Y2hTdHJhdGVneSxcbn0gZnJvbSAnLi9zZWdtZW50LWNhY2hlJ1xuaW1wb3J0IHsgY3JlYXRlQ2FjaGVLZXkgfSBmcm9tICcuL3NlZ21lbnQtY2FjaGUnXG5pbXBvcnQge1xuICB0eXBlIFByZWZldGNoVGFzayxcbiAgUHJlZmV0Y2hQcmlvcml0eSxcbiAgc2NoZWR1bGVQcmVmZXRjaFRhc2sgYXMgc2NoZWR1bGVTZWdtZW50UHJlZmV0Y2hUYXNrLFxuICBjYW5jZWxQcmVmZXRjaFRhc2ssXG4gIHJlc2NoZWR1bGVQcmVmZXRjaFRhc2ssXG59IGZyb20gJy4vc2VnbWVudC1jYWNoZSdcbmltcG9ydCB7IHN0YXJ0VHJhbnNpdGlvbiB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgUHJlZmV0Y2hLaW5kIH0gZnJvbSAnLi9yb3V0ZXItcmVkdWNlci9yb3V0ZXItcmVkdWNlci10eXBlcydcbmltcG9ydCB7IEludmFyaWFudEVycm9yIH0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi9pbnZhcmlhbnQtZXJyb3InXG5cbnR5cGUgTGlua0VsZW1lbnQgPSBIVE1MQW5jaG9yRWxlbWVudCB8IFNWR0FFbGVtZW50XG5cbnR5cGUgRWxlbWVudCA9IExpbmtFbGVtZW50IHwgSFRNTEZvcm1FbGVtZW50XG5cbi8vIFByb3BlcnRpZXMgdGhhdCBhcmUgc2hhcmVkIGJldHdlZW4gTGluayBhbmQgRm9ybSBpbnN0YW5jZXMuIFdlIHVzZSB0aGUgc2FtZVxuLy8gc2hhcGUgZm9yIGJvdGggdG8gcHJldmVudCBhIHBvbHltb3JwaGljIGRlLW9wdCBpbiB0aGUgVk0uXG50eXBlIExpbmtPckZvcm1JbnN0YW5jZVNoYXJlZCA9IHtcbiAgcm91dGVyOiBBcHBSb3V0ZXJJbnN0YW5jZVxuICBmZXRjaFN0cmF0ZWd5OiBQcmVmZXRjaFRhc2tGZXRjaFN0cmF0ZWd5XG5cbiAgaXNWaXNpYmxlOiBib29sZWFuXG5cbiAgLy8gVGhlIG1vc3QgcmVjZW50bHkgaW5pdGlhdGVkIHByZWZldGNoIHRhc2suIEl0IG1heSBvciBtYXkgbm90IGhhdmVcbiAgLy8gYWxyZWFkeSBjb21wbGV0ZWQuIFRoZSBzYW1lIHByZWZldGNoIHRhc2sgb2JqZWN0IGNhbiBiZSByZXVzZWQgYWNyb3NzXG4gIC8vIG11bHRpcGxlIHByZWZldGNoZXMgb2YgdGhlIHNhbWUgbGluay5cbiAgcHJlZmV0Y2hUYXNrOiBQcmVmZXRjaFRhc2sgfCBudWxsXG59XG5cbmV4cG9ydCB0eXBlIEZvcm1JbnN0YW5jZSA9IExpbmtPckZvcm1JbnN0YW5jZVNoYXJlZCAmIHtcbiAgcHJlZmV0Y2hIcmVmOiBzdHJpbmdcbiAgc2V0T3B0aW1pc3RpY0xpbmtTdGF0dXM6IG51bGxcbn1cblxudHlwZSBQcmVmZXRjaGFibGVMaW5rSW5zdGFuY2UgPSBMaW5rT3JGb3JtSW5zdGFuY2VTaGFyZWQgJiB7XG4gIHByZWZldGNoSHJlZjogc3RyaW5nXG4gIHNldE9wdGltaXN0aWNMaW5rU3RhdHVzOiAoc3RhdHVzOiB7IHBlbmRpbmc6IGJvb2xlYW4gfSkgPT4gdm9pZFxufVxuXG50eXBlIE5vblByZWZldGNoYWJsZUxpbmtJbnN0YW5jZSA9IExpbmtPckZvcm1JbnN0YW5jZVNoYXJlZCAmIHtcbiAgcHJlZmV0Y2hIcmVmOiBudWxsXG4gIHNldE9wdGltaXN0aWNMaW5rU3RhdHVzOiAoc3RhdHVzOiB7IHBlbmRpbmc6IGJvb2xlYW4gfSkgPT4gdm9pZFxufVxuXG50eXBlIFByZWZldGNoYWJsZUluc3RhbmNlID0gUHJlZmV0Y2hhYmxlTGlua0luc3RhbmNlIHwgRm9ybUluc3RhbmNlXG5cbmV4cG9ydCB0eXBlIExpbmtJbnN0YW5jZSA9XG4gIHwgUHJlZmV0Y2hhYmxlTGlua0luc3RhbmNlXG4gIHwgTm9uUHJlZmV0Y2hhYmxlTGlua0luc3RhbmNlXG5cbi8vIFRyYWNrcyB0aGUgbW9zdCByZWNlbnRseSBuYXZpZ2F0ZWQgbGluayBpbnN0YW5jZS4gV2hlbiBudWxsLCBpbmRpY2F0ZXNcbi8vIHRoZSBjdXJyZW50IG5hdmlnYXRpb24gd2FzIG5vdCBpbml0aWF0ZWQgYnkgYSBsaW5rIGNsaWNrLlxubGV0IGxpbmtGb3JNb3N0UmVjZW50TmF2aWdhdGlvbjogTGlua0luc3RhbmNlIHwgbnVsbCA9IG51bGxcblxuLy8gU3RhdHVzIG9iamVjdCBpbmRpY2F0aW5nIGxpbmsgaXMgcGVuZGluZ1xuZXhwb3J0IGNvbnN0IFBFTkRJTkdfTElOS19TVEFUVVMgPSB7IHBlbmRpbmc6IHRydWUgfVxuXG4vLyBTdGF0dXMgb2JqZWN0IGluZGljYXRpbmcgbGluayBpcyBpZGxlXG5leHBvcnQgY29uc3QgSURMRV9MSU5LX1NUQVRVUyA9IHsgcGVuZGluZzogZmFsc2UgfVxuXG4vLyBVcGRhdGVzIHRoZSBsb2FkaW5nIHN0YXRlIHdoZW4gbmF2aWdhdGluZyBiZXR3ZWVuIGxpbmtzXG4vLyAtIFJlc2V0cyB0aGUgcHJldmlvdXMgbGluaydzIGxvYWRpbmcgc3RhdGVcbi8vIC0gU2V0cyB0aGUgbmV3IGxpbmsncyBsb2FkaW5nIHN0YXRlXG4vLyAtIFVwZGF0ZXMgdHJhY2tpbmcgb2YgY3VycmVudCBuYXZpZ2F0aW9uXG5leHBvcnQgZnVuY3Rpb24gc2V0TGlua0ZvckN1cnJlbnROYXZpZ2F0aW9uKGxpbms6IExpbmtJbnN0YW5jZSB8IG51bGwpIHtcbiAgc3RhcnRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICBsaW5rRm9yTW9zdFJlY2VudE5hdmlnYXRpb24/LnNldE9wdGltaXN0aWNMaW5rU3RhdHVzKElETEVfTElOS19TVEFUVVMpXG4gICAgbGluaz8uc2V0T3B0aW1pc3RpY0xpbmtTdGF0dXMoUEVORElOR19MSU5LX1NUQVRVUylcbiAgICBsaW5rRm9yTW9zdFJlY2VudE5hdmlnYXRpb24gPSBsaW5rXG4gIH0pXG59XG5cbi8vIFVubW91bnRzIHRoZSBjdXJyZW50IGxpbmsgaW5zdGFuY2UgZnJvbSBuYXZpZ2F0aW9uIHRyYWNraW5nXG5leHBvcnQgZnVuY3Rpb24gdW5tb3VudExpbmtGb3JDdXJyZW50TmF2aWdhdGlvbihsaW5rOiBMaW5rSW5zdGFuY2UpIHtcbiAgaWYgKGxpbmtGb3JNb3N0UmVjZW50TmF2aWdhdGlvbiA9PT0gbGluaykge1xuICAgIGxpbmtGb3JNb3N0UmVjZW50TmF2aWdhdGlvbiA9IG51bGxcbiAgfVxufVxuXG4vLyBVc2UgYSBXZWFrTWFwIHRvIGFzc29jaWF0ZSBhIExpbmsgaW5zdGFuY2Ugd2l0aCBpdHMgRE9NIGVsZW1lbnQuIFRoaXMgaXNcbi8vIHVzZWQgYnkgdGhlIEludGVyc2VjdGlvbk9ic2VydmVyIHRvIHRyYWNrIHRoZSBsaW5rJ3MgdmlzaWJpbGl0eS5cbmNvbnN0IHByZWZldGNoYWJsZTpcbiAgfCBXZWFrTWFwPEVsZW1lbnQsIFByZWZldGNoYWJsZUluc3RhbmNlPlxuICB8IE1hcDxFbGVtZW50LCBQcmVmZXRjaGFibGVJbnN0YW5jZT4gPVxuICB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IG5ldyBXZWFrTWFwKCkgOiBuZXcgTWFwKClcblxuLy8gQSBTZXQgb2YgdGhlIGN1cnJlbnRseSB2aXNpYmxlIGxpbmtzLiBXZSByZS1wcmVmZXRjaCB2aXNpYmxlIGxpbmtzIGFmdGVyIGFcbi8vIGNhY2hlIGludmFsaWRhdGlvbiwgb3Igd2hlbiB0aGUgY3VycmVudCBVUkwgY2hhbmdlcy4gSXQncyBhIHNlcGFyYXRlIGRhdGFcbi8vIHN0cnVjdHVyZSBmcm9tIHRoZSBXZWFrTWFwIGFib3ZlIGJlY2F1c2Ugb25seSB0aGUgdmlzaWJsZSBsaW5rcyBuZWVkIHRvXG4vLyBiZSBlbnVtZXJhdGVkLlxuY29uc3QgcHJlZmV0Y2hhYmxlQW5kVmlzaWJsZTogU2V0PFByZWZldGNoYWJsZUluc3RhbmNlPiA9IG5ldyBTZXQoKVxuXG4vLyBBIHNpbmdsZSBJbnRlcnNlY3Rpb25PYnNlcnZlciBpbnN0YW5jZSBzaGFyZWQgYnkgYWxsIDxMaW5rPiBjb21wb25lbnRzLlxuY29uc3Qgb2JzZXJ2ZXI6IEludGVyc2VjdGlvbk9ic2VydmVyIHwgbnVsbCA9XG4gIHR5cGVvZiBJbnRlcnNlY3Rpb25PYnNlcnZlciA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGhhbmRsZUludGVyc2VjdCwge1xuICAgICAgICByb290TWFyZ2luOiAnMjAwcHgnLFxuICAgICAgfSlcbiAgICA6IG51bGxcblxuZnVuY3Rpb24gb2JzZXJ2ZVZpc2liaWxpdHkoZWxlbWVudDogRWxlbWVudCwgaW5zdGFuY2U6IFByZWZldGNoYWJsZUluc3RhbmNlKSB7XG4gIGNvbnN0IGV4aXN0aW5nSW5zdGFuY2UgPSBwcmVmZXRjaGFibGUuZ2V0KGVsZW1lbnQpXG4gIGlmIChleGlzdGluZ0luc3RhbmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBUaGlzIHNob3VsZG4ndCBoYXBwZW4gYmVjYXVzZSBlYWNoIDxMaW5rPiBjb21wb25lbnQgc2hvdWxkIGhhdmUgaXRzIG93blxuICAgIC8vIGFuY2hvciB0YWcgaW5zdGFuY2UsIGJ1dCBpdCdzIGRlZmVuc2l2ZSBjb2RpbmcgdG8gYXZvaWQgYSBtZW1vcnkgbGVhayBpblxuICAgIC8vIGNhc2UgdGhlcmUncyBhIGxvZ2ljYWwgZXJyb3Igc29tZXdoZXJlIGVsc2UuXG4gICAgdW5tb3VudFByZWZldGNoYWJsZUluc3RhbmNlKGVsZW1lbnQpXG4gIH1cbiAgLy8gT25seSB0cmFjayBwcmVmZXRjaGFibGUgbGlua3MgdGhhdCBoYXZlIGEgdmFsaWQgcHJlZmV0Y2ggVVJMXG4gIHByZWZldGNoYWJsZS5zZXQoZWxlbWVudCwgaW5zdGFuY2UpXG4gIGlmIChvYnNlcnZlciAhPT0gbnVsbCkge1xuICAgIG9ic2VydmVyLm9ic2VydmUoZWxlbWVudClcbiAgfVxufVxuXG5mdW5jdGlvbiBjb2VyY2VQcmVmZXRjaGFibGVVcmwoaHJlZjogc3RyaW5nKTogVVJMIHwgbnVsbCB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGNyZWF0ZVByZWZldGNoVVJMKGhyZWYpXG4gIH0gY2F0Y2gge1xuICAgIC8vIGNyZWF0ZVByZWZldGNoVVJMIHNvbWV0aW1lcyB0aHJvd3MgYW4gZXJyb3IgaWYgYW4gaW52YWxpZCBVUkwgaXNcbiAgICAvLyBwcm92aWRlZCwgdGhvdWdoIEknbSBub3Qgc3VyZSBpZiBpdCdzIGFjdHVhbGx5IG5lY2Vzc2FyeS5cbiAgICAvLyBUT0RPOiBDb25zaWRlciByZW1vdmluZyB0aGUgdGhyb3cgZnJvbSB0aGUgaW5uZXIgZnVuY3Rpb24sIG9yIGNoYW5nZSBpdFxuICAgIC8vIHRvIHJlcG9ydEVycm9yLiBPciBtYXliZSB0aGUgZXJyb3IgaXNuJ3QgZXZlbiBuZWNlc3NhcnkgZm9yIGF1dG9tYXRpY1xuICAgIC8vIHByZWZldGNoZXMsIGp1c3QgbmF2aWdhdGlvbnMuXG4gICAgY29uc3QgcmVwb3J0RXJyb3JGbiA9XG4gICAgICB0eXBlb2YgcmVwb3J0RXJyb3IgPT09ICdmdW5jdGlvbicgPyByZXBvcnRFcnJvciA6IGNvbnNvbGUuZXJyb3JcbiAgICByZXBvcnRFcnJvckZuKFxuICAgICAgYENhbm5vdCBwcmVmZXRjaCAnJHtocmVmfScgYmVjYXVzZSBpdCBjYW5ub3QgYmUgY29udmVydGVkIHRvIGEgVVJMLmBcbiAgICApXG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbW91bnRMaW5rSW5zdGFuY2UoXG4gIGVsZW1lbnQ6IExpbmtFbGVtZW50LFxuICBocmVmOiBzdHJpbmcsXG4gIHJvdXRlcjogQXBwUm91dGVySW5zdGFuY2UsXG4gIGZldGNoU3RyYXRlZ3k6IFByZWZldGNoVGFza0ZldGNoU3RyYXRlZ3ksXG4gIHByZWZldGNoRW5hYmxlZDogYm9vbGVhbixcbiAgc2V0T3B0aW1pc3RpY0xpbmtTdGF0dXM6IChzdGF0dXM6IHsgcGVuZGluZzogYm9vbGVhbiB9KSA9PiB2b2lkXG4pOiBMaW5rSW5zdGFuY2Uge1xuICBpZiAocHJlZmV0Y2hFbmFibGVkKSB7XG4gICAgY29uc3QgcHJlZmV0Y2hVUkwgPSBjb2VyY2VQcmVmZXRjaGFibGVVcmwoaHJlZilcbiAgICBpZiAocHJlZmV0Y2hVUkwgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGluc3RhbmNlOiBQcmVmZXRjaGFibGVMaW5rSW5zdGFuY2UgPSB7XG4gICAgICAgIHJvdXRlcixcbiAgICAgICAgZmV0Y2hTdHJhdGVneSxcbiAgICAgICAgaXNWaXNpYmxlOiBmYWxzZSxcbiAgICAgICAgcHJlZmV0Y2hUYXNrOiBudWxsLFxuICAgICAgICBwcmVmZXRjaEhyZWY6IHByZWZldGNoVVJMLmhyZWYsXG4gICAgICAgIHNldE9wdGltaXN0aWNMaW5rU3RhdHVzLFxuICAgICAgfVxuICAgICAgLy8gV2Ugb25seSBvYnNlcnZlIHRoZSBsaW5rJ3MgdmlzaWJpbGl0eSBpZiBpdCdzIHByZWZldGNoYWJsZS4gRm9yXG4gICAgICAvLyBleGFtcGxlLCB0aGlzIGV4Y2x1ZGVzIGxpbmtzIHRvIGV4dGVybmFsIFVSTHMuXG4gICAgICBvYnNlcnZlVmlzaWJpbGl0eShlbGVtZW50LCBpbnN0YW5jZSlcbiAgICAgIHJldHVybiBpbnN0YW5jZVxuICAgIH1cbiAgfVxuICAvLyBJZiB0aGUgbGluayBpcyBub3QgcHJlZmV0Y2hhYmxlLCB3ZSBzdGlsbCBjcmVhdGUgYW4gaW5zdGFuY2Ugc28gd2UgY2FuXG4gIC8vIHRyYWNrIGl0cyBvcHRpbWlzdGljIHN0YXRlIChpLmUuIHVzZUxpbmtTdGF0dXMpLlxuICBjb25zdCBpbnN0YW5jZTogTm9uUHJlZmV0Y2hhYmxlTGlua0luc3RhbmNlID0ge1xuICAgIHJvdXRlcixcbiAgICBmZXRjaFN0cmF0ZWd5LFxuICAgIGlzVmlzaWJsZTogZmFsc2UsXG4gICAgcHJlZmV0Y2hUYXNrOiBudWxsLFxuICAgIHByZWZldGNoSHJlZjogbnVsbCxcbiAgICBzZXRPcHRpbWlzdGljTGlua1N0YXR1cyxcbiAgfVxuICByZXR1cm4gaW5zdGFuY2Vcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1vdW50Rm9ybUluc3RhbmNlKFxuICBlbGVtZW50OiBIVE1MRm9ybUVsZW1lbnQsXG4gIGhyZWY6IHN0cmluZyxcbiAgcm91dGVyOiBBcHBSb3V0ZXJJbnN0YW5jZSxcbiAgZmV0Y2hTdHJhdGVneTogUHJlZmV0Y2hUYXNrRmV0Y2hTdHJhdGVneVxuKTogdm9pZCB7XG4gIGNvbnN0IHByZWZldGNoVVJMID0gY29lcmNlUHJlZmV0Y2hhYmxlVXJsKGhyZWYpXG4gIGlmIChwcmVmZXRjaFVSTCA9PT0gbnVsbCkge1xuICAgIC8vIFRoaXMgaHJlZiBpcyBub3QgcHJlZmV0Y2hhYmxlLCBzbyB3ZSBkb24ndCB0cmFjayBpdC5cbiAgICAvLyBUT0RPOiBXZSBjdXJyZW50bHkgb2JzZXJ2ZS91bm9ic2VydmUgYSBmb3JtIGV2ZXJ5IHRpbWUgaXRzIGhyZWYgY2hhbmdlcy5cbiAgICAvLyBGb3IgTGlua3MsIHRoaXMgaXNuJ3QgYSBiaWcgZGVhbCBiZWNhdXNlIHRoZSBocmVmIGRvZXNuJ3QgdXN1YWxseSBjaGFuZ2UsXG4gICAgLy8gYnV0IGZvciBmb3JtcyBpdCdzIGV4dHJlbWVseSBjb21tb24uIFdlIHNob3VsZCBvcHRpbWl6ZSB0aGlzLlxuICAgIHJldHVyblxuICB9XG4gIGNvbnN0IGluc3RhbmNlOiBGb3JtSW5zdGFuY2UgPSB7XG4gICAgcm91dGVyLFxuICAgIGZldGNoU3RyYXRlZ3ksXG4gICAgaXNWaXNpYmxlOiBmYWxzZSxcbiAgICBwcmVmZXRjaFRhc2s6IG51bGwsXG4gICAgcHJlZmV0Y2hIcmVmOiBwcmVmZXRjaFVSTC5ocmVmLFxuICAgIHNldE9wdGltaXN0aWNMaW5rU3RhdHVzOiBudWxsLFxuICB9XG4gIG9ic2VydmVWaXNpYmlsaXR5KGVsZW1lbnQsIGluc3RhbmNlKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdW5tb3VudFByZWZldGNoYWJsZUluc3RhbmNlKGVsZW1lbnQ6IEVsZW1lbnQpIHtcbiAgY29uc3QgaW5zdGFuY2UgPSBwcmVmZXRjaGFibGUuZ2V0KGVsZW1lbnQpXG4gIGlmIChpbnN0YW5jZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcHJlZmV0Y2hhYmxlLmRlbGV0ZShlbGVtZW50KVxuICAgIHByZWZldGNoYWJsZUFuZFZpc2libGUuZGVsZXRlKGluc3RhbmNlKVxuICAgIGNvbnN0IHByZWZldGNoVGFzayA9IGluc3RhbmNlLnByZWZldGNoVGFza1xuICAgIGlmIChwcmVmZXRjaFRhc2sgIT09IG51bGwpIHtcbiAgICAgIGNhbmNlbFByZWZldGNoVGFzayhwcmVmZXRjaFRhc2spXG4gICAgfVxuICB9XG4gIGlmIChvYnNlcnZlciAhPT0gbnVsbCkge1xuICAgIG9ic2VydmVyLnVub2JzZXJ2ZShlbGVtZW50KVxuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUludGVyc2VjdChlbnRyaWVzOiBBcnJheTxJbnRlcnNlY3Rpb25PYnNlcnZlckVudHJ5Pikge1xuICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICAvLyBTb21lIGV4dHJlbWVseSBvbGQgYnJvd3NlcnMgb3IgcG9seWZpbGxzIGRvbid0IHJlbGlhYmx5IHN1cHBvcnRcbiAgICAvLyBpc0ludGVyc2VjdGluZyBzbyB3ZSBjaGVjayBpbnRlcnNlY3Rpb25SYXRpbyBpbnN0ZWFkLiAoRG8gd2UgY2FyZT8gTm90XG4gICAgLy8gcmVhbGx5LiBCdXQgd2hhdGV2ZXIgdGhpcyBpcyBmaW5lLilcbiAgICBjb25zdCBpc1Zpc2libGUgPSBlbnRyeS5pbnRlcnNlY3Rpb25SYXRpbyA+IDBcbiAgICBvbkxpbmtWaXNpYmlsaXR5Q2hhbmdlZChlbnRyeS50YXJnZXQgYXMgSFRNTEFuY2hvckVsZW1lbnQsIGlzVmlzaWJsZSlcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gb25MaW5rVmlzaWJpbGl0eUNoYW5nZWQoZWxlbWVudDogRWxlbWVudCwgaXNWaXNpYmxlOiBib29sZWFuKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gUHJlZmV0Y2hpbmcgb24gdmlld3BvcnQgaXMgZGlzYWJsZWQgaW4gZGV2ZWxvcG1lbnQgZm9yIHBlcmZvcm1hbmNlXG4gICAgLy8gcmVhc29ucywgYmVjYXVzZSBpdCByZXF1aXJlcyBjb21waWxpbmcgdGhlIHRhcmdldCBwYWdlLlxuICAgIC8vIFRPRE86IEludmVzdGlnYXRlIHJlLWVuYWJsaW5nIHRoaXMuXG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCBpbnN0YW5jZSA9IHByZWZldGNoYWJsZS5nZXQoZWxlbWVudClcbiAgaWYgKGluc3RhbmNlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGluc3RhbmNlLmlzVmlzaWJsZSA9IGlzVmlzaWJsZVxuICBpZiAoaXNWaXNpYmxlKSB7XG4gICAgcHJlZmV0Y2hhYmxlQW5kVmlzaWJsZS5hZGQoaW5zdGFuY2UpXG4gIH0gZWxzZSB7XG4gICAgcHJlZmV0Y2hhYmxlQW5kVmlzaWJsZS5kZWxldGUoaW5zdGFuY2UpXG4gIH1cbiAgcmVzY2hlZHVsZUxpbmtQcmVmZXRjaChpbnN0YW5jZSwgUHJlZmV0Y2hQcmlvcml0eS5EZWZhdWx0KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gb25OYXZpZ2F0aW9uSW50ZW50KFxuICBlbGVtZW50OiBIVE1MQW5jaG9yRWxlbWVudCB8IFNWR0FFbGVtZW50LFxuICB1bnN0YWJsZV91cGdyYWRlVG9EeW5hbWljUHJlZmV0Y2g6IGJvb2xlYW5cbikge1xuICBjb25zdCBpbnN0YW5jZSA9IHByZWZldGNoYWJsZS5nZXQoZWxlbWVudClcbiAgaWYgKGluc3RhbmNlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm5cbiAgfVxuICAvLyBQcmVmZXRjaCB0aGUgbGluayBvbiBob3Zlci90b3VjaHN0YXJ0LlxuICBpZiAoaW5zdGFuY2UgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChcbiAgICAgIHByb2Nlc3MuZW52Ll9fTkVYVF9EWU5BTUlDX09OX0hPVkVSICYmXG4gICAgICB1bnN0YWJsZV91cGdyYWRlVG9EeW5hbWljUHJlZmV0Y2hcbiAgICApIHtcbiAgICAgIC8vIFN3aXRjaCB0byBhIGZ1bGwgcHJlZmV0Y2hcbiAgICAgIGluc3RhbmNlLmZldGNoU3RyYXRlZ3kgPSBGZXRjaFN0cmF0ZWd5LkZ1bGxcbiAgICB9XG4gICAgcmVzY2hlZHVsZUxpbmtQcmVmZXRjaChpbnN0YW5jZSwgUHJlZmV0Y2hQcmlvcml0eS5JbnRlbnQpXG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzY2hlZHVsZUxpbmtQcmVmZXRjaChcbiAgaW5zdGFuY2U6IFByZWZldGNoYWJsZUluc3RhbmNlLFxuICBwcmlvcml0eTogUHJlZmV0Y2hQcmlvcml0eS5EZWZhdWx0IHwgUHJlZmV0Y2hQcmlvcml0eS5JbnRlbnRcbikge1xuICBjb25zdCBleGlzdGluZ1ByZWZldGNoVGFzayA9IGluc3RhbmNlLnByZWZldGNoVGFza1xuXG4gIGlmICghaW5zdGFuY2UuaXNWaXNpYmxlKSB7XG4gICAgLy8gQ2FuY2VsIGFueSBpbi1wcm9ncmVzcyBwcmVmZXRjaCB0YXNrLiAoSWYgaXQgYWxyZWFkeSBmaW5pc2hlZCB0aGVuIHRoaXNcbiAgICAvLyBpcyBhIG5vLW9wLilcbiAgICBpZiAoZXhpc3RpbmdQcmVmZXRjaFRhc2sgIT09IG51bGwpIHtcbiAgICAgIGNhbmNlbFByZWZldGNoVGFzayhleGlzdGluZ1ByZWZldGNoVGFzaylcbiAgICB9XG4gICAgLy8gV2UgZG9uJ3QgbmVlZCB0byByZXNldCB0aGUgcHJlZmV0Y2hUYXNrIHRvIG51bGwgdXBvbiBjYW5jZWxsYXRpb247IGFuXG4gICAgLy8gb2xkIHRhc2sgb2JqZWN0IGNhbiBiZSByZXNjaGVkdWxlZCB3aXRoIHJlc2NoZWR1bGVQcmVmZXRjaFRhc2suIFRoaXMgaXMgYVxuICAgIC8vIG1pY3JvLW9wdGltaXphdGlvbiBidXQgYWxzbyBtYWtlcyB0aGUgY29kZSBzaW1wbGVyIChkb24ndCBuZWVkIHRvXG4gICAgLy8gd29ycnkgYWJvdXQgd2hldGhlciBhbiBvbGQgdGFzayBvYmplY3QgaXMgc3RhbGUpLlxuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKCFwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1NFR01FTlRfQ0FDSEUpIHtcbiAgICAvLyBUaGUgb2xkIHByZWZldGNoIGltcGxlbWVudGF0aW9uIGRvZXMgbm90IGhhdmUgZGlmZmVyZW50IHByaW9yaXR5IGxldmVscy5cbiAgICAvLyBKdXN0IHNjaGVkdWxlIGEgbmV3IHByZWZldGNoIHRhc2suXG4gICAgcHJlZmV0Y2hXaXRoT2xkQ2FjaGVJbXBsZW1lbnRhdGlvbihpbnN0YW5jZSlcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IGFwcFJvdXRlclN0YXRlID0gZ2V0Q3VycmVudEFwcFJvdXRlclN0YXRlKClcbiAgaWYgKGFwcFJvdXRlclN0YXRlICE9PSBudWxsKSB7XG4gICAgY29uc3QgdHJlZUF0VGltZU9mUHJlZmV0Y2ggPSBhcHBSb3V0ZXJTdGF0ZS50cmVlXG4gICAgaWYgKGV4aXN0aW5nUHJlZmV0Y2hUYXNrID09PSBudWxsKSB7XG4gICAgICAvLyBJbml0aWF0ZSBhIHByZWZldGNoIHRhc2suXG4gICAgICBjb25zdCBuZXh0VXJsID0gYXBwUm91dGVyU3RhdGUubmV4dFVybFxuICAgICAgY29uc3QgY2FjaGVLZXkgPSBjcmVhdGVDYWNoZUtleShpbnN0YW5jZS5wcmVmZXRjaEhyZWYsIG5leHRVcmwpXG4gICAgICBpbnN0YW5jZS5wcmVmZXRjaFRhc2sgPSBzY2hlZHVsZVNlZ21lbnRQcmVmZXRjaFRhc2soXG4gICAgICAgIGNhY2hlS2V5LFxuICAgICAgICB0cmVlQXRUaW1lT2ZQcmVmZXRjaCxcbiAgICAgICAgaW5zdGFuY2UuZmV0Y2hTdHJhdGVneSxcbiAgICAgICAgcHJpb3JpdHksXG4gICAgICAgIG51bGxcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gV2UgYWxyZWFkeSBoYXZlIGFuIG9sZCB0YXNrIG9iamVjdCB0aGF0IHdlIGNhbiByZXNjaGVkdWxlLiBUaGlzIGlzXG4gICAgICAvLyBlZmZlY3RpdmVseSB0aGUgc2FtZSBhcyBjYW5jZWxpbmcgdGhlIG9sZCB0YXNrIGFuZCBjcmVhdGluZyBhIG5ldyBvbmUuXG4gICAgICByZXNjaGVkdWxlUHJlZmV0Y2hUYXNrKFxuICAgICAgICBleGlzdGluZ1ByZWZldGNoVGFzayxcbiAgICAgICAgdHJlZUF0VGltZU9mUHJlZmV0Y2gsXG4gICAgICAgIGluc3RhbmNlLmZldGNoU3RyYXRlZ3ksXG4gICAgICAgIHByaW9yaXR5XG4gICAgICApXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwaW5nVmlzaWJsZUxpbmtzKFxuICBuZXh0VXJsOiBzdHJpbmcgfCBudWxsLFxuICB0cmVlOiBGbGlnaHRSb3V0ZXJTdGF0ZVxuKSB7XG4gIC8vIEZvciBlYWNoIGN1cnJlbnRseSB2aXNpYmxlIGxpbmssIGNhbmNlbCB0aGUgZXhpc3RpbmcgcHJlZmV0Y2ggdGFzayAoaWYgaXRcbiAgLy8gZXhpc3RzKSBhbmQgc2NoZWR1bGUgYSBuZXcgb25lLiBUaGlzIGlzIGVmZmVjdGl2ZWx5IHRoZSBzYW1lIGFzIGlmIGFsbCB0aGVcbiAgLy8gdmlzaWJsZSBsaW5rcyBsZWZ0IGFuZCB0aGVuIHJlLWVudGVyZWQgdGhlIHZpZXdwb3J0LlxuICAvL1xuICAvLyBUaGlzIGlzIGNhbGxlZCB3aGVuIHRoZSBOZXh0LVVybCBvciB0aGUgYmFzZSB0cmVlIGNoYW5nZXMsIHNpbmNlIHRob3NlXG4gIC8vIG1heSBhZmZlY3QgdGhlIHJlc3VsdCBvZiBhIHByZWZldGNoIHRhc2suIEl0J3MgYWxzbyBjYWxsZWQgYWZ0ZXIgYVxuICAvLyBjYWNoZSBpbnZhbGlkYXRpb24uXG4gIGZvciAoY29uc3QgaW5zdGFuY2Ugb2YgcHJlZmV0Y2hhYmxlQW5kVmlzaWJsZSkge1xuICAgIGNvbnN0IHRhc2sgPSBpbnN0YW5jZS5wcmVmZXRjaFRhc2tcbiAgICBpZiAodGFzayAhPT0gbnVsbCAmJiAhaXNQcmVmZXRjaFRhc2tEaXJ0eSh0YXNrLCBuZXh0VXJsLCB0cmVlKSkge1xuICAgICAgLy8gVGhlIGNhY2hlIGhhcyBub3QgYmVlbiBpbnZhbGlkYXRlZCwgYW5kIG5vbmUgb2YgdGhlIGlucHV0cyBoYXZlXG4gICAgICAvLyBjaGFuZ2VkLiBCYWlsIG91dC5cbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIC8vIFNvbWV0aGluZyBjaGFuZ2VkLiBDYW5jZWwgdGhlIGV4aXN0aW5nIHByZWZldGNoIHRhc2sgYW5kIHNjaGVkdWxlIGFcbiAgICAvLyBuZXcgb25lLlxuICAgIGlmICh0YXNrICE9PSBudWxsKSB7XG4gICAgICBjYW5jZWxQcmVmZXRjaFRhc2sodGFzaylcbiAgICB9XG4gICAgY29uc3QgY2FjaGVLZXkgPSBjcmVhdGVDYWNoZUtleShpbnN0YW5jZS5wcmVmZXRjaEhyZWYsIG5leHRVcmwpXG4gICAgaW5zdGFuY2UucHJlZmV0Y2hUYXNrID0gc2NoZWR1bGVTZWdtZW50UHJlZmV0Y2hUYXNrKFxuICAgICAgY2FjaGVLZXksXG4gICAgICB0cmVlLFxuICAgICAgaW5zdGFuY2UuZmV0Y2hTdHJhdGVneSxcbiAgICAgIFByZWZldGNoUHJpb3JpdHkuRGVmYXVsdCxcbiAgICAgIG51bGxcbiAgICApXG4gIH1cbn1cblxuZnVuY3Rpb24gcHJlZmV0Y2hXaXRoT2xkQ2FjaGVJbXBsZW1lbnRhdGlvbihpbnN0YW5jZTogUHJlZmV0Y2hhYmxlSW5zdGFuY2UpIHtcbiAgLy8gVGhpcyBpcyB0aGUgcGF0aCB1c2VkIHdoZW4gdGhlIFNlZ21lbnQgQ2FjaGUgaXMgbm90IGVuYWJsZWQuXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3QgZG9QcmVmZXRjaCA9IGFzeW5jICgpID0+IHtcbiAgICAvLyBub3RlIHRoYXQgYGFwcFJvdXRlci5wcmVmZXRjaCgpYCBpcyBjdXJyZW50bHkgc3luYyxcbiAgICAvLyBzbyB3ZSBoYXZlIHRvIHdyYXAgdGhpcyBjYWxsIGluIGFuIGFzeW5jIGZ1bmN0aW9uIHRvIGJlIGFibGUgdG8gY2F0Y2goKSBlcnJvcnMgYmVsb3cuXG5cbiAgICBsZXQgcHJlZmV0Y2hLaW5kOiBQcmVmZXRjaEtpbmRcbiAgICBzd2l0Y2ggKGluc3RhbmNlLmZldGNoU3RyYXRlZ3kpIHtcbiAgICAgIGNhc2UgRmV0Y2hTdHJhdGVneS5QUFI6IHtcbiAgICAgICAgcHJlZmV0Y2hLaW5kID0gUHJlZmV0Y2hLaW5kLkFVVE9cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGNhc2UgRmV0Y2hTdHJhdGVneS5GdWxsOiB7XG4gICAgICAgIHByZWZldGNoS2luZCA9IFByZWZldGNoS2luZC5GVUxMXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBjYXNlIEZldGNoU3RyYXRlZ3kuUFBSUnVudGltZToge1xuICAgICAgICAvLyBXZSBjYW4gb25seSBnZXQgaGVyZSBpZiBDbGllbnQgU2VnbWVudCBDYWNoZSBpcyBvZmYsIGFuZCBpbiB0aGF0IGNhc2VcbiAgICAgICAgLy8gaXQgc2hvdWxkbid0IGJlIHBvc3NpYmxlIGZvciBhIGxpbmsgdG8gcmVxdWVzdCBhIHJ1bnRpbWUgcHJlZmV0Y2guXG4gICAgICAgIHRocm93IG5ldyBJbnZhcmlhbnRFcnJvcihcbiAgICAgICAgICAnRmV0Y2hTdHJhdGVneS5QUFJSdW50aW1lIHNob3VsZCBuZXZlciBiZSB1c2VkIHdoZW4gYGV4cGVyaW1lbnRhbC5jbGllbnRTZWdtZW50Q2FjaGVgIGlzIGRpc2FibGVkJ1xuICAgICAgICApXG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIGluc3RhbmNlLmZldGNoU3RyYXRlZ3kgc2F0aXNmaWVzIG5ldmVyXG4gICAgICAgIC8vIFVucmVhY2hhYmxlLCBidXQgb3RoZXJ3aXNlIHR5cGVzY3JpcHQgd2lsbCBjb25zaWRlciB0aGUgdmFyaWFibGUgdW5hc3NpZ25lZFxuICAgICAgICBwcmVmZXRjaEtpbmQgPSB1bmRlZmluZWQhXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluc3RhbmNlLnJvdXRlci5wcmVmZXRjaChpbnN0YW5jZS5wcmVmZXRjaEhyZWYsIHtcbiAgICAgIGtpbmQ6IHByZWZldGNoS2luZCxcbiAgICB9KVxuICB9XG5cbiAgLy8gUHJlZmV0Y2ggdGhlIHBhZ2UgaWYgYXNrZWQgKG9ubHkgaW4gdGhlIGNsaWVudClcbiAgLy8gV2UgbmVlZCB0byBoYW5kbGUgYSBwcmVmZXRjaCBlcnJvciBoZXJlIHNpbmNlIHdlIG1heSBiZVxuICAvLyBsb2FkaW5nIHdpdGggcHJpb3JpdHkgd2hpY2ggY2FuIHJlamVjdCBidXQgd2UgZG9uJ3RcbiAgLy8gd2FudCB0byBmb3JjZSBuYXZpZ2F0aW9uIHNpbmNlIHRoaXMgaXMgb25seSBhIHByZWZldGNoXG4gIGRvUHJlZmV0Y2goKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIHJldGhyb3cgdG8gc2hvdyBpbnZhbGlkIFVSTCBlcnJvcnNcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfSlcbn1cbiJdLCJuYW1lcyI6WyJJRExFX0xJTktfU1RBVFVTIiwiUEVORElOR19MSU5LX1NUQVRVUyIsIm1vdW50Rm9ybUluc3RhbmNlIiwibW91bnRMaW5rSW5zdGFuY2UiLCJvbkxpbmtWaXNpYmlsaXR5Q2hhbmdlZCIsIm9uTmF2aWdhdGlvbkludGVudCIsInBpbmdWaXNpYmxlTGlua3MiLCJzZXRMaW5rRm9yQ3VycmVudE5hdmlnYXRpb24iLCJ1bm1vdW50TGlua0ZvckN1cnJlbnROYXZpZ2F0aW9uIiwidW5tb3VudFByZWZldGNoYWJsZUluc3RhbmNlIiwibGlua0Zvck1vc3RSZWNlbnROYXZpZ2F0aW9uIiwicGVuZGluZyIsImxpbmsiLCJzdGFydFRyYW5zaXRpb24iLCJzZXRPcHRpbWlzdGljTGlua1N0YXR1cyIsInByZWZldGNoYWJsZSIsIldlYWtNYXAiLCJNYXAiLCJwcmVmZXRjaGFibGVBbmRWaXNpYmxlIiwiU2V0Iiwib2JzZXJ2ZXIiLCJJbnRlcnNlY3Rpb25PYnNlcnZlciIsImhhbmRsZUludGVyc2VjdCIsInJvb3RNYXJnaW4iLCJvYnNlcnZlVmlzaWJpbGl0eSIsImVsZW1lbnQiLCJpbnN0YW5jZSIsImV4aXN0aW5nSW5zdGFuY2UiLCJnZXQiLCJ1bmRlZmluZWQiLCJzZXQiLCJvYnNlcnZlIiwiY29lcmNlUHJlZmV0Y2hhYmxlVXJsIiwiaHJlZiIsImNyZWF0ZVByZWZldGNoVVJMIiwicmVwb3J0RXJyb3JGbiIsInJlcG9ydEVycm9yIiwiY29uc29sZSIsImVycm9yIiwicm91dGVyIiwiZmV0Y2hTdHJhdGVneSIsInByZWZldGNoRW5hYmxlZCIsInByZWZldGNoVVJMIiwiaXNWaXNpYmxlIiwicHJlZmV0Y2hUYXNrIiwicHJlZmV0Y2hIcmVmIiwiZGVsZXRlIiwiY2FuY2VsUHJlZmV0Y2hUYXNrIiwidW5vYnNlcnZlIiwiZW50cmllcyIsImVudHJ5IiwiaW50ZXJzZWN0aW9uUmF0aW8iLCJ0YXJnZXQiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJhZGQiLCJyZXNjaGVkdWxlTGlua1ByZWZldGNoIiwiUHJlZmV0Y2hQcmlvcml0eSIsIkRlZmF1bHQiLCJ1bnN0YWJsZV91cGdyYWRlVG9EeW5hbWljUHJlZmV0Y2giLCJfX05FWFRfRFlOQU1JQ19PTl9IT1ZFUiIsIkZldGNoU3RyYXRlZ3kiLCJGdWxsIiwiSW50ZW50IiwicHJpb3JpdHkiLCJleGlzdGluZ1ByZWZldGNoVGFzayIsIl9fTkVYVF9DTElFTlRfU0VHTUVOVF9DQUNIRSIsInByZWZldGNoV2l0aE9sZENhY2hlSW1wbGVtZW50YXRpb24iLCJhcHBSb3V0ZXJTdGF0ZSIsImdldEN1cnJlbnRBcHBSb3V0ZXJTdGF0ZSIsInRyZWVBdFRpbWVPZlByZWZldGNoIiwidHJlZSIsIm5leHRVcmwiLCJjYWNoZUtleSIsImNyZWF0ZUNhY2hlS2V5Iiwic2NoZWR1bGVTZWdtZW50UHJlZmV0Y2hUYXNrIiwicmVzY2hlZHVsZVByZWZldGNoVGFzayIsInRhc2siLCJpc1ByZWZldGNoVGFza0RpcnR5Iiwid2luZG93IiwiZG9QcmVmZXRjaCIsInByZWZldGNoS2luZCIsIlBQUiIsIlByZWZldGNoS2luZCIsIkFVVE8iLCJGVUxMIiwiUFBSUnVudGltZSIsIkludmFyaWFudEVycm9yIiwicHJlZmV0Y2giLCJraW5kIiwiY2F0Y2giLCJlcnIiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/links.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/router-reducer/create-initial-router-state.js":
/*!****************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/router-reducer/create-initial-router-state.js ***!
  \****************************************************************************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"createInitialRouterState\", ({\n    enumerable: true,\n    get: function() {\n        return createInitialRouterState;\n    }\n}));\nconst _createhreffromurl = __webpack_require__(/*! ./create-href-from-url */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\");\nconst _filllazyitemstillleafwithhead = __webpack_require__(/*! ./fill-lazy-items-till-leaf-with-head */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js\");\nconst _computechangedpath = __webpack_require__(/*! ./compute-changed-path */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/router-reducer/compute-changed-path.js\");\nconst _prefetchcacheutils = __webpack_require__(/*! ./prefetch-cache-utils */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js\");\nconst _routerreducertypes = __webpack_require__(/*! ./router-reducer-types */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nconst _refetchinactiveparallelsegments = __webpack_require__(/*! ./refetch-inactive-parallel-segments */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/router-reducer/refetch-inactive-parallel-segments.js\");\nconst _flightdatahelpers = __webpack_require__(/*! ../../flight-data-helpers */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/flight-data-helpers.js\");\nfunction createInitialRouterState(param) {\n    let { navigatedAt, initialFlightData, initialCanonicalUrlParts, initialParallelRoutes, location, couldBeIntercepted, postponed, prerendered } = param;\n    // When initialized on the server, the canonical URL is provided as an array of parts.\n    // This is to ensure that when the RSC payload streamed to the client, crawlers don't interpret it\n    // as a URL that should be crawled.\n    const initialCanonicalUrl = initialCanonicalUrlParts.join('/');\n    const normalizedFlightData = (0, _flightdatahelpers.getFlightDataPartsFromPath)(initialFlightData[0]);\n    const { tree: initialTree, seedData: initialSeedData, head: initialHead } = normalizedFlightData;\n    // For the SSR render, seed data should always be available (we only send back a `null` response\n    // in the case of a `loading` segment, pre-PPR.)\n    const rsc = initialSeedData == null ? void 0 : initialSeedData[1];\n    var _initialSeedData_;\n    const loading = (_initialSeedData_ = initialSeedData == null ? void 0 : initialSeedData[3]) != null ? _initialSeedData_ : null;\n    const cache = {\n        lazyData: null,\n        rsc,\n        prefetchRsc: null,\n        head: null,\n        prefetchHead: null,\n        // The cache gets seeded during the first render. `initialParallelRoutes` ensures the cache from the first render is there during the second render.\n        parallelRoutes: initialParallelRoutes,\n        loading,\n        navigatedAt\n    };\n    const canonicalUrl = // This is safe to do as canonicalUrl can't be rendered, it's only used to control the history updates in the useEffect further down in this file.\n    location ? (0, _createhreffromurl.createHrefFromUrl)(location) : initialCanonicalUrl;\n    (0, _refetchinactiveparallelsegments.addRefreshMarkerToActiveParallelSegments)(initialTree, canonicalUrl);\n    const prefetchCache = new Map();\n    // When the cache hasn't been seeded yet we fill the cache with the head.\n    if (initialParallelRoutes === null || initialParallelRoutes.size === 0) {\n        (0, _filllazyitemstillleafwithhead.fillLazyItemsTillLeafWithHead)(navigatedAt, cache, undefined, initialTree, initialSeedData, initialHead, undefined);\n    }\n    var _ref;\n    const initialState = {\n        tree: initialTree,\n        cache,\n        prefetchCache,\n        pushRef: {\n            pendingPush: false,\n            mpaNavigation: false,\n            // First render needs to preserve the previous window.history.state\n            // to avoid it being overwritten on navigation back/forward with MPA Navigation.\n            preserveCustomHistoryState: true\n        },\n        focusAndScrollRef: {\n            apply: false,\n            onlyHashChange: false,\n            hashFragment: null,\n            segmentPaths: []\n        },\n        canonicalUrl,\n        nextUrl: (_ref = (0, _computechangedpath.extractPathFromFlightRouterState)(initialTree) || (location == null ? void 0 : location.pathname)) != null ? _ref : null\n    };\n    if (false) {}\n    return initialState;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=create-initial-router-state.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE1LjUuMTJfcmVhY3QtZG9tQDE5LjIuNF9yZWFjdEAxOS4yLjRfX3JlYWN0QDE5LjIuNC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2NyZWF0ZS1pbml0aWFsLXJvdXRlci1zdGF0ZS5qcyIsIm1hcHBpbmdzIjoiOzs7OzREQXlCZ0JBOzs7ZUFBQUE7OzsrQ0F0QmtCOzJEQUNZO2dEQUNHO2dEQUkxQztnREFDK0M7NkRBQ0c7K0NBQ2Q7QUFhcEMsU0FBU0EseUJBQXlCLEtBU1Y7SUFUVSxNQUN2Q0MsV0FBVyxFQUNYQyxpQkFBaUIsRUFDakJDLHdCQUF3QixFQUN4QkMscUJBQXFCLEVBQ3JCQyxRQUFRLEVBQ1JDLGtCQUFrQixFQUNsQkMsU0FBUyxFQUNUQyxXQUFXLEVBQ2tCLEdBVFU7SUFVdkMsc0ZBQXNGO0lBQ3RGLGtHQUFrRztJQUNsRyxtQ0FBbUM7SUFDbkMsTUFBTUMsc0JBQXNCTix5QkFBeUJPLElBQUksQ0FBQztJQUUxRCxNQUFNQyx1QkFBdUJDLENBQUFBLEdBQUFBLG1CQUFBQSwwQkFBQUEsRUFBMkJWLGlCQUFpQixDQUFDLEVBQUU7SUFDNUUsTUFBTSxFQUNKVyxNQUFNQyxXQUFXLEVBQ2pCQyxVQUFVQyxlQUFlLEVBQ3pCQyxNQUFNQyxXQUFXLEVBQ2xCLEdBQUdQO0lBQ0osZ0dBQWdHO0lBQ2hHLGdEQUFnRDtJQUNoRCxNQUFNUSxNQUFNSCxtQkFBQUEsT0FBQUEsS0FBQUEsSUFBQUEsZUFBaUIsQ0FBQyxFQUFFO1FBQ2hCQTtJQUFoQixNQUFNSSxVQUFVSixDQUFBQSxvQkFBQUEsbUJBQUFBLE9BQUFBLEtBQUFBLElBQUFBLGVBQWlCLENBQUMsT0FBRSxPQUFwQkEsb0JBQXdCO0lBRXhDLE1BQU1LLFFBQW1CO1FBQ3ZCQyxVQUFVO1FBQ1ZIO1FBQ0FJLGFBQWE7UUFDYk4sTUFBTTtRQUNOTyxjQUFjO1FBQ2Qsb0pBQW9KO1FBQ3BKQyxnQkFBZ0JyQjtRQUNoQmdCO1FBQ0FuQjtJQUNGO0lBRUEsTUFBTXlCLGVBQ0osNkVBQTZFLHFFQUNxRTtJQUNsSnJCLFdBRUlzQixDQUFBQSxHQUFBQSxtQkFBQUEsaUJBQWlCLEVBQUN0QixZQUNsQkk7SUFFTm1CLENBQUFBLEdBQUFBLGlDQUFBQSx3Q0FBQUEsRUFBeUNkLGFBQWFZO0lBRXRELE1BQU1HLGdCQUFnQixJQUFJQztJQUUxQix5RUFBeUU7SUFDekUsSUFBSTFCLDBCQUEwQixRQUFRQSxzQkFBc0IyQixJQUFJLEtBQUssR0FBRztRQUN0RUMsQ0FBQUEsR0FBQUEsK0JBQUFBLDZCQUFBQSxFQUNFL0IsYUFDQW9CLE9BQ0FZLFdBQ0FuQixhQUNBRSxpQkFDQUUsYUFDQWU7SUFFSjtRQXFCSTtJQW5CSixNQUFNRSxlQUFlO1FBQ25CdEIsTUFBTUM7UUFDTk87UUFDQVE7UUFDQU8sU0FBUztZQUNQQyxhQUFhO1lBQ2JDLGVBQWU7WUFDZixtRUFBbUU7WUFDbkUsZ0ZBQWdGO1lBQ2hGQyw0QkFBNEI7UUFDOUI7UUFDQUMsbUJBQW1CO1lBQ2pCQyxPQUFPO1lBQ1BDLGdCQUFnQjtZQUNoQkMsY0FBYztZQUNkQyxjQUFjLEVBQUU7UUFDbEI7UUFDQWxCO1FBQ0FtQixTQUVFLENBQUNYLE9BQUFBLENBQUFBLEdBQUFBLG9CQUFBQSxnQ0FBZ0MsRUFBQ3BCLGlCQUFnQlQsWUFBQUEsT0FBQUEsS0FBQUEsSUFBQUEsU0FBVXlDLFFBQUFBLENBQVEsWUFBbkVaLE9BQ0Q7SUFDSjtJQUVBLElBQUlhLEtBQWtEMUMsRUFBRSxFQXVDdkQ7SUFFRCxPQUFPOEI7QUFDVCIsInNvdXJjZXMiOlsiL1VzZXJzL3NyYy9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9jcmVhdGUtaW5pdGlhbC1yb3V0ZXItc3RhdGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBDYWNoZU5vZGUgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB0eXBlIHsgRmxpZ2h0RGF0YVBhdGggfSBmcm9tICcuLi8uLi8uLi9zZXJ2ZXIvYXBwLXJlbmRlci90eXBlcydcblxuaW1wb3J0IHsgY3JlYXRlSHJlZkZyb21VcmwgfSBmcm9tICcuL2NyZWF0ZS1ocmVmLWZyb20tdXJsJ1xuaW1wb3J0IHsgZmlsbExhenlJdGVtc1RpbGxMZWFmV2l0aEhlYWQgfSBmcm9tICcuL2ZpbGwtbGF6eS1pdGVtcy10aWxsLWxlYWYtd2l0aC1oZWFkJ1xuaW1wb3J0IHsgZXh0cmFjdFBhdGhGcm9tRmxpZ2h0Um91dGVyU3RhdGUgfSBmcm9tICcuL2NvbXB1dGUtY2hhbmdlZC1wYXRoJ1xuaW1wb3J0IHtcbiAgY3JlYXRlU2VlZGVkUHJlZmV0Y2hDYWNoZUVudHJ5LFxuICBTVEFUSUNfU1RBTEVUSU1FX01TLFxufSBmcm9tICcuL3ByZWZldGNoLWNhY2hlLXV0aWxzJ1xuaW1wb3J0IHsgUHJlZmV0Y2hLaW5kLCB0eXBlIFByZWZldGNoQ2FjaGVFbnRyeSB9IGZyb20gJy4vcm91dGVyLXJlZHVjZXItdHlwZXMnXG5pbXBvcnQgeyBhZGRSZWZyZXNoTWFya2VyVG9BY3RpdmVQYXJhbGxlbFNlZ21lbnRzIH0gZnJvbSAnLi9yZWZldGNoLWluYWN0aXZlLXBhcmFsbGVsLXNlZ21lbnRzJ1xuaW1wb3J0IHsgZ2V0RmxpZ2h0RGF0YVBhcnRzRnJvbVBhdGggfSBmcm9tICcuLi8uLi9mbGlnaHQtZGF0YS1oZWxwZXJzJ1xuXG5leHBvcnQgaW50ZXJmYWNlIEluaXRpYWxSb3V0ZXJTdGF0ZVBhcmFtZXRlcnMge1xuICBuYXZpZ2F0ZWRBdDogbnVtYmVyXG4gIGluaXRpYWxDYW5vbmljYWxVcmxQYXJ0czogc3RyaW5nW11cbiAgaW5pdGlhbFBhcmFsbGVsUm91dGVzOiBDYWNoZU5vZGVbJ3BhcmFsbGVsUm91dGVzJ11cbiAgaW5pdGlhbEZsaWdodERhdGE6IEZsaWdodERhdGFQYXRoW11cbiAgbG9jYXRpb246IExvY2F0aW9uIHwgbnVsbFxuICBjb3VsZEJlSW50ZXJjZXB0ZWQ6IGJvb2xlYW5cbiAgcG9zdHBvbmVkOiBib29sZWFuXG4gIHByZXJlbmRlcmVkOiBib29sZWFuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVJbml0aWFsUm91dGVyU3RhdGUoe1xuICBuYXZpZ2F0ZWRBdCxcbiAgaW5pdGlhbEZsaWdodERhdGEsXG4gIGluaXRpYWxDYW5vbmljYWxVcmxQYXJ0cyxcbiAgaW5pdGlhbFBhcmFsbGVsUm91dGVzLFxuICBsb2NhdGlvbixcbiAgY291bGRCZUludGVyY2VwdGVkLFxuICBwb3N0cG9uZWQsXG4gIHByZXJlbmRlcmVkLFxufTogSW5pdGlhbFJvdXRlclN0YXRlUGFyYW1ldGVycykge1xuICAvLyBXaGVuIGluaXRpYWxpemVkIG9uIHRoZSBzZXJ2ZXIsIHRoZSBjYW5vbmljYWwgVVJMIGlzIHByb3ZpZGVkIGFzIGFuIGFycmF5IG9mIHBhcnRzLlxuICAvLyBUaGlzIGlzIHRvIGVuc3VyZSB0aGF0IHdoZW4gdGhlIFJTQyBwYXlsb2FkIHN0cmVhbWVkIHRvIHRoZSBjbGllbnQsIGNyYXdsZXJzIGRvbid0IGludGVycHJldCBpdFxuICAvLyBhcyBhIFVSTCB0aGF0IHNob3VsZCBiZSBjcmF3bGVkLlxuICBjb25zdCBpbml0aWFsQ2Fub25pY2FsVXJsID0gaW5pdGlhbENhbm9uaWNhbFVybFBhcnRzLmpvaW4oJy8nKVxuXG4gIGNvbnN0IG5vcm1hbGl6ZWRGbGlnaHREYXRhID0gZ2V0RmxpZ2h0RGF0YVBhcnRzRnJvbVBhdGgoaW5pdGlhbEZsaWdodERhdGFbMF0pXG4gIGNvbnN0IHtcbiAgICB0cmVlOiBpbml0aWFsVHJlZSxcbiAgICBzZWVkRGF0YTogaW5pdGlhbFNlZWREYXRhLFxuICAgIGhlYWQ6IGluaXRpYWxIZWFkLFxuICB9ID0gbm9ybWFsaXplZEZsaWdodERhdGFcbiAgLy8gRm9yIHRoZSBTU1IgcmVuZGVyLCBzZWVkIGRhdGEgc2hvdWxkIGFsd2F5cyBiZSBhdmFpbGFibGUgKHdlIG9ubHkgc2VuZCBiYWNrIGEgYG51bGxgIHJlc3BvbnNlXG4gIC8vIGluIHRoZSBjYXNlIG9mIGEgYGxvYWRpbmdgIHNlZ21lbnQsIHByZS1QUFIuKVxuICBjb25zdCByc2MgPSBpbml0aWFsU2VlZERhdGE/LlsxXVxuICBjb25zdCBsb2FkaW5nID0gaW5pdGlhbFNlZWREYXRhPy5bM10gPz8gbnVsbFxuXG4gIGNvbnN0IGNhY2hlOiBDYWNoZU5vZGUgPSB7XG4gICAgbGF6eURhdGE6IG51bGwsXG4gICAgcnNjLFxuICAgIHByZWZldGNoUnNjOiBudWxsLFxuICAgIGhlYWQ6IG51bGwsXG4gICAgcHJlZmV0Y2hIZWFkOiBudWxsLFxuICAgIC8vIFRoZSBjYWNoZSBnZXRzIHNlZWRlZCBkdXJpbmcgdGhlIGZpcnN0IHJlbmRlci4gYGluaXRpYWxQYXJhbGxlbFJvdXRlc2AgZW5zdXJlcyB0aGUgY2FjaGUgZnJvbSB0aGUgZmlyc3QgcmVuZGVyIGlzIHRoZXJlIGR1cmluZyB0aGUgc2Vjb25kIHJlbmRlci5cbiAgICBwYXJhbGxlbFJvdXRlczogaW5pdGlhbFBhcmFsbGVsUm91dGVzLFxuICAgIGxvYWRpbmcsXG4gICAgbmF2aWdhdGVkQXQsXG4gIH1cblxuICBjb25zdCBjYW5vbmljYWxVcmwgPVxuICAgIC8vIGxvY2F0aW9uLmhyZWYgaXMgcmVhZCBhcyB0aGUgaW5pdGlhbCB2YWx1ZSBmb3IgY2Fub25pY2FsVXJsIGluIHRoZSBicm93c2VyXG4gICAgLy8gVGhpcyBpcyBzYWZlIHRvIGRvIGFzIGNhbm9uaWNhbFVybCBjYW4ndCBiZSByZW5kZXJlZCwgaXQncyBvbmx5IHVzZWQgdG8gY29udHJvbCB0aGUgaGlzdG9yeSB1cGRhdGVzIGluIHRoZSB1c2VFZmZlY3QgZnVydGhlciBkb3duIGluIHRoaXMgZmlsZS5cbiAgICBsb2NhdGlvblxuICAgICAgPyAvLyB3aW5kb3cubG9jYXRpb24gZG9lcyBub3QgaGF2ZSB0aGUgc2FtZSB0eXBlIGFzIFVSTCBidXQgaGFzIGFsbCB0aGUgZmllbGRzIGNyZWF0ZUhyZWZGcm9tVXJsIG5lZWRzLlxuICAgICAgICBjcmVhdGVIcmVmRnJvbVVybChsb2NhdGlvbilcbiAgICAgIDogaW5pdGlhbENhbm9uaWNhbFVybFxuXG4gIGFkZFJlZnJlc2hNYXJrZXJUb0FjdGl2ZVBhcmFsbGVsU2VnbWVudHMoaW5pdGlhbFRyZWUsIGNhbm9uaWNhbFVybClcblxuICBjb25zdCBwcmVmZXRjaENhY2hlID0gbmV3IE1hcDxzdHJpbmcsIFByZWZldGNoQ2FjaGVFbnRyeT4oKVxuXG4gIC8vIFdoZW4gdGhlIGNhY2hlIGhhc24ndCBiZWVuIHNlZWRlZCB5ZXQgd2UgZmlsbCB0aGUgY2FjaGUgd2l0aCB0aGUgaGVhZC5cbiAgaWYgKGluaXRpYWxQYXJhbGxlbFJvdXRlcyA9PT0gbnVsbCB8fCBpbml0aWFsUGFyYWxsZWxSb3V0ZXMuc2l6ZSA9PT0gMCkge1xuICAgIGZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkKFxuICAgICAgbmF2aWdhdGVkQXQsXG4gICAgICBjYWNoZSxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIGluaXRpYWxUcmVlLFxuICAgICAgaW5pdGlhbFNlZWREYXRhLFxuICAgICAgaW5pdGlhbEhlYWQsXG4gICAgICB1bmRlZmluZWRcbiAgICApXG4gIH1cblxuICBjb25zdCBpbml0aWFsU3RhdGUgPSB7XG4gICAgdHJlZTogaW5pdGlhbFRyZWUsXG4gICAgY2FjaGUsXG4gICAgcHJlZmV0Y2hDYWNoZSxcbiAgICBwdXNoUmVmOiB7XG4gICAgICBwZW5kaW5nUHVzaDogZmFsc2UsXG4gICAgICBtcGFOYXZpZ2F0aW9uOiBmYWxzZSxcbiAgICAgIC8vIEZpcnN0IHJlbmRlciBuZWVkcyB0byBwcmVzZXJ2ZSB0aGUgcHJldmlvdXMgd2luZG93Lmhpc3Rvcnkuc3RhdGVcbiAgICAgIC8vIHRvIGF2b2lkIGl0IGJlaW5nIG92ZXJ3cml0dGVuIG9uIG5hdmlnYXRpb24gYmFjay9mb3J3YXJkIHdpdGggTVBBIE5hdmlnYXRpb24uXG4gICAgICBwcmVzZXJ2ZUN1c3RvbUhpc3RvcnlTdGF0ZTogdHJ1ZSxcbiAgICB9LFxuICAgIGZvY3VzQW5kU2Nyb2xsUmVmOiB7XG4gICAgICBhcHBseTogZmFsc2UsXG4gICAgICBvbmx5SGFzaENoYW5nZTogZmFsc2UsXG4gICAgICBoYXNoRnJhZ21lbnQ6IG51bGwsXG4gICAgICBzZWdtZW50UGF0aHM6IFtdLFxuICAgIH0sXG4gICAgY2Fub25pY2FsVXJsLFxuICAgIG5leHRVcmw6XG4gICAgICAvLyB0aGUgfHwgb3BlcmF0b3IgaXMgaW50ZW50aW9uYWwsIHRoZSBwYXRobmFtZSBjYW4gYmUgYW4gZW1wdHkgc3RyaW5nXG4gICAgICAoZXh0cmFjdFBhdGhGcm9tRmxpZ2h0Um91dGVyU3RhdGUoaW5pdGlhbFRyZWUpIHx8IGxvY2F0aW9uPy5wYXRobmFtZSkgPz9cbiAgICAgIG51bGwsXG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdkZXZlbG9wbWVudCcgJiYgbG9jYXRpb24pIHtcbiAgICAvLyBTZWVkIHRoZSBwcmVmZXRjaCBjYWNoZSB3aXRoIHRoaXMgcGFnZSdzIGRhdGEuXG4gICAgLy8gVGhpcyBpcyB0byBwcmV2ZW50IG5lZWRsZXNzbHkgcmUtcHJlZmV0Y2hpbmcgYSBwYWdlIHRoYXQgaXMgYWxyZWFkeSByZXVzYWJsZSxcbiAgICAvLyBhbmQgd2lsbCBhdm9pZCB0cmlnZ2VyaW5nIGEgbG9hZGluZyBzdGF0ZS9kYXRhIGZldGNoIHN0YWxsIHdoZW4gbmF2aWdhdGluZyBiYWNrIHRvIHRoZSBwYWdlLlxuICAgIC8vIFdlIGRvbid0IGN1cnJlbnRseSBkbyB0aGlzIGluIGRldmVsb3BtZW50IGJlY2F1c2UgbGlua3MgYXJlbid0IHByZWZldGNoZWQgaW4gZGV2ZWxvcG1lbnRcbiAgICAvLyBzbyBoYXZpbmcgYSBtaXNtYXRjaCBiZXR3ZWVuIHByZWZldGNoL25vIHByZWZldGNoIHByb3ZpZGVzIGluY29uc2lzdGVudCBiZWhhdmlvciBiYXNlZCBvbiB3aGljaCBwYWdlXG4gICAgLy8gd2FzIGxvYWRlZCBmaXJzdC5cbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKFxuICAgICAgYCR7bG9jYXRpb24ucGF0aG5hbWV9JHtsb2NhdGlvbi5zZWFyY2h9YCxcbiAgICAgIGxvY2F0aW9uLm9yaWdpblxuICAgIClcblxuICAgIGNyZWF0ZVNlZWRlZFByZWZldGNoQ2FjaGVFbnRyeSh7XG4gICAgICB1cmwsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGZsaWdodERhdGE6IFtub3JtYWxpemVkRmxpZ2h0RGF0YV0sXG4gICAgICAgIGNhbm9uaWNhbFVybDogdW5kZWZpbmVkLFxuICAgICAgICBjb3VsZEJlSW50ZXJjZXB0ZWQ6ICEhY291bGRCZUludGVyY2VwdGVkLFxuICAgICAgICBwcmVyZW5kZXJlZCxcbiAgICAgICAgcG9zdHBvbmVkLFxuICAgICAgICAvLyBUT0RPOiBUaGUgaW5pdGlhbCBSU0MgcGF5bG9hZCBpbmNsdWRlcyBib3RoIHN0YXRpYyBhbmQgZHluYW1pYyBkYXRhXG4gICAgICAgIC8vIGluIHRoZSBzYW1lIHJlc3BvbnNlLCBldmVuIGlmIFBQUiBpcyBlbmFibGVkLiBTbyBpZiB0aGVyZSdzIGFueVxuICAgICAgICAvLyBkeW5hbWljIGRhdGEgYXQgYWxsLCB3ZSBjYW4ndCBzZXQgYSBzdGFsZSB0aW1lLiBJbiB0aGUgZnV0dXJlIHdlIG1heVxuICAgICAgICAvLyBhZGQgYSB3YXkgdG8gc3BsaXQgYSBzaW5nbGUgRmxpZ2h0IHN0cmVhbSBpbnRvIHN0YXRpYyBhbmQgZHluYW1pY1xuICAgICAgICAvLyBwYXJ0cy4gQnV0IGluIHRoZSBtZWFudGltZSB3ZSBzaG91bGQgYXQgbGVhc3QgbWFrZSB0aGlzIHdvcmsgZm9yXG4gICAgICAgIC8vIGZ1bGx5IHN0YXRpYyBwYWdlcy5cbiAgICAgICAgc3RhbGVUaW1lOlxuICAgICAgICAgIC8vIEluIHRoZSBvbGQgcm91dGVyLCB0aGVyZSB3YXMgb25seSBhIHNpbmdsZSBjb25maWd1cmFibGUgc3RhbGVUaW1lIChleHBlcmltZW50YWwuc3RhbGVUaW1lcylcbiAgICAgICAgICAvLyBBcyBhbiBhYnVuZGFuY2Ugb2YgY2F1dGlvbiwgdGhpcyB3aWxsIG9ubHkgc2V0IHRoZSBpbml0aWFsIHN0YWxlVGltZSB0byB0aGUgY29uZmlndXJlZCB2YWx1ZVxuICAgICAgICAgIC8vIGlmIHdlJ3JlIG5vdCBsZXZlcmFnaW5nIHRoZSBzZWdtZW50IGNhY2hlLCB3aGljaCBoYXMgaXRzIG93biBwcmVmZXRjaGluZyBzZW1hbnRpY3MuXG4gICAgICAgICAgcHJlcmVuZGVyZWQgJiYgIXByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfU0VHTUVOVF9DQUNIRVxuICAgICAgICAgICAgPyBTVEFUSUNfU1RBTEVUSU1FX01TXG4gICAgICAgICAgICA6IC0xLFxuICAgICAgfSxcbiAgICAgIHRyZWU6IGluaXRpYWxTdGF0ZS50cmVlLFxuICAgICAgcHJlZmV0Y2hDYWNoZTogaW5pdGlhbFN0YXRlLnByZWZldGNoQ2FjaGUsXG4gICAgICBuZXh0VXJsOiBpbml0aWFsU3RhdGUubmV4dFVybCxcbiAgICAgIGtpbmQ6IHByZXJlbmRlcmVkID8gUHJlZmV0Y2hLaW5kLkZVTEwgOiBQcmVmZXRjaEtpbmQuQVVUTyxcbiAgICB9KVxuICB9XG5cbiAgcmV0dXJuIGluaXRpYWxTdGF0ZVxufVxuIl0sIm5hbWVzIjpbImNyZWF0ZUluaXRpYWxSb3V0ZXJTdGF0ZSIsIm5hdmlnYXRlZEF0IiwiaW5pdGlhbEZsaWdodERhdGEiLCJpbml0aWFsQ2Fub25pY2FsVXJsUGFydHMiLCJpbml0aWFsUGFyYWxsZWxSb3V0ZXMiLCJsb2NhdGlvbiIsImNvdWxkQmVJbnRlcmNlcHRlZCIsInBvc3Rwb25lZCIsInByZXJlbmRlcmVkIiwiaW5pdGlhbENhbm9uaWNhbFVybCIsImpvaW4iLCJub3JtYWxpemVkRmxpZ2h0RGF0YSIsImdldEZsaWdodERhdGFQYXJ0c0Zyb21QYXRoIiwidHJlZSIsImluaXRpYWxUcmVlIiwic2VlZERhdGEiLCJpbml0aWFsU2VlZERhdGEiLCJoZWFkIiwiaW5pdGlhbEhlYWQiLCJyc2MiLCJsb2FkaW5nIiwiY2FjaGUiLCJsYXp5RGF0YSIsInByZWZldGNoUnNjIiwicHJlZmV0Y2hIZWFkIiwicGFyYWxsZWxSb3V0ZXMiLCJjYW5vbmljYWxVcmwiLCJjcmVhdGVIcmVmRnJvbVVybCIsImFkZFJlZnJlc2hNYXJrZXJUb0FjdGl2ZVBhcmFsbGVsU2VnbWVudHMiLCJwcmVmZXRjaENhY2hlIiwiTWFwIiwic2l6ZSIsImZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkIiwidW5kZWZpbmVkIiwiZXh0cmFjdFBhdGhGcm9tRmxpZ2h0Um91dGVyU3RhdGUiLCJpbml0aWFsU3RhdGUiLCJwdXNoUmVmIiwicGVuZGluZ1B1c2giLCJtcGFOYXZpZ2F0aW9uIiwicHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGUiLCJmb2N1c0FuZFNjcm9sbFJlZiIsImFwcGx5Iiwib25seUhhc2hDaGFuZ2UiLCJoYXNoRnJhZ21lbnQiLCJzZWdtZW50UGF0aHMiLCJuZXh0VXJsIiwicGF0aG5hbWUiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJ1cmwiLCJVUkwiLCJzZWFyY2giLCJvcmlnaW4iLCJjcmVhdGVTZWVkZWRQcmVmZXRjaENhY2hlRW50cnkiLCJkYXRhIiwiZmxpZ2h0RGF0YSIsInN0YWxlVGltZSIsIl9fTkVYVF9DTElFTlRfU0VHTUVOVF9DQUNIRSIsIlNUQVRJQ19TVEFMRVRJTUVfTVMiLCJraW5kIiwiUHJlZmV0Y2hLaW5kIiwiRlVMTCIsIkFVVE8iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/router-reducer/create-initial-router-state.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/router-reducer/fetch-server-response.js":
/*!**********************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/router-reducer/fetch-server-response.js ***!
  \**********************************************************************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createFetch: function() {\n        return createFetch;\n    },\n    createFromNextReadableStream: function() {\n        return createFromNextReadableStream;\n    },\n    fetchServerResponse: function() {\n        return fetchServerResponse;\n    }\n});\nconst _client = __webpack_require__(/*! react-server-dom-webpack/client */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/compiled/react-server-dom-webpack/client.browser.js\");\nconst _approuterheaders = __webpack_require__(/*! ../app-router-headers */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/app-router-headers.js\");\nconst _appcallserver = __webpack_require__(/*! ../../app-call-server */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/app-call-server.js\");\nconst _appfindsourcemapurl = __webpack_require__(/*! ../../app-find-source-map-url */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/app-find-source-map-url.js\");\nconst _routerreducertypes = __webpack_require__(/*! ./router-reducer-types */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nconst _flightdatahelpers = __webpack_require__(/*! ../../flight-data-helpers */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/flight-data-helpers.js\");\nconst _appbuildid = __webpack_require__(/*! ../../app-build-id */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/app-build-id.js\");\nconst _setcachebustingsearchparam = __webpack_require__(/*! ./set-cache-busting-search-param */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/router-reducer/set-cache-busting-search-param.js\");\nconst _routeparams = __webpack_require__(/*! ../../route-params */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/route-params.js\");\nconst createFromReadableStream = _client.createFromReadableStream;\nfunction doMpaNavigation(url) {\n    return {\n        flightData: (0, _routeparams.urlToUrlWithoutFlightMarker)(new URL(url, location.origin)).toString(),\n        canonicalUrl: undefined,\n        couldBeIntercepted: false,\n        prerendered: false,\n        postponed: false,\n        staleTime: -1\n    };\n}\nlet abortController = new AbortController();\nif (true) {\n    // Abort any in-flight requests when the page is unloaded, e.g. due to\n    // reloading the page or performing hard navigations. This allows us to ignore\n    // what would otherwise be a thrown TypeError when the browser cancels the\n    // requests.\n    window.addEventListener('pagehide', ()=>{\n        abortController.abort();\n    });\n    // Use a fresh AbortController instance on pageshow, e.g. when navigating back\n    // and the JavaScript execution context is restored by the browser.\n    window.addEventListener('pageshow', ()=>{\n        abortController = new AbortController();\n    });\n}\nasync function fetchServerResponse(url, options) {\n    const { flightRouterState, nextUrl, prefetchKind } = options;\n    const headers = {\n        // Enable flight response\n        [_approuterheaders.RSC_HEADER]: '1',\n        // Provide the current router state\n        [_approuterheaders.NEXT_ROUTER_STATE_TREE_HEADER]: (0, _flightdatahelpers.prepareFlightRouterStateForRequest)(flightRouterState, options.isHmrRefresh)\n    };\n    /**\n   * Three cases:\n   * - `prefetchKind` is `undefined`, it means it's a normal navigation, so we want to prefetch the page data fully\n   * - `prefetchKind` is `full` - we want to prefetch the whole page so same as above\n   * - `prefetchKind` is `auto` - if the page is dynamic, prefetch the page data partially, if static prefetch the page data fully\n   */ if (prefetchKind === _routerreducertypes.PrefetchKind.AUTO) {\n        headers[_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER] = '1';\n    }\n    if ( true && options.isHmrRefresh) {\n        headers[_approuterheaders.NEXT_HMR_REFRESH_HEADER] = '1';\n    }\n    if (nextUrl) {\n        headers[_approuterheaders.NEXT_URL] = nextUrl;\n    }\n    try {\n        var _res_headers_get;\n        // When creating a \"temporary\" prefetch (the \"on-demand\" prefetch that gets created on navigation, if one doesn't exist)\n        // we send the request with a \"high\" priority as it's in response to a user interaction that could be blocking a transition.\n        // Otherwise, all other prefetches are sent with a \"low\" priority.\n        // We use \"auto\" for in all other cases to match the existing default, as this function is shared outside of prefetching.\n        const fetchPriority = prefetchKind ? prefetchKind === _routerreducertypes.PrefetchKind.TEMPORARY ? 'high' : 'low' : 'auto';\n        if (false) {}\n        const res = await createFetch(url, headers, fetchPriority, abortController.signal);\n        const responseUrl = (0, _routeparams.urlToUrlWithoutFlightMarker)(new URL(res.url));\n        const canonicalUrl = res.redirected ? responseUrl : undefined;\n        const contentType = res.headers.get('content-type') || '';\n        const interception = !!((_res_headers_get = res.headers.get('vary')) == null ? void 0 : _res_headers_get.includes(_approuterheaders.NEXT_URL));\n        const postponed = !!res.headers.get(_approuterheaders.NEXT_DID_POSTPONE_HEADER);\n        const staleTimeHeaderSeconds = res.headers.get(_approuterheaders.NEXT_ROUTER_STALE_TIME_HEADER);\n        const staleTime = staleTimeHeaderSeconds !== null ? parseInt(staleTimeHeaderSeconds, 10) * 1000 : -1;\n        let isFlightResponse = contentType.startsWith(_approuterheaders.RSC_CONTENT_TYPE_HEADER);\n        if (false) {}\n        // If fetch returns something different than flight response handle it like a mpa navigation\n        // If the fetch was not 200, we also handle it like a mpa navigation\n        if (!isFlightResponse || !res.ok || !res.body) {\n            // in case the original URL came with a hash, preserve it before redirecting to the new URL\n            if (url.hash) {\n                responseUrl.hash = url.hash;\n            }\n            return doMpaNavigation(responseUrl.toString());\n        }\n        // We may navigate to a page that requires a different Webpack runtime.\n        // In prod, every page will have the same Webpack runtime.\n        // In dev, the Webpack runtime is minimal for each page.\n        // We need to ensure the Webpack runtime is updated before executing client-side JS of the new page.\n        if (true) {\n            await (__webpack_require__(/*! ../../dev/hot-reloader/app/hot-reloader-app */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/dev/hot-reloader/app/hot-reloader-app.js\").waitForWebpackRuntimeHotUpdate)();\n        }\n        // Handle the `fetch` readable stream that can be unwrapped by `React.use`.\n        const flightStream = postponed ? createUnclosingPrefetchStream(res.body) : res.body;\n        const response = await createFromNextReadableStream(flightStream);\n        if ((0, _appbuildid.getAppBuildId)() !== response.b) {\n            return doMpaNavigation(res.url);\n        }\n        return {\n            flightData: (0, _flightdatahelpers.normalizeFlightData)(response.f),\n            canonicalUrl: canonicalUrl,\n            couldBeIntercepted: interception,\n            prerendered: response.S,\n            postponed,\n            staleTime\n        };\n    } catch (err) {\n        if (!abortController.signal.aborted) {\n            console.error(\"Failed to fetch RSC payload for \" + url + \". Falling back to browser navigation.\", err);\n        }\n        // If fetch fails handle it like a mpa navigation\n        // TODO-APP: Add a test for the case where a CORS request fails, e.g. external url redirect coming from the response.\n        // See https://github.com/vercel/next.js/issues/43605#issuecomment-1451617521 for a reproduction.\n        return {\n            flightData: url.toString(),\n            canonicalUrl: undefined,\n            couldBeIntercepted: false,\n            prerendered: false,\n            postponed: false,\n            staleTime: -1\n        };\n    }\n}\nasync function createFetch(url, headers, fetchPriority, signal) {\n    // TODO: In output: \"export\" mode, the headers do nothing. Omit them (and the\n    // cache busting search param) from the request so they're\n    // maximally cacheable.\n    if (false) {}\n    if (false) {}\n    const fetchOptions = {\n        // Backwards compat for older browsers. `same-origin` is the default in modern browsers.\n        credentials: 'same-origin',\n        headers,\n        priority: fetchPriority || undefined,\n        signal\n    };\n    // `fetchUrl` is slightly different from `url` because we add a cache-busting\n    // search param to it. This should not leak outside of this function, so we\n    // track them separately.\n    let fetchUrl = new URL(url);\n    (0, _setcachebustingsearchparam.setCacheBustingSearchParam)(fetchUrl, headers);\n    let browserResponse = await fetch(fetchUrl, fetchOptions);\n    // If the server responds with a redirect (e.g. 307), and the redirected\n    // location does not contain the cache busting search param set in the\n    // original request, the response is likely invalid  when following the\n    // redirect, the browser forwards the request headers, but since the cache\n    // busting search param is missing, the server will reject the request due to\n    // a mismatch.\n    //\n    // Ideally, we would be able to intercept the redirect response and perform it\n    // manually, instead of letting the browser automatically follow it, but this\n    // is not allowed by the fetch API.\n    //\n    // So instead, we must \"replay\" the redirect by fetching the new location\n    // again, but this time we'll append the cache busting search param to prevent\n    // a mismatch.\n    //\n    // TODO: We can optimize Next.js's built-in middleware APIs by returning a\n    // custom status code, to prevent the browser from automatically following it.\n    //\n    // This does not affect Server Action-based redirects; those are encoded\n    // differently, as part of the Flight body. It only affects redirects that\n    // occur in a middleware or a third-party proxy.\n    let redirected = browserResponse.redirected;\n    if (false) {}\n    // Remove the cache busting search param from the response URL, to prevent it\n    // from leaking outside of this function.\n    const responseUrl = new URL(browserResponse.url, fetchUrl);\n    responseUrl.searchParams.delete(_approuterheaders.NEXT_RSC_UNION_QUERY);\n    const rscResponse = {\n        url: responseUrl.href,\n        // This is true if any redirects occurred, either automatically by the\n        // browser, or manually by us. So it's different from\n        // `browserResponse.redirected`, which only tells us whether the browser\n        // followed a redirect, and only for the last response in the chain.\n        redirected,\n        // These can be copied from the last browser response we received. We\n        // intentionally only expose the subset of fields that are actually used\n        // elsewhere in the codebase.\n        ok: browserResponse.ok,\n        headers: browserResponse.headers,\n        body: browserResponse.body,\n        status: browserResponse.status\n    };\n    return rscResponse;\n}\nfunction createFromNextReadableStream(flightStream) {\n    return createFromReadableStream(flightStream, {\n        callServer: _appcallserver.callServer,\n        findSourceMapURL: _appfindsourcemapurl.findSourceMapURL\n    });\n}\nfunction createUnclosingPrefetchStream(originalFlightStream) {\n    // When PPR is enabled, prefetch streams may contain references that never\n    // resolve, because that's how we encode dynamic data access. In the decoded\n    // object returned by the Flight client, these are reified into hanging\n    // promises that suspend during render, which is effectively what we want.\n    // The UI resolves when it switches to the dynamic data stream\n    // (via useDeferredValue(dynamic, static)).\n    //\n    // However, the Flight implementation currently errors if the server closes\n    // the response before all the references are resolved. As a cheat to work\n    // around this, we wrap the original stream in a new stream that never closes,\n    // and therefore doesn't error.\n    const reader = originalFlightStream.getReader();\n    return new ReadableStream({\n        async pull (controller) {\n            while(true){\n                const { done, value } = await reader.read();\n                if (!done) {\n                    // Pass to the target stream and keep consuming the Flight response\n                    // from the server.\n                    controller.enqueue(value);\n                    continue;\n                }\n                // The server stream has closed. Exit, but intentionally do not close\n                // the target stream.\n                return;\n            }\n        }\n    });\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=fetch-server-response.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE1LjUuMTJfcmVhY3QtZG9tQDE5LjIuNF9yZWFjdEAxOS4yLjRfX3JlYWN0QDE5LjIuNC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2ZldGNoLXNlcnZlci1yZXNwb25zZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUEyUXNCQSxXQUFXO2VBQVhBOztJQXFITkMsNEJBQTRCO2VBQTVCQTs7SUEzUk1DLG1CQUFtQjtlQUFuQkE7OztvQ0FqR3NEOzhDQWtCckU7MkNBQ29CO2lEQUNNO2dEQUNKOytDQUt0Qjt3Q0FDdUI7d0RBQ2E7eUNBQ0M7QUFFNUMsTUFBTUMsMkJBQ0pDLFFBQUFBLHdCQUErQjtBQThCakMsU0FBU0MsZ0JBQWdCQyxHQUFXO0lBQ2xDLE9BQU87UUFDTEMsWUFBWUMsQ0FBQUEsR0FBQUEsYUFBQUEsMkJBQUFBLEVBQ1YsSUFBSUMsSUFBSUgsS0FBS0ksU0FBU0MsTUFBTSxHQUM1QkMsUUFBUTtRQUNWQyxjQUFjQztRQUNkQyxvQkFBb0I7UUFDcEJDLGFBQWE7UUFDYkMsV0FBVztRQUNYQyxXQUFXLENBQUM7SUFDZDtBQUNGO0FBRUEsSUFBSUMsa0JBQWtCLElBQUlDO0FBRTFCLElBQUksSUFBNkIsRUFBRTtJQUNqQyxzRUFBc0U7SUFDdEUsOEVBQThFO0lBQzlFLDBFQUEwRTtJQUMxRSxZQUFZO0lBQ1pDLE9BQU9DLGdCQUFnQixDQUFDLFlBQVk7UUFDbENILGdCQUFnQkksS0FBSztJQUN2QjtJQUVBLDhFQUE4RTtJQUM5RSxtRUFBbUU7SUFDbkVGLE9BQU9DLGdCQUFnQixDQUFDLFlBQVk7UUFDbENILGtCQUFrQixJQUFJQztJQUN4QjtBQUNGO0FBTU8sZUFBZWxCLG9CQUNwQkksR0FBUSxFQUNSa0IsT0FBbUM7SUFFbkMsTUFBTSxFQUFFQyxpQkFBaUIsRUFBRUMsT0FBTyxFQUFFQyxZQUFZLEVB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U0FBU0QscUJBQXFCRSxTQUFTO0lBQzdDLE9BQU8sSUFBSUMsZUFBZTtRQUN4QixNQUFNQyxNQUFLQyxVQUFVO1lBQ25CLE1BQU8sS0FBTTtnQkFDWCxNQUFNLEVBQUVDLElBQUksRUFBRUMsS0FBSyxFQUFFLEdBQUcsTUFBTU4sT0FBT08sSUFBSTtnQkFDekMsSUFBSSxDQUFDRixNQUFNO29CQUNULG1FQUFtRTtvQkFDbkUsbUJBQW1CO29CQUNuQkQsV0FBV0ksT0FBTyxDQUFDRjtvQkFDbkI7Z0JBQ0Y7Z0JBQ0EscUVBQXFFO2dCQUNyRSxxQkFBcUI7Z0JBQ3JCO1lBQ0Y7UUFDRjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zcmMvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvZmV0Y2gtc2VydmVyLXJlc3BvbnNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuXG4vLyBUT0RPOiBFeHBsaWNpdGx5IGltcG9ydCBmcm9tIGNsaWVudC5icm93c2VyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLWV4dHJhbmVvdXMtZGVwZW5kZW5jaWVzXG5pbXBvcnQgeyBjcmVhdGVGcm9tUmVhZGFibGVTdHJlYW0gYXMgY3JlYXRlRnJvbVJlYWRhYmxlU3RyZWFtQnJvd3NlciB9IGZyb20gJ3JlYWN0LXNlcnZlci1kb20td2VicGFjay9jbGllbnQnXG5cbmltcG9ydCB0eXBlIHtcbiAgRmxpZ2h0Um91dGVyU3RhdGUsXG4gIE5hdmlnYXRpb25GbGlnaHRSZXNwb25zZSxcbn0gZnJvbSAnLi4vLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvdHlwZXMnXG5cbmltcG9ydCB0eXBlIHsgTkVYVF9ST1VURVJfU0VHTUVOVF9QUkVGRVRDSF9IRUFERVIgfSBmcm9tICcuLi9hcHAtcm91dGVyLWhlYWRlcnMnXG5pbXBvcnQge1xuICBORVhUX1JPVVRFUl9QUkVGRVRDSF9IRUFERVIsXG4gIE5FWFRfUk9VVEVSX1NUQVRFX1RSRUVfSEVBREVSLFxuICBORVhUX1JTQ19VTklPTl9RVUVSWSxcbiAgTkVYVF9VUkwsXG4gIFJTQ19IRUFERVIsXG4gIFJTQ19DT05URU5UX1RZUEVfSEVBREVSLFxuICBORVhUX0hNUl9SRUZSRVNIX0hFQURFUixcbiAgTkVYVF9ESURfUE9TVFBPTkVfSEVBREVSLFxuICBORVhUX1JPVVRFUl9TVEFMRV9USU1FX0hFQURFUixcbn0gZnJvbSAnLi4vYXBwLXJvdXRlci1oZWFkZXJzJ1xuaW1wb3J0IHsgY2FsbFNlcnZlciB9IGZyb20gJy4uLy4uL2FwcC1jYWxsLXNlcnZlcidcbmltcG9ydCB7IGZpbmRTb3VyY2VNYXBVUkwgfSBmcm9tICcuLi8uLi9hcHAtZmluZC1zb3VyY2UtbWFwLXVybCdcbmltcG9ydCB7IFByZWZldGNoS2luZCB9IGZyb20gJy4vcm91dGVyLXJlZHVjZXItdHlwZXMnXG5pbXBvcnQge1xuICBub3JtYWxpemVGbGlnaHREYXRhLFxuICBwcmVwYXJlRmxpZ2h0Um91dGVyU3RhdGVGb3JSZXF1ZXN0LFxuICB0eXBlIE5vcm1hbGl6ZWRGbGlnaHREYXRhLFxufSBmcm9tICcuLi8uLi9mbGlnaHQtZGF0YS1oZWxwZXJzJ1xuaW1wb3J0IHsgZ2V0QXBwQnVpbGRJZCB9IGZyb20gJy4uLy4uL2FwcC1idWlsZC1pZCdcbmltcG9ydCB7IHNldENhY2hlQnVzdGluZ1NlYXJjaFBhcmFtIH0gZnJvbSAnLi9zZXQtY2FjaGUtYnVzdGluZy1zZWFyY2gtcGFyYW0nXG5pbXBvcnQgeyB1cmxUb1VybFdpdGhvdXRGbGlnaHRNYXJrZXIgfSBmcm9tICcuLi8uLi9yb3V0ZS1wYXJhbXMnXG5cbmNvbnN0IGNyZWF0ZUZyb21SZWFkYWJsZVN0cmVhbSA9XG4gIGNyZWF0ZUZyb21SZWFkYWJsZVN0cmVhbUJyb3dzZXIgYXMgKHR5cGVvZiBpbXBvcnQoJ3JlYWN0LXNlcnZlci1kb20td2VicGFjay9jbGllbnQuYnJvd3NlcicpKVsnY3JlYXRlRnJvbVJlYWRhYmxlU3RyZWFtJ11cblxuZXhwb3J0IGludGVyZmFjZSBGZXRjaFNlcnZlclJlc3BvbnNlT3B0aW9ucyB7XG4gIHJlYWRvbmx5IGZsaWdodFJvdXRlclN0YXRlOiBGbGlnaHRSb3V0ZXJTdGF0ZVxuICByZWFkb25seSBuZXh0VXJsOiBzdHJpbmcgfCBudWxsXG4gIHJlYWRvbmx5IHByZWZldGNoS2luZD86IFByZWZldGNoS2luZFxuICByZWFkb25seSBpc0htclJlZnJlc2g/OiBib29sZWFuXG59XG5cbmV4cG9ydCB0eXBlIEZldGNoU2VydmVyUmVzcG9uc2VSZXN1bHQgPSB7XG4gIGZsaWdodERhdGE6IE5vcm1hbGl6ZWRGbGlnaHREYXRhW10gfCBzdHJpbmdcbiAgY2Fub25pY2FsVXJsOiBVUkwgfCB1bmRlZmluZWRcbiAgY291bGRCZUludGVyY2VwdGVkOiBib29sZWFuXG4gIHByZXJlbmRlcmVkOiBib29sZWFuXG4gIHBvc3Rwb25lZDogYm9vbGVhblxuICBzdGFsZVRpbWU6IG51bWJlclxufVxuXG5leHBvcnQgdHlwZSBSZXF1ZXN0SGVhZGVycyA9IHtcbiAgW1JTQ19IRUFERVJdPzogJzEnXG4gIFtORVhUX1JPVVRFUl9TVEFURV9UUkVFX0hFQURFUl0/OiBzdHJpbmdcbiAgW05FWFRfVVJMXT86IHN0cmluZ1xuICBbTkVYVF9ST1VURVJfUFJFRkVUQ0hfSEVBREVSXT86ICcxJyB8ICcyJ1xuICBbTkVYVF9ST1VURVJfU0VHTUVOVF9QUkVGRVRDSF9IRUFERVJdPzogc3RyaW5nXG4gICd4LWRlcGxveW1lbnQtaWQnPzogc3RyaW5nXG4gIFtORVhUX0hNUl9SRUZSRVNIX0hFQURFUl0/OiAnMSdcbiAgLy8gQSBoZWFkZXIgdGhhdCBpcyBvbmx5IGFkZGVkIGluIHRlc3QgbW9kZSB0byBhc3NlcnQgb24gZmV0Y2ggcHJpb3JpdHlcbiAgJ05leHQtVGVzdC1GZXRjaC1Qcmlvcml0eSc/OiBSZXF1ZXN0SW5pdFsncHJpb3JpdHknXVxufVxuXG5mdW5jdGlvbiBkb01wYU5hdmlnYXRpb24odXJsOiBzdHJpbmcpOiBGZXRjaFNlcnZlclJlc3BvbnNlUmVzdWx0IHtcbiAgcmV0dXJuIHtcbiAgICBmbGlnaHREYXRhOiB1cmxUb1VybFdpdGhvdXRGbGlnaHRNYXJrZXIoXG4gICAgICBuZXcgVVJMKHVybCwgbG9jYXRpb24ub3JpZ2luKVxuICAgICkudG9TdHJpbmcoKSxcbiAgICBjYW5vbmljYWxVcmw6IHVuZGVmaW5lZCxcbiAgICBjb3VsZEJlSW50ZXJjZXB0ZWQ6IGZhbHNlLFxuICAgIHByZXJlbmRlcmVkOiBmYWxzZSxcbiAgICBwb3N0cG9uZWQ6IGZhbHNlLFxuICAgIHN0YWxlVGltZTogLTEsXG4gIH1cbn1cblxubGV0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgLy8gQWJvcnQgYW55IGluLWZsaWdodCByZXF1ZXN0cyB3aGVuIHRoZSBwYWdlIGlzIHVubG9hZGVkLCBlLmcuIGR1ZSB0b1xuICAvLyByZWxvYWRpbmcgdGhlIHBhZ2Ugb3IgcGVyZm9ybWluZyBoYXJkIG5hdmlnYXRpb25zLiBUaGlzIGFsbG93cyB1cyB0byBpZ25vcmVcbiAgLy8gd2hhdCB3b3VsZCBvdGhlcndpc2UgYmUgYSB0aHJvd24gVHlwZUVycm9yIHdoZW4gdGhlIGJyb3dzZXIgY2FuY2VscyB0aGVcbiAgLy8gcmVxdWVzdHMuXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwYWdlaGlkZScsICgpID0+IHtcbiAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKVxuICB9KVxuXG4gIC8vIFVzZSBhIGZyZXNoIEFib3J0Q29udHJvbGxlciBpbnN0YW5jZSBvbiBwYWdlc2hvdywgZS5nLiB3aGVuIG5hdmlnYXRpbmcgYmFja1xuICAvLyBhbmQgdGhlIEphdmFTY3JpcHQgZXhlY3V0aW9uIGNvbnRleHQgaXMgcmVzdG9yZWQgYnkgdGhlIGJyb3dzZXIuXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwYWdlc2hvdycsICgpID0+IHtcbiAgICBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKClcbiAgfSlcbn1cblxuLyoqXG4gKiBGZXRjaCB0aGUgZmxpZ2h0IGRhdGEgZm9yIHRoZSBwcm92aWRlZCB1cmwuIFRha2VzIGluIHRoZSBjdXJyZW50IHJvdXRlciBzdGF0ZVxuICogdG8gZGVjaWRlIHdoYXQgdG8gcmVuZGVyIHNlcnZlci1zaWRlLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hTZXJ2ZXJSZXNwb25zZShcbiAgdXJsOiBVUkwsXG4gIG9wdGlvbnM6IEZldGNoU2VydmVyUmVzcG9uc2VPcHRpb25zXG4pOiBQcm9taXNlPEZldGNoU2VydmVyUmVzcG9uc2VSZXN1bHQ+IHtcbiAgY29uc3QgeyBmbGlnaHRSb3V0ZXJTdGF0ZSwgbmV4dFVybCwgcHJlZmV0Y2hLaW5kIH0gPSBvcHRpb25zXG5cbiAgY29uc3QgaGVhZGVyczogUmVxdWVzdEhlYWRlcnMgPSB7XG4gICAgLy8gRW5hYmxlIGZsaWdodCByZXNwb25zZVxuICAgIFtSU0NfSEVBREVSXTogJzEnLFxuICAgIC8vIFByb3ZpZGUgdGhlIGN1cnJlbnQgcm91dGVyIHN0YXRlXG4gICAgW05FWFRfUk9VVEVSX1NUQVRFX1RSRUVfSEVBREVSXTogcHJlcGFyZUZsaWdodFJvdXRlclN0YXRlRm9yUmVxdWVzdChcbiAgICAgIGZsaWdodFJvdXRlclN0YXRlLFxuICAgICAgb3B0aW9ucy5pc0htclJlZnJlc2hcbiAgICApLFxuICB9XG5cbiAgLyoqXG4gICAqIFRocmVlIGNhc2VzOlxuICAgKiAtIGBwcmVmZXRjaEtpbmRgIGlzIGB1bmRlZmluZWRgLCBpdCBtZWFucyBpdCdzIGEgbm9ybWFsIG5hdmlnYXRpb24sIHNvIHdlIHdhbnQgdG8gcHJlZmV0Y2ggdGhlIHBhZ2UgZGF0YSBmdWxseVxuICAgKiAtIGBwcmVmZXRjaEtpbmRgIGlzIGBmdWxsYCAtIHdlIHdhbnQgdG8gcHJlZmV0Y2ggdGhlIHdob2xlIHBhZ2Ugc28gc2FtZSBhcyBhYm92ZVxuICAgKiAtIGBwcmVmZXRjaEtpbmRgIGlzIGBhdXRvYCAtIGlmIHRoZSBwYWdlIGlzIGR5bmFtaWMsIHByZWZldGNoIHRoZSBwYWdlIGRhdGEgcGFydGlhbGx5LCBpZiBzdGF0aWMgcHJlZmV0Y2ggdGhlIHBhZ2UgZGF0YSBmdWxseVxuICAgKi9cbiAgaWYgKHByZWZldGNoS2luZCA9PT0gUHJlZmV0Y2hLaW5kLkFVVE8pIHtcbiAgICBoZWFkZXJzW05FWFRfUk9VVEVSX1BSRUZFVENIX0hFQURFUl0gPSAnMSdcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiBvcHRpb25zLmlzSG1yUmVmcmVzaCkge1xuICAgIGhlYWRlcnNbTkVYVF9ITVJfUkVGUkVTSF9IRUFERVJdID0gJzEnXG4gIH1cblxuICBpZiAobmV4dFVybCkge1xuICAgIGhlYWRlcnNbTkVYVF9VUkxdID0gbmV4dFVybFxuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBXaGVuIGNyZWF0aW5nIGEgXCJ0ZW1wb3JhcnlcIiBwcmVmZXRjaCAodGhlIFwib24tZGVtYW5kXCIgcHJlZmV0Y2ggdGhhdCBnZXRzIGNyZWF0ZWQgb24gbmF2aWdhdGlvbiwgaWYgb25lIGRvZXNuJ3QgZXhpc3QpXG4gICAgLy8gd2Ugc2VuZCB0aGUgcmVxdWVzdCB3aXRoIGEgXCJoaWdoXCIgcHJpb3JpdHkgYXMgaXQncyBpbiByZXNwb25zZSB0byBhIHVzZXIgaW50ZXJhY3Rpb24gdGhhdCBjb3VsZCBiZSBibG9ja2luZyBhIHRyYW5zaXRpb24uXG4gICAgLy8gT3RoZXJ3aXNlLCBhbGwgb3RoZXIgcHJlZmV0Y2hlcyBhcmUgc2VudCB3aXRoIGEgXCJsb3dcIiBwcmlvcml0eS5cbiAgICAvLyBXZSB1c2UgXCJhdXRvXCIgZm9yIGluIGFsbCBvdGhlciBjYXNlcyB0byBtYXRjaCB0aGUgZXhpc3RpbmcgZGVmYXVsdCwgYXMgdGhpcyBmdW5jdGlvbiBpcyBzaGFyZWQgb3V0c2lkZSBvZiBwcmVmZXRjaGluZy5cbiAgICBjb25zdCBmZXRjaFByaW9yaXR5ID0gcHJlZmV0Y2hLaW5kXG4gICAgICA/IHByZWZldGNoS2luZCA9PT0gUHJlZmV0Y2hLaW5kLlRFTVBPUkFSWVxuICAgICAgICA/ICdoaWdoJ1xuICAgICAgICA6ICdsb3cnXG4gICAgICA6ICdhdXRvJ1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfQ09ORklHX09VVFBVVCA9PT0gJ2V4cG9ydCcpIHtcbiAgICAgICAgLy8gSW4gXCJvdXRwdXQ6IGV4cG9ydFwiIG1vZGUsIHdlIGNhbid0IHJlbHkgb24gaGVhZGVycyB0byBkaXN0aW5ndWlzaFxuICAgICAgICAvLyBiZXR3ZWVuIEhUTUwgYW5kIFJTQyByZXF1ZXN0cy4gSW5zdGVhZCwgd2UgYXBwZW5kIGFuIGV4dHJhIHByZWZpeFxuICAgICAgICAvLyB0byB0aGUgcmVxdWVzdC5cbiAgICAgICAgdXJsID0gbmV3IFVSTCh1cmwpXG4gICAgICAgIGlmICh1cmwucGF0aG5hbWUuZW5kc1dpdGgoJy8nKSkge1xuICAgICAgICAgIHVybC5wYXRobmFtZSArPSAnaW5kZXgudHh0J1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVybC5wYXRobmFtZSArPSAnLnR4dCdcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGNyZWF0ZUZldGNoKFxuICAgICAgdXJsLFxuICAgICAgaGVhZGVycyxcbiAgICAgIGZldGNoUHJpb3JpdHksXG4gICAgICBhYm9ydENvbnRyb2xsZXIuc2lnbmFsXG4gICAgKVxuXG4gICAgY29uc3QgcmVzcG9uc2VVcmwgPSB1cmxUb1VybFdpdGhvdXRGbGlnaHRNYXJrZXIobmV3IFVSTChyZXMudXJsKSlcbiAgICBjb25zdCBjYW5vbmljYWxVcmwgPSByZXMucmVkaXJlY3RlZCA/IHJlc3BvbnNlVXJsIDogdW5kZWZpbmVkXG5cbiAgICBjb25zdCBjb250ZW50VHlwZSA9IHJlcy5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykgfHwgJydcbiAgICBjb25zdCBpbnRlcmNlcHRpb24gPSAhIXJlcy5oZWFkZXJzLmdldCgndmFyeScpPy5pbmNsdWRlcyhORVhUX1VSTClcbiAgICBjb25zdCBwb3N0cG9uZWQgPSAhIXJlcy5oZWFkZXJzLmdldChORVhUX0RJRF9QT1NUUE9ORV9IRUFERVIpXG4gICAgY29uc3Qgc3RhbGVUaW1lSGVhZGVyU2Vjb25kcyA9IHJlcy5oZWFkZXJzLmdldChcbiAgICAgIE5FWFRfUk9VVEVSX1NUQUxFX1RJTUVfSEVBREVSXG4gICAgKVxuICAgIGNvbnN0IHN0YWxlVGltZSA9XG4gICAgICBzdGFsZVRpbWVIZWFkZXJTZWNvbmRzICE9PSBudWxsXG4gICAgICAgID8gcGFyc2VJbnQoc3RhbGVUaW1lSGVhZGVyU2Vjb25kcywgMTApICogMTAwMFxuICAgICAgICA6IC0xXG4gICAgbGV0IGlzRmxpZ2h0UmVzcG9uc2UgPSBjb250ZW50VHlwZS5zdGFydHNXaXRoKFJTQ19DT05URU5UX1RZUEVfSEVBREVSKVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfQ09ORklHX09VVFBVVCA9PT0gJ2V4cG9ydCcpIHtcbiAgICAgICAgaWYgKCFpc0ZsaWdodFJlc3BvbnNlKSB7XG4gICAgICAgICAgaXNGbGlnaHRSZXNwb25zZSA9IGNvbnRlbnRUeXBlLnN0YXJ0c1dpdGgoJ3RleHQvcGxhaW4nKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgZmV0Y2ggcmV0dXJucyBzb21ldGhpbmcgZGlmZmVyZW50IHRoYW4gZmxpZ2h0IHJlc3BvbnNlIGhhbmRsZSBpdCBsaWtlIGEgbXBhIG5hdmlnYXRpb25cbiAgICAvLyBJZiB0aGUgZmV0Y2ggd2FzIG5vdCAyMDAsIHdlIGFsc28gaGFuZGxlIGl0IGxpa2UgYSBtcGEgbmF2aWdhdGlvblxuICAgIGlmICghaXNGbGlnaHRSZXNwb25zZSB8fCAhcmVzLm9rIHx8ICFyZXMuYm9keSkge1xuICAgICAgLy8gaW4gY2FzZSB0aGUgb3JpZ2luYWwgVVJMIGNhbWUgd2l0aCBhIGhhc2gsIHByZXNlcnZlIGl0IGJlZm9yZSByZWRpcmVjdGluZyB0byB0aGUgbmV3IFVSTFxuICAgICAgaWYgKHVybC5oYXNoKSB7XG4gICAgICAgIHJlc3BvbnNlVXJsLmhhc2ggPSB1cmwuaGFzaFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZG9NcGFOYXZpZ2F0aW9uKHJlc3BvbnNlVXJsLnRvU3RyaW5nKCkpXG4gICAgfVxuXG4gICAgLy8gV2UgbWF5IG5hdmlnYXRlIHRvIGEgcGFnZSB0aGF0IHJlcXVpcmVzIGEgZGlmZmVyZW50IFdlYnBhY2sgcnVudGltZS5cbiAgICAvLyBJbiBwcm9kLCBldmVyeSBwYWdlIHdpbGwgaGF2ZSB0aGUgc2FtZSBXZWJwYWNrIHJ1bnRpbWUuXG4gICAgLy8gSW4gZGV2LCB0aGUgV2VicGFjayBydW50aW1lIGlzIG1pbmltYWwgZm9yIGVhY2ggcGFnZS5cbiAgICAvLyBXZSBuZWVkIHRvIGVuc3VyZSB0aGUgV2VicGFjayBydW50aW1lIGlzIHVwZGF0ZWQgYmVmb3JlIGV4ZWN1dGluZyBjbGllbnQtc2lkZSBKUyBvZiB0aGUgbmV3IHBhZ2UuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIXByb2Nlc3MuZW52LlRVUkJPUEFDSykge1xuICAgICAgYXdhaXQgKFxuICAgICAgICByZXF1aXJlKCcuLi8uLi9kZXYvaG90LXJlbG9hZGVyL2FwcC9ob3QtcmVsb2FkZXItYXBwJykgYXMgdHlwZW9mIGltcG9ydCgnLi4vLi4vZGV2L2hvdC1yZWxvYWRlci9hcHAvaG90LXJlbG9hZGVyLWFwcCcpXG4gICAgICApLndhaXRGb3JXZWJwYWNrUnVudGltZUhvdFVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHRoZSBgZmV0Y2hgIHJlYWRhYmxlIHN0cmVhbSB0aGF0IGNhbiBiZSB1bndyYXBwZWQgYnkgYFJlYWN0LnVzZWAuXG4gICAgY29uc3QgZmxpZ2h0U3RyZWFtID0gcG9zdHBvbmVkXG4gICAgICA/IGNyZWF0ZVVuY2xvc2luZ1ByZWZldGNoU3RyZWFtKHJlcy5ib2R5KVxuICAgICAgOiByZXMuYm9keVxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgKGNyZWF0ZUZyb21OZXh0UmVhZGFibGVTdHJlYW0oXG4gICAgICBmbGlnaHRTdHJlYW1cbiAgICApIGFzIFByb21pc2U8TmF2aWdhdGlvbkZsaWdodFJlc3BvbnNlPilcblxuICAgIGlmIChnZXRBcHBCdWlsZElkKCkgIT09IHJlc3BvbnNlLmIpIHtcbiAgICAgIHJldHVybiBkb01wYU5hdmlnYXRpb24ocmVzLnVybClcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZmxpZ2h0RGF0YTogbm9ybWFsaXplRmxpZ2h0RGF0YShyZXNwb25zZS5mKSxcbiAgICAgIGNhbm9uaWNhbFVybDogY2Fub25pY2FsVXJsLFxuICAgICAgY291bGRCZUludGVyY2VwdGVkOiBpbnRlcmNlcHRpb24sXG4gICAgICBwcmVyZW5kZXJlZDogcmVzcG9uc2UuUyxcbiAgICAgIHBvc3Rwb25lZCxcbiAgICAgIHN0YWxlVGltZSxcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmICghYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBgRmFpbGVkIHRvIGZldGNoIFJTQyBwYXlsb2FkIGZvciAke3VybH0uIEZhbGxpbmcgYmFjayB0byBicm93c2VyIG5hdmlnYXRpb24uYCxcbiAgICAgICAgZXJyXG4gICAgICApXG4gICAgfVxuXG4gICAgLy8gSWYgZmV0Y2ggZmFpbHMgaGFuZGxlIGl0IGxpa2UgYSBtcGEgbmF2aWdhdGlvblxuICAgIC8vIFRPRE8tQVBQOiBBZGQgYSB0ZXN0IGZvciB0aGUgY2FzZSB3aGVyZSBhIENPUlMgcmVxdWVzdCBmYWlscywgZS5nLiBleHRlcm5hbCB1cmwgcmVkaXJlY3QgY29taW5nIGZyb20gdGhlIHJlc3BvbnNlLlxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL25leHQuanMvaXNzdWVzLzQzNjA1I2lzc3VlY29tbWVudC0xNDUxNjE3NTIxIGZvciBhIHJlcHJvZHVjdGlvbi5cbiAgICByZXR1cm4ge1xuICAgICAgZmxpZ2h0RGF0YTogdXJsLnRvU3RyaW5nKCksXG4gICAgICBjYW5vbmljYWxVcmw6IHVuZGVmaW5lZCxcbiAgICAgIGNvdWxkQmVJbnRlcmNlcHRlZDogZmFsc2UsXG4gICAgICBwcmVyZW5kZXJlZDogZmFsc2UsXG4gICAgICBwb3N0cG9uZWQ6IGZhbHNlLFxuICAgICAgc3RhbGVUaW1lOiAtMSxcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhpcyBpcyBhIHN1YnNldCBvZiB0aGUgc3RhbmRhcmQgUmVzcG9uc2UgdHlwZS4gV2UgdXNlIGEgY3VzdG9tIHR5cGUgZm9yXG4vLyB0aGlzIHNvIHdlIGNhbiBsaW1pdCB3aGljaCBkZXRhaWxzIGFib3V0IHRoZSByZXNwb25zZSBsZWFrIGludG8gdGhlIHJlc3Qgb2Zcbi8vIHRoZSBjb2RlYmFzZS4gRm9yIGV4YW1wbGUsIHRoZXJlJ3Mgc29tZSBjdXN0b20gbG9naWMgZm9yIG1hbnVhbGx5IGZvbGxvd2luZ1xuLy8gcmVkaXJlY3RzLCBzbyBcInJlZGlyZWN0ZWRcIiBpbiB0aGlzIHR5cGUgY291bGQgYmUgYSBjb21wb3NpdGUgb2YgbXVsdGlwbGVcbi8vIGJyb3dzZXIgZmV0Y2ggY2FsbHM7IGhvd2V2ZXIsIHRoaXMgZmFjdCBzaG91bGQgbm90IGxlYWsgdG8gdGhlIGNhbGxlci5cbmV4cG9ydCB0eXBlIFJTQ1Jlc3BvbnNlID0ge1xuICBvazogYm9vbGVhblxuICByZWRpcmVjdGVkOiBib29sZWFuXG4gIGhlYWRlcnM6IEhlYWRlcnNcbiAgYm9keTogUmVhZGFibGVTdHJlYW08VWludDhBcnJheT4gfCBudWxsXG4gIHN0YXR1czogbnVtYmVyXG4gIHVybDogc3RyaW5nXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVGZXRjaChcbiAgdXJsOiBVUkwsXG4gIGhlYWRlcnM6IFJlcXVlc3RIZWFkZXJzLFxuICBmZXRjaFByaW9yaXR5OiAnYXV0bycgfCAnaGlnaCcgfCAnbG93JyB8IG51bGwsXG4gIHNpZ25hbD86IEFib3J0U2lnbmFsXG4pOiBQcm9taXNlPFJTQ1Jlc3BvbnNlPiB7XG4gIC8vIFRPRE86IEluIG91dHB1dDogXCJleHBvcnRcIiBtb2RlLCB0aGUgaGVhZGVycyBkbyBub3RoaW5nLiBPbWl0IHRoZW0gKGFuZCB0aGVcbiAgLy8gY2FjaGUgYnVzdGluZyBzZWFyY2ggcGFyYW0pIGZyb20gdGhlIHJlcXVlc3Qgc28gdGhleSdyZVxuICAvLyBtYXhpbWFsbHkgY2FjaGVhYmxlLlxuXG4gIGlmIChwcm9jZXNzLmVudi5fX05FWFRfVEVTVF9NT0RFICYmIGZldGNoUHJpb3JpdHkgIT09IG51bGwpIHtcbiAgICBoZWFkZXJzWydOZXh0LVRlc3QtRmV0Y2gtUHJpb3JpdHknXSA9IGZldGNoUHJpb3JpdHlcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5ORVhUX0RFUExPWU1FTlRfSUQpIHtcbiAgICBoZWFkZXJzWyd4LWRlcGxveW1lbnQtaWQnXSA9IHByb2Nlc3MuZW52Lk5FWFRfREVQTE9ZTUVOVF9JRFxuICB9XG5cbiAgY29uc3QgZmV0Y2hPcHRpb25zOiBSZXF1ZXN0SW5pdCA9IHtcbiAgICAvLyBCYWNrd2FyZHMgY29tcGF0IGZvciBvbGRlciBicm93c2Vycy4gYHNhbWUtb3JpZ2luYCBpcyB0aGUgZGVmYXVsdCBpbiBtb2Rlcm4gYnJvd3NlcnMuXG4gICAgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbicsXG4gICAgaGVhZGVycyxcbiAgICBwcmlvcml0eTogZmV0Y2hQcmlvcml0eSB8fCB1bmRlZmluZWQsXG4gICAgc2lnbmFsLFxuICB9XG4gIC8vIGBmZXRjaFVybGAgaXMgc2xpZ2h0bHkgZGlmZmVyZW50IGZyb20gYHVybGAgYmVjYXVzZSB3ZSBhZGQgYSBjYWNoZS1idXN0aW5nXG4gIC8vIHNlYXJjaCBwYXJhbSB0byBpdC4gVGhpcyBzaG91bGQgbm90IGxlYWsgb3V0c2lkZSBvZiB0aGlzIGZ1bmN0aW9uLCBzbyB3ZVxuICAvLyB0cmFjayB0aGVtIHNlcGFyYXRlbHkuXG4gIGxldCBmZXRjaFVybCA9IG5ldyBVUkwodXJsKVxuICBzZXRDYWNoZUJ1c3RpbmdTZWFyY2hQYXJhbShmZXRjaFVybCwgaGVhZGVycylcbiAgbGV0IGJyb3dzZXJSZXNwb25zZSA9IGF3YWl0IGZldGNoKGZldGNoVXJsLCBmZXRjaE9wdGlvbnMpXG5cbiAgLy8gSWYgdGhlIHNlcnZlciByZXNwb25kcyB3aXRoIGEgcmVkaXJlY3QgKGUuZy4gMzA3KSwgYW5kIHRoZSByZWRpcmVjdGVkXG4gIC8vIGxvY2F0aW9uIGRvZXMgbm90IGNvbnRhaW4gdGhlIGNhY2hlIGJ1c3Rpbmcgc2VhcmNoIHBhcmFtIHNldCBpbiB0aGVcbiAgLy8gb3JpZ2luYWwgcmVxdWVzdCwgdGhlIHJlc3BvbnNlIGlzIGxpa2VseSBpbnZhbGlkIOKAlCB3aGVuIGZvbGxvd2luZyB0aGVcbiAgLy8gcmVkaXJlY3QsIHRoZSBicm93c2VyIGZvcndhcmRzIHRoZSByZXF1ZXN0IGhlYWRlcnMsIGJ1dCBzaW5jZSB0aGUgY2FjaGVcbiAgLy8gYnVzdGluZyBzZWFyY2ggcGFyYW0gaXMgbWlzc2luZywgdGhlIHNlcnZlciB3aWxsIHJlamVjdCB0aGUgcmVxdWVzdCBkdWUgdG9cbiAgLy8gYSBtaXNtYXRjaC5cbiAgLy9cbiAgLy8gSWRlYWxseSwgd2Ugd291bGQgYmUgYWJsZSB0byBpbnRlcmNlcHQgdGhlIHJlZGlyZWN0IHJlc3BvbnNlIGFuZCBwZXJmb3JtIGl0XG4gIC8vIG1hbnVhbGx5LCBpbnN0ZWFkIG9mIGxldHRpbmcgdGhlIGJyb3dzZXIgYXV0b21hdGljYWxseSBmb2xsb3cgaXQsIGJ1dCB0aGlzXG4gIC8vIGlzIG5vdCBhbGxvd2VkIGJ5IHRoZSBmZXRjaCBBUEkuXG4gIC8vXG4gIC8vIFNvIGluc3RlYWQsIHdlIG11c3QgXCJyZXBsYXlcIiB0aGUgcmVkaXJlY3QgYnkgZmV0Y2hpbmcgdGhlIG5ldyBsb2NhdGlvblxuICAvLyBhZ2FpbiwgYnV0IHRoaXMgdGltZSB3ZSdsbCBhcHBlbmQgdGhlIGNhY2hlIGJ1c3Rpbmcgc2VhcmNoIHBhcmFtIHRvIHByZXZlbnRcbiAgLy8gYSBtaXNtYXRjaC5cbiAgLy9cbiAgLy8gVE9ETzogV2UgY2FuIG9wdGltaXplIE5leHQuanMncyBidWlsdC1pbiBtaWRkbGV3YXJlIEFQSXMgYnkgcmV0dXJuaW5nIGFcbiAgLy8gY3VzdG9tIHN0YXR1cyBjb2RlLCB0byBwcmV2ZW50IHRoZSBicm93c2VyIGZyb20gYXV0b21hdGljYWxseSBmb2xsb3dpbmcgaXQuXG4gIC8vXG4gIC8vIFRoaXMgZG9lcyBub3QgYWZmZWN0IFNlcnZlciBBY3Rpb24tYmFzZWQgcmVkaXJlY3RzOyB0aG9zZSBhcmUgZW5jb2RlZFxuICAvLyBkaWZmZXJlbnRseSwgYXMgcGFydCBvZiB0aGUgRmxpZ2h0IGJvZHkuIEl0IG9ubHkgYWZmZWN0cyByZWRpcmVjdHMgdGhhdFxuICAvLyBvY2N1ciBpbiBhIG1pZGRsZXdhcmUgb3IgYSB0aGlyZC1wYXJ0eSBwcm94eS5cblxuICBsZXQgcmVkaXJlY3RlZCA9IGJyb3dzZXJSZXNwb25zZS5yZWRpcmVjdGVkXG4gIGlmIChwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1ZBTElEQVRFX1JTQ19SRVFVRVNUX0hFQURFUlMpIHtcbiAgICAvLyBUaGlzIGlzIHRvIHByZXZlbnQgYSByZWRpcmVjdCBsb29wLiBTYW1lIGxpbWl0IHVzZWQgYnkgQ2hyb21lLlxuICAgIGNvbnN0IE1BWF9SRURJUkVDVFMgPSAyMFxuICAgIGZvciAobGV0IG4gPSAwOyBuIDwgTUFYX1JFRElSRUNUUzsgbisrKSB7XG4gICAgICBpZiAoIWJyb3dzZXJSZXNwb25zZS5yZWRpcmVjdGVkKSB7XG4gICAgICAgIC8vIFRoZSBzZXJ2ZXIgZGlkIG5vdCBwZXJmb3JtIGEgcmVkaXJlY3QuXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBjb25zdCByZXNwb25zZVVybCA9IG5ldyBVUkwoYnJvd3NlclJlc3BvbnNlLnVybCwgZmV0Y2hVcmwpXG4gICAgICBpZiAocmVzcG9uc2VVcmwub3JpZ2luICE9PSBmZXRjaFVybC5vcmlnaW4pIHtcbiAgICAgICAgLy8gVGhlIHNlcnZlciByZWRpcmVjdGVkIHRvIGFuIGV4dGVybmFsIFVSTC4gVGhlIHJlc3Qgb2YgdGhlIGxvZ2ljIGJlbG93XG4gICAgICAgIC8vIGlzIG5vdCByZWxldmFudCwgYmVjYXVzZSBpdCBvbmx5IGFwcGxpZXMgdG8gaW50ZXJuYWwgcmVkaXJlY3RzLlxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgaWYgKFxuICAgICAgICByZXNwb25zZVVybC5zZWFyY2hQYXJhbXMuZ2V0KE5FWFRfUlNDX1VOSU9OX1FVRVJZKSA9PT1cbiAgICAgICAgZmV0Y2hVcmwuc2VhcmNoUGFyYW1zLmdldChORVhUX1JTQ19VTklPTl9RVUVSWSlcbiAgICAgICkge1xuICAgICAgICAvLyBUaGUgcmVkaXJlY3RlZCBVUkwgYWxyZWFkeSBpbmNsdWRlcyB0aGUgY2FjaGUgYnVzdGluZyBzZWFyY2ggcGFyYW0uXG4gICAgICAgIC8vIFRoaXMgd2FzIHByb2JhYmx5IGludGVudGlvbmFsLiBSZWdhcmRsZXNzLCB0aGVyZSdzIG5vIHJlYXNvbiB0b1xuICAgICAgICAvLyBpc3N1ZSBhbm90aGVyIHJlcXVlc3QgdG8gdGhpcyBVUkwgYmVjYXVzZSBpdCBhbHJlYWR5IGhhcyB0aGUgcGFyYW1cbiAgICAgICAgLy8gdmFsdWUgdGhhdCB3ZSB3b3VsZCBoYXZlIGFkZGVkIGJlbG93LlxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgLy8gVGhlIFJTQyByZXF1ZXN0IHdhcyByZWRpcmVjdGVkLiBBc3N1bWUgdGhlIHJlc3BvbnNlIGlzIGludmFsaWQuXG4gICAgICAvL1xuICAgICAgLy8gQXBwZW5kIHRoZSBjYWNoZSBidXN0aW5nIHNlYXJjaCBwYXJhbSB0byB0aGUgcmVkaXJlY3RlZCBVUkwgYW5kXG4gICAgICAvLyBmZXRjaCBhZ2Fpbi5cbiAgICAgIGZldGNoVXJsID0gbmV3IFVSTChyZXNwb25zZVVybClcbiAgICAgIHNldENhY2hlQnVzdGluZ1NlYXJjaFBhcmFtKGZldGNoVXJsLCBoZWFkZXJzKVxuICAgICAgYnJvd3NlclJlc3BvbnNlID0gYXdhaXQgZmV0Y2goZmV0Y2hVcmwsIGZldGNoT3B0aW9ucylcbiAgICAgIC8vIFdlIGp1c3QgcGVyZm9ybWVkIGEgbWFudWFsIHJlZGlyZWN0LCBzbyB0aGlzIGlzIG5vdyB0cnVlLlxuICAgICAgcmVkaXJlY3RlZCA9IHRydWVcbiAgICB9XG4gIH1cblxuICAvLyBSZW1vdmUgdGhlIGNhY2hlIGJ1c3Rpbmcgc2VhcmNoIHBhcmFtIGZyb20gdGhlIHJlc3BvbnNlIFVSTCwgdG8gcHJldmVudCBpdFxuICAvLyBmcm9tIGxlYWtpbmcgb3V0c2lkZSBvZiB0aGlzIGZ1bmN0aW9uLlxuICBjb25zdCByZXNwb25zZVVybCA9IG5ldyBVUkwoYnJvd3NlclJlc3BvbnNlLnVybCwgZmV0Y2hVcmwpXG4gIHJlc3BvbnNlVXJsLnNlYXJjaFBhcmFtcy5kZWxldGUoTkVYVF9SU0NfVU5JT05fUVVFUlkpXG5cbiAgY29uc3QgcnNjUmVzcG9uc2U6IFJTQ1Jlc3BvbnNlID0ge1xuICAgIHVybDogcmVzcG9uc2VVcmwuaHJlZixcblxuICAgIC8vIFRoaXMgaXMgdHJ1ZSBpZiBhbnkgcmVkaXJlY3RzIG9jY3VycmVkLCBlaXRoZXIgYXV0b21hdGljYWxseSBieSB0aGVcbiAgICAvLyBicm93c2VyLCBvciBtYW51YWxseSBieSB1cy4gU28gaXQncyBkaWZmZXJlbnQgZnJvbVxuICAgIC8vIGBicm93c2VyUmVzcG9uc2UucmVkaXJlY3RlZGAsIHdoaWNoIG9ubHkgdGVsbHMgdXMgd2hldGhlciB0aGUgYnJvd3NlclxuICAgIC8vIGZvbGxvd2VkIGEgcmVkaXJlY3QsIGFuZCBvbmx5IGZvciB0aGUgbGFzdCByZXNwb25zZSBpbiB0aGUgY2hhaW4uXG4gICAgcmVkaXJlY3RlZCxcblxuICAgIC8vIFRoZXNlIGNhbiBiZSBjb3BpZWQgZnJvbSB0aGUgbGFzdCBicm93c2VyIHJlc3BvbnNlIHdlIHJlY2VpdmVkLiBXZVxuICAgIC8vIGludGVudGlvbmFsbHkgb25seSBleHBvc2UgdGhlIHN1YnNldCBvZiBmaWVsZHMgdGhhdCBhcmUgYWN0dWFsbHkgdXNlZFxuICAgIC8vIGVsc2V3aGVyZSBpbiB0aGUgY29kZWJhc2UuXG4gICAgb2s6IGJyb3dzZXJSZXNwb25zZS5vayxcbiAgICBoZWFkZXJzOiBicm93c2VyUmVzcG9uc2UuaGVhZGVycyxcbiAgICBib2R5OiBicm93c2VyUmVzcG9uc2UuYm9keSxcbiAgICBzdGF0dXM6IGJyb3dzZXJSZXNwb25zZS5zdGF0dXMsXG4gIH1cblxuICByZXR1cm4gcnNjUmVzcG9uc2Vcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZyb21OZXh0UmVhZGFibGVTdHJlYW0oXG4gIGZsaWdodFN0cmVhbTogUmVhZGFibGVTdHJlYW08VWludDhBcnJheT5cbik6IFByb21pc2U8dW5rbm93bj4ge1xuICByZXR1cm4gY3JlYXRlRnJvbVJlYWRhYmxlU3RyZWFtKGZsaWdodFN0cmVhbSwge1xuICAgIGNhbGxTZXJ2ZXIsXG4gICAgZmluZFNvdXJjZU1hcFVSTCxcbiAgfSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlVW5jbG9zaW5nUHJlZmV0Y2hTdHJlYW0oXG4gIG9yaWdpbmFsRmxpZ2h0U3RyZWFtOiBSZWFkYWJsZVN0cmVhbTxVaW50OEFycmF5PlxuKTogUmVhZGFibGVTdHJlYW08VWludDhBcnJheT4ge1xuICAvLyBXaGVuIFBQUiBpcyBlbmFibGVkLCBwcmVmZXRjaCBzdHJlYW1zIG1heSBjb250YWluIHJlZmVyZW5jZXMgdGhhdCBuZXZlclxuICAvLyByZXNvbHZlLCBiZWNhdXNlIHRoYXQncyBob3cgd2UgZW5jb2RlIGR5bmFtaWMgZGF0YSBhY2Nlc3MuIEluIHRoZSBkZWNvZGVkXG4gIC8vIG9iamVjdCByZXR1cm5lZCBieSB0aGUgRmxpZ2h0IGNsaWVudCwgdGhlc2UgYXJlIHJlaWZpZWQgaW50byBoYW5naW5nXG4gIC8vIHByb21pc2VzIHRoYXQgc3VzcGVuZCBkdXJpbmcgcmVuZGVyLCB3aGljaCBpcyBlZmZlY3RpdmVseSB3aGF0IHdlIHdhbnQuXG4gIC8vIFRoZSBVSSByZXNvbHZlcyB3aGVuIGl0IHN3aXRjaGVzIHRvIHRoZSBkeW5hbWljIGRhdGEgc3RyZWFtXG4gIC8vICh2aWEgdXNlRGVmZXJyZWRWYWx1ZShkeW5hbWljLCBzdGF0aWMpKS5cbiAgLy9cbiAgLy8gSG93ZXZlciwgdGhlIEZsaWdodCBpbXBsZW1lbnRhdGlvbiBjdXJyZW50bHkgZXJyb3JzIGlmIHRoZSBzZXJ2ZXIgY2xvc2VzXG4gIC8vIHRoZSByZXNwb25zZSBiZWZvcmUgYWxsIHRoZSByZWZlcmVuY2VzIGFyZSByZXNvbHZlZC4gQXMgYSBjaGVhdCB0byB3b3JrXG4gIC8vIGFyb3VuZCB0aGlzLCB3ZSB3cmFwIHRoZSBvcmlnaW5hbCBzdHJlYW0gaW4gYSBuZXcgc3RyZWFtIHRoYXQgbmV2ZXIgY2xvc2VzLFxuICAvLyBhbmQgdGhlcmVmb3JlIGRvZXNuJ3QgZXJyb3IuXG4gIGNvbnN0IHJlYWRlciA9IG9yaWdpbmFsRmxpZ2h0U3RyZWFtLmdldFJlYWRlcigpXG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIGFzeW5jIHB1bGwoY29udHJvbGxlcikge1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKVxuICAgICAgICBpZiAoIWRvbmUpIHtcbiAgICAgICAgICAvLyBQYXNzIHRvIHRoZSB0YXJnZXQgc3RyZWFtIGFuZCBrZWVwIGNvbnN1bWluZyB0aGUgRmxpZ2h0IHJlc3BvbnNlXG4gICAgICAgICAgLy8gZnJvbSB0aGUgc2VydmVyLlxuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh2YWx1ZSlcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBzZXJ2ZXIgc3RyZWFtIGhhcyBjbG9zZWQuIEV4aXQsIGJ1dCBpbnRlbnRpb25hbGx5IGRvIG5vdCBjbG9zZVxuICAgICAgICAvLyB0aGUgdGFyZ2V0IHN0cmVhbS5cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfSxcbiAgfSlcbn1cbiJdLCJuYW1lcyI6WyJjcmVhdGVGZXRjaCIsImNyZWF0ZUZyb21OZXh0UmVhZGFibGVTdHJlYW0iLCJmZXRjaFNlcnZlclJlc3BvbnNlIiwiY3JlYXRlRnJvbVJlYWRhYmxlU3RyZWFtIiwiY3JlYXRlRnJvbVJlYWRhYmxlU3RyZWFtQnJvd3NlciIsImRvTXBhTmF2aWdhdGlvbiIsInVybCIsImZsaWdodERhdGEiLCJ1cmxUb1VybFdpdGhvdXRGbGlnaHRNYXJrZXIiLCJVUkwiLCJsb2NhdGlvbiIsIm9yaWdpbiIsInRvU3RyaW5nIiwiY2Fub25pY2FsVXJsIiwidW5kZWZpbmVkIiwiY291bGRCZUludGVyY2VwdGVkIiwicHJlcmVuZGVyZWQiLCJwb3N0cG9uZWQiLCJzdGFsZVRpbWUiLCJhYm9ydENvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwiYWJvcnQiLCJvcHRpb25zIiwiZmxpZ2h0Um91dGVyU3RhdGUiLCJuZXh0VXJsIiwicHJlZmV0Y2hLaW5kIiwiaGVhZGVycyIsIlJTQ19IRUFERVIiLCJORVhUX1JPVVRFUl9TVEFURV9UUkVFX0hFQURFUiIsInByZXBhcmVGbGlnaHRSb3V0ZXJTdGF0ZUZvclJlcXVlc3QiLCJpc0htclJlZnJlc2giLCJQcmVmZXRjaEtpbmQiLCJBVVRPIiwiTkVYVF9ST1VURVJfUFJFRkVUQ0hfSEVBREVSIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiTkVYVF9ITVJfUkVGUkVTSF9IRUFERVIiLCJORVhUX1VSTCIsInJlcyIsImZldGNoUHJpb3JpdHkiLCJURU1QT1JBUlkiLCJfX05FWFRfQ09ORklHX09VVFBVVCIsInBhdGhuYW1lIiwiZW5kc1dpdGgiLCJzaWduYWwiLCJyZXNwb25zZVVybCIsInJlZGlyZWN0ZWQiLCJjb250ZW50VHlwZSIsImdldCIsImludGVyY2VwdGlvbiIsImluY2x1ZGVzIiwiTkVYVF9ESURfUE9TVFBPTkVfSEVBREVSIiwic3RhbGVUaW1lSGVhZGVyU2Vjb25kcyIsIk5FWFRfUk9VVEVSX1NUQUxFX1RJTUVfSEVBREVSIiwicGFyc2VJbnQiLCJpc0ZsaWdodFJlc3BvbnNlIiwic3RhcnRzV2l0aCIsIlJTQ19DT05URU5UX1RZUEVfSEVBREVSIiwib2siLCJib2R5IiwiaGFzaCIsIlRVUkJPUEFDSyIsInJlcXVpcmUiLCJ3YWl0Rm9yV2VicGFja1J1bnRpbWVIb3RVcGRhdGUiLCJmbGlnaHRTdHJlYW0iLCJjcmVhdGVVbmNsb3NpbmdQcmVmZXRjaFN0cmVhbSIsInJlc3BvbnNlIiwiZ2V0QXBwQnVpbGRJZCIsImIiLCJub3JtYWxpemVGbGlnaHREYXRhIiwiZiIsIlMiLCJlcnIiLCJhYm9ydGVkIiwiY29uc29sZSIsImVycm9yIiwiX19ORVhUX1RFU1RfTU9ERSIsIk5FWFRfREVQTE9ZTUVOVF9JRCIsImZldGNoT3B0aW9ucyIsImNyZWRlbnRpYWxzIiwicHJpb3JpdHkiLCJmZXRjaFVybCIsInNldENhY2hlQnVzdGluZ1NlYXJjaFBhcmFtIiwiYnJvd3NlclJlc3BvbnNlIiwiZmV0Y2giLCJfX05FWFRfQ0xJRU5UX1ZBTElEQVRFX1JTQ19SRVFVRVNUX0hFQURFUlMiLCJNQVhfUkVESVJFQ1RTIiwibiIsInNlYXJjaFBhcmFtcyIsIk5FWFRfUlNDX1VOSU9OX1FVRVJZIiwiZGVsZXRlIiwicnNjUmVzcG9uc2UiLCJocmVmIiwic3RhdHVzIiwiY2FsbFNlcnZlciIsImZpbmRTb3VyY2VNYXBVUkwiLCJvcmlnaW5hbEZsaWdodFN0cmVhbSIsInJlYWRlciIsImdldFJlYWRlciIsIlJlYWRhYmxlU3RyZWFtIiwicHVsbCIsImNvbnRyb2xsZXIiLCJkb25lIiwidmFsdWUiLCJyZWFkIiwiZW5xdWV1ZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/router-reducer/fetch-server-response.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js":
/*!*********************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js ***!
  \*********************************************************************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    DYNAMIC_STALETIME_MS: function() {\n        return DYNAMIC_STALETIME_MS;\n    },\n    STATIC_STALETIME_MS: function() {\n        return STATIC_STALETIME_MS;\n    },\n    createSeededPrefetchCacheEntry: function() {\n        return createSeededPrefetchCacheEntry;\n    },\n    getOrCreatePrefetchCacheEntry: function() {\n        return getOrCreatePrefetchCacheEntry;\n    },\n    prunePrefetchCache: function() {\n        return prunePrefetchCache;\n    }\n});\nconst _fetchserverresponse = __webpack_require__(/*! ./fetch-server-response */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/router-reducer/fetch-server-response.js\");\nconst _routerreducertypes = __webpack_require__(/*! ./router-reducer-types */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nconst _prefetchreducer = __webpack_require__(/*! ./reducers/prefetch-reducer */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js\");\nconst INTERCEPTION_CACHE_KEY_MARKER = '%';\n/**\n * Creates a cache key for the router prefetch cache\n *\n * @param url - The URL being navigated to\n * @param nextUrl - an internal URL, primarily used for handling rewrites. Defaults to '/'.\n * @return The generated prefetch cache key.\n */ function createPrefetchCacheKeyImpl(url, includeSearchParams, prefix) {\n    // Initially we only use the pathname as the cache key. We don't want to include\n    // search params so that multiple URLs with the same search parameter can re-use\n    // loading states.\n    let pathnameFromUrl = url.pathname;\n    // RSC responses can differ based on search params, specifically in the case where we aren't\n    // returning a partial response (ie with `PrefetchKind.AUTO`).\n    // In the auto case, since loading.js & layout.js won't have access to search params,\n    // we can safely re-use that cache entry. But for full prefetches, we should not\n    // re-use the cache entry as the response may differ.\n    if (includeSearchParams) {\n        // if we have a full prefetch, we can include the search param in the key,\n        // as we'll be getting back a full response. The server might have read the search\n        // params when generating the full response.\n        pathnameFromUrl += url.search;\n    }\n    if (prefix) {\n        return \"\" + prefix + INTERCEPTION_CACHE_KEY_MARKER + pathnameFromUrl;\n    }\n    return pathnameFromUrl;\n}\nfunction createPrefetchCacheKey(url, kind, nextUrl) {\n    return createPrefetchCacheKeyImpl(url, kind === _routerreducertypes.PrefetchKind.FULL, nextUrl);\n}\nfunction getExistingCacheEntry(url, kind, nextUrl, prefetchCache, allowAliasing) {\n    if (kind === void 0) kind = _routerreducertypes.PrefetchKind.TEMPORARY;\n    // We first check if there's a more specific interception route prefetch entry\n    // This is because when we detect a prefetch that corresponds with an interception route, we prefix it with nextUrl (see `createPrefetchCacheKey`)\n    // to avoid conflicts with other pages that may have the same URL but render different things depending on the `Next-URL` header.\n    for (const maybeNextUrl of [\n        nextUrl,\n        null\n    ]){\n        const cacheKeyWithParams = createPrefetchCacheKeyImpl(url, true, maybeNextUrl);\n        const cacheKeyWithoutParams = createPrefetchCacheKeyImpl(url, false, maybeNextUrl);\n        // First, we check if we have a cache entry that exactly matches the URL\n        const cacheKeyToUse = url.search ? cacheKeyWithParams : cacheKeyWithoutParams;\n        const existingEntry = prefetchCache.get(cacheKeyToUse);\n        if (existingEntry && allowAliasing) {\n            // We know we're returning an aliased entry when the pathname matches but the search params don't,\n            const isAliased = existingEntry.url.pathname === url.pathname && existingEntry.url.search !== url.search;\n            if (isAliased) {\n                return {\n                    ...existingEntry,\n                    aliased: true\n                };\n            }\n            return existingEntry;\n        }\n        // If the request contains search params, and we're not doing a full prefetch, we can return the\n        // param-less entry if it exists.\n        // This is technically covered by the check at the bottom of this function, which iterates over cache entries,\n        // but lets us arrive there quicker in the param-full case.\n        const entryWithoutParams = prefetchCache.get(cacheKeyWithoutParams);\n        if (false) {}\n    }\n    // If we've gotten to this point, we didn't find a specific cache entry that matched\n    // the request URL.\n    // We attempt a partial match by checking if there's a cache entry with the same pathname.\n    // Regardless of what we find, since it doesn't correspond with the requested URL, we'll mark it \"aliased\".\n    // This will signal to the router that it should only apply the loading state on the prefetched data.\n    if (false) {}\n    return undefined;\n}\nfunction getOrCreatePrefetchCacheEntry(param) {\n    let { url, nextUrl, tree, prefetchCache, kind, allowAliasing = true } = param;\n    const existingCacheEntry = getExistingCacheEntry(url, kind, nextUrl, prefetchCache, allowAliasing);\n    if (existingCacheEntry) {\n        // Grab the latest status of the cache entry and update it\n        existingCacheEntry.status = getPrefetchEntryCacheStatus(existingCacheEntry);\n        // when `kind` is provided, an explicit prefetch was requested.\n        // if the requested prefetch is \"full\" and the current cache entry wasn't, we want to re-prefetch with the new intent\n        const switchedToFullPrefetch = existingCacheEntry.kind !== _routerreducertypes.PrefetchKind.FULL && kind === _routerreducertypes.PrefetchKind.FULL;\n        if (switchedToFullPrefetch) {\n            // If we switched to a full prefetch, validate that the existing cache entry contained partial data.\n            // It's possible that the cache entry was seeded with full data but has a cache type of \"auto\" (ie when cache entries\n            // are seeded but without a prefetch intent)\n            existingCacheEntry.data.then((prefetchResponse)=>{\n                const isFullPrefetch = Array.isArray(prefetchResponse.flightData) && prefetchResponse.flightData.some((flightData)=>{\n                    // If we started rendering from the root and we returned RSC data (seedData), we already had a full prefetch.\n                    return flightData.isRootRender && flightData.seedData !== null;\n                });\n                if (!isFullPrefetch) {\n                    return createLazyPrefetchEntry({\n                        tree,\n                        url,\n                        nextUrl,\n                        prefetchCache,\n                        // If we didn't get an explicit prefetch kind, we want to set a temporary kind\n                        // rather than assuming the same intent as the previous entry, to be consistent with how we\n                        // lazily create prefetch entries when intent is left unspecified.\n                        kind: kind != null ? kind : _routerreducertypes.PrefetchKind.TEMPORARY\n                    });\n                }\n            });\n        }\n        // If the existing cache entry was marked as temporary, it means it was lazily created when attempting to get an entry,\n        // where we didn't have the prefetch intent. Now that we have the intent (in `kind`), we want to update the entry to the more accurate kind.\n        if (kind && existingCacheEntry.kind === _routerreducertypes.PrefetchKind.TEMPORARY) {\n            existingCacheEntry.kind = kind;\n        }\n        // We've determined that the existing entry we found is still valid, so we return it.\n        return existingCacheEntry;\n    }\n    // If we didn't return an entry, create a new one.\n    return createLazyPrefetchEntry({\n        tree,\n        url,\n        nextUrl,\n        prefetchCache,\n        kind: kind || _routerreducertypes.PrefetchKind.TEMPORARY\n    });\n}\n/*\n * Used to take an existing cache entry and prefix it with the nextUrl, if it exists.\n * This ensures that we don't have conflicting cache entries for the same URL (as is the case with route interception).\n */ function prefixExistingPrefetchCacheEntry(param) {\n    let { url, nextUrl, prefetchCache, existingCacheKey } = param;\n    const existingCacheEntry = prefetchCache.get(existingCacheKey);\n    if (!existingCacheEntry) {\n        // no-op -- there wasn't an entry to move\n        return;\n    }\n    const newCacheKey = createPrefetchCacheKey(url, existingCacheEntry.kind, nextUrl);\n    prefetchCache.set(newCacheKey, {\n        ...existingCacheEntry,\n        key: newCacheKey\n    });\n    prefetchCache.delete(existingCacheKey);\n    return newCacheKey;\n}\nfunction createSeededPrefetchCacheEntry(param) {\n    let { nextUrl, tree, prefetchCache, url, data, kind } = param;\n    // The initial cache entry technically includes full data, but it isn't explicitly prefetched -- we just seed the\n    // prefetch cache so that we can skip an extra prefetch request later, since we already have the data.\n    // if the prefetch corresponds with an interception route, we use the nextUrl to prefix the cache key\n    const prefetchCacheKey = data.couldBeIntercepted ? createPrefetchCacheKey(url, kind, nextUrl) : createPrefetchCacheKey(url, kind);\n    const prefetchEntry = {\n        treeAtTimeOfPrefetch: tree,\n        data: Promise.resolve(data),\n        kind,\n        prefetchTime: Date.now(),\n        lastUsedTime: Date.now(),\n        staleTime: data.staleTime,\n        key: prefetchCacheKey,\n        status: _routerreducertypes.PrefetchCacheEntryStatus.fresh,\n        url\n    };\n    prefetchCache.set(prefetchCacheKey, prefetchEntry);\n    return prefetchEntry;\n}\n/**\n * Creates a prefetch entry entry and enqueues a fetch request to retrieve the data.\n */ function createLazyPrefetchEntry(param) {\n    let { url, kind, tree, nextUrl, prefetchCache } = param;\n    const prefetchCacheKey = createPrefetchCacheKey(url, kind);\n    // initiates the fetch request for the prefetch and attaches a listener\n    // to the promise to update the prefetch cache entry when the promise resolves (if necessary)\n    const data = _prefetchreducer.prefetchQueue.enqueue(()=>(0, _fetchserverresponse.fetchServerResponse)(url, {\n            flightRouterState: tree,\n            nextUrl,\n            prefetchKind: kind\n        }).then((prefetchResponse)=>{\n            // TODO: `fetchServerResponse` should be more tighly coupled to these prefetch cache operations\n            // to avoid drift between this cache key prefixing logic\n            // (which is currently directly influenced by the server response)\n            let newCacheKey;\n            if (prefetchResponse.couldBeIntercepted) {\n                // Determine if we need to prefix the cache key with the nextUrl\n                newCacheKey = prefixExistingPrefetchCacheEntry({\n                    url,\n                    existingCacheKey: prefetchCacheKey,\n                    nextUrl,\n                    prefetchCache\n                });\n            }\n            // If the prefetch was a cache hit, we want to update the existing cache entry to reflect that it was a full prefetch.\n            // This is because we know that a static response will contain the full RSC payload, and can be updated to respect the `static`\n            // staleTime.\n            if (prefetchResponse.prerendered) {\n                const existingCacheEntry = prefetchCache.get(newCacheKey != null ? newCacheKey : prefetchCacheKey);\n                if (existingCacheEntry) {\n                    existingCacheEntry.kind = _routerreducertypes.PrefetchKind.FULL;\n                    if (prefetchResponse.staleTime !== -1) {\n                        // This is the stale time that was collected by the server during\n                        // static generation. Use this in place of the default stale time.\n                        existingCacheEntry.staleTime = prefetchResponse.staleTime;\n                    }\n                }\n            }\n            return prefetchResponse;\n        }));\n    const prefetchEntry = {\n        treeAtTimeOfPrefetch: tree,\n        data,\n        kind,\n        prefetchTime: Date.now(),\n        lastUsedTime: null,\n        staleTime: -1,\n        key: prefetchCacheKey,\n        status: _routerreducertypes.PrefetchCacheEntryStatus.fresh,\n        url\n    };\n    prefetchCache.set(prefetchCacheKey, prefetchEntry);\n    return prefetchEntry;\n}\nfunction prunePrefetchCache(prefetchCache) {\n    for (const [href, prefetchCacheEntry] of prefetchCache){\n        if (getPrefetchEntryCacheStatus(prefetchCacheEntry) === _routerreducertypes.PrefetchCacheEntryStatus.expired) {\n            prefetchCache.delete(href);\n        }\n    }\n}\nconst DYNAMIC_STALETIME_MS = Number(\"0\") * 1000;\nconst STATIC_STALETIME_MS = Number(\"300\") * 1000;\nfunction getPrefetchEntryCacheStatus(param) {\n    let { kind, prefetchTime, lastUsedTime } = param;\n    // We will re-use the cache entry data for up to the `dynamic` staletime window.\n    if (Date.now() < (lastUsedTime != null ? lastUsedTime : prefetchTime) + DYNAMIC_STALETIME_MS) {\n        return lastUsedTime ? _routerreducertypes.PrefetchCacheEntryStatus.reusable : _routerreducertypes.PrefetchCacheEntryStatus.fresh;\n    }\n    // For \"auto\" prefetching, we'll re-use only the loading boundary for up to `static` staletime window.\n    // A stale entry will only re-use the `loading` boundary, not the full data.\n    // This will trigger a \"lazy fetch\" for the full data.\n    if (kind === _routerreducertypes.PrefetchKind.AUTO) {\n        if (Date.now() < prefetchTime + STATIC_STALETIME_MS) {\n            return _routerreducertypes.PrefetchCacheEntryStatus.stale;\n        }\n    }\n    // for \"full\" prefetching, we'll re-use the cache entry data for up to `static` staletime window.\n    if (kind === _routerreducertypes.PrefetchKind.FULL) {\n        if (Date.now() < prefetchTime + STATIC_STALETIME_MS) {\n            return _routerreducertypes.PrefetchCacheEntryStatus.reusable;\n        }\n    }\n    return _routerreducertypes.PrefetchCacheEntryStatus.expired;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=prefetch-cache-utils.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE1LjUuMTJfcmVhY3QtZG9tQDE5LjIuNF9yZWFjdEAxOS4yLjRfX3JlYWN0QDE5LjIuNC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3ByZWZldGNoLWNhY2hlLXV0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztJQTRZYUEsb0JBQW9CO2VBQXBCQTs7SUFHQUMsbUJBQW1CO2VBQW5CQTs7SUFuSUdDLDhCQUE4QjtlQUE5QkE7O0lBOUdBQyw2QkFBNkI7ZUFBN0JBOztJQStOQUMsa0JBQWtCO2VBQWxCQTs7O2lEQTFYVDtnREFNQTs2Q0FDdUI7QUFFOUIsTUFBTUMsZ0NBQWdDO0FBVXRDOzs7Ozs7Q0FNQyxHQUNELFNBQVNDLDJCQUNQQyxHQUFRLEVBQ1JDLG1CQUE0QixFQUM1QkMsTUFBc0I7SUFFdEIsZ0ZBQWdGO0lBQ2hGLGdGQUFnRjtJQUNoRixrQkFBa0I7SUFDbEIsSUFBSUMsa0JBQWtCSCxJQUFJSSxRQUFRO0lBRWxDLDRGQUE0RjtJQUM1Riw4REFBOEQ7SUFDOUQscUZBQXFGO0lBQ3JGLGdGQUFnRjtJQUNoRixxREFBcUQ7SUFDckQsSUFBSUgscUJBQXFCO1FBQ3ZCLDBFQUEwRTtRQUMxRSxrRkFBa0Y7UUFDbEYsNENBQTRDO1FBQzVDRSxtQkFBbUJILElBQUlLLE1BQU07SUFDL0I7SUFFQSxJQUFJSCxRQUFRO1FBQ1YsT0FBUSxLQUFFQSxTQUFTSixnQ0FBZ0NLO0lBQ3JEO0lBRUEsT0FBT0E7QUFDVDtBQUVBLFNBQVNHLHVCQUNQTixHQUFRLEVBQ1JPLElBQThCLEVBQzlCQyxPQUF1QjtJQUV2QixPQUFPVCwyQkFBMkJDLEtBQUtPLFNBQVNFLG9CQUFBQSxZQUFZLENBQUNDLElBQUksRUFBRUY7QUFDckU7QUFFQSxTQUFTRyxzQkFDUFgsR0FBUSxFQUNSTyxJQUEyQyxFQUMzQ0MsT0FBc0IsRUFDdEJJ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RztJQUNqRyxJQUFJekUsU0FBU0Usb0JBQUFBLFlBQVksQ0FBQ0MsSUFBSSxFQUFFO1FBQzlCLElBQUlrRCxLQUFLQyxHQUFHLEtBQUtGLGVBQWVqRSxxQkFBcUI7WUFDbkQsT0FBT3NFLG9CQUFBQSx3QkFBd0IsQ0FBQ2MsUUFBUTtRQUMxQztJQUNGO0lBRUEsT0FBT2Qsb0JBQUFBLHdCQUF3QixDQUFDVSxPQUFPO0FBQ3pDIiwic291cmNlcyI6WyIvVXNlcnMvc3JjL2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3ByZWZldGNoLWNhY2hlLXV0aWxzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIGZldGNoU2VydmVyUmVzcG9uc2UsXG4gIHR5cGUgRmV0Y2hTZXJ2ZXJSZXNwb25zZVJlc3VsdCxcbn0gZnJvbSAnLi9mZXRjaC1zZXJ2ZXItcmVzcG9uc2UnXG5pbXBvcnQge1xuICBQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMsXG4gIHR5cGUgUHJlZmV0Y2hDYWNoZUVudHJ5LFxuICBQcmVmZXRjaEtpbmQsXG4gIHR5cGUgUmVhZG9ubHlSZWR1Y2VyU3RhdGUsXG59IGZyb20gJy4vcm91dGVyLXJlZHVjZXItdHlwZXMnXG5pbXBvcnQgeyBwcmVmZXRjaFF1ZXVlIH0gZnJvbSAnLi9yZWR1Y2Vycy9wcmVmZXRjaC1yZWR1Y2VyJ1xuXG5jb25zdCBJTlRFUkNFUFRJT05fQ0FDSEVfS0VZX01BUktFUiA9ICclJ1xuXG5leHBvcnQgdHlwZSBBbGlhc2VkUHJlZmV0Y2hDYWNoZUVudHJ5ID0gUHJlZmV0Y2hDYWNoZUVudHJ5ICYge1xuICAvKiogVGhpcyBpcyBhIHNwZWNpYWwgcHJvcGVydHkgdGhhdCBpbmRpY2F0ZXMgYSBwcmVmZXRjaCBlbnRyeSBhc3NvY2lhdGVkIHdpdGggYSBkaWZmZXJlbnQgVVJMXG4gICAqIHdhcyByZXR1cm5lZCByYXRoZXIgdGhhbiB0aGUgcmVxdWVzdGVkIFVSTC4gVGhpcyBzaWduYWxzIHRvIHRoZSByb3V0ZXIgdGhhdCBpdCBzaG91bGQgb25seVxuICAgKiBhcHBseSB0aGUgcGFydCB0aGF0IGRvZXNuJ3QgZGVwZW5kIG9uIHNlYXJjaFBhcmFtcyAoc3BlY2lmaWNhbGx5IHRoZSBsb2FkaW5nIHN0YXRlKS5cbiAgICovXG4gIGFsaWFzZWQ/OiBib29sZWFuXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNhY2hlIGtleSBmb3IgdGhlIHJvdXRlciBwcmVmZXRjaCBjYWNoZVxuICpcbiAqIEBwYXJhbSB1cmwgLSBUaGUgVVJMIGJlaW5nIG5hdmlnYXRlZCB0b1xuICogQHBhcmFtIG5leHRVcmwgLSBhbiBpbnRlcm5hbCBVUkwsIHByaW1hcmlseSB1c2VkIGZvciBoYW5kbGluZyByZXdyaXRlcy4gRGVmYXVsdHMgdG8gJy8nLlxuICogQHJldHVybiBUaGUgZ2VuZXJhdGVkIHByZWZldGNoIGNhY2hlIGtleS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUHJlZmV0Y2hDYWNoZUtleUltcGwoXG4gIHVybDogVVJMLFxuICBpbmNsdWRlU2VhcmNoUGFyYW1zOiBib29sZWFuLFxuICBwcmVmaXg/OiBzdHJpbmcgfCBudWxsXG4pIHtcbiAgLy8gSW5pdGlhbGx5IHdlIG9ubHkgdXNlIHRoZSBwYXRobmFtZSBhcyB0aGUgY2FjaGUga2V5LiBXZSBkb24ndCB3YW50IHRvIGluY2x1ZGVcbiAgLy8gc2VhcmNoIHBhcmFtcyBzbyB0aGF0IG11bHRpcGxlIFVSTHMgd2l0aCB0aGUgc2FtZSBzZWFyY2ggcGFyYW1ldGVyIGNhbiByZS11c2VcbiAgLy8gbG9hZGluZyBzdGF0ZXMuXG4gIGxldCBwYXRobmFtZUZyb21VcmwgPSB1cmwucGF0aG5hbWVcblxuICAvLyBSU0MgcmVzcG9uc2VzIGNhbiBkaWZmZXIgYmFzZWQgb24gc2VhcmNoIHBhcmFtcywgc3BlY2lmaWNhbGx5IGluIHRoZSBjYXNlIHdoZXJlIHdlIGFyZW4ndFxuICAvLyByZXR1cm5pbmcgYSBwYXJ0aWFsIHJlc3BvbnNlIChpZSB3aXRoIGBQcmVmZXRjaEtpbmQuQVVUT2ApLlxuICAvLyBJbiB0aGUgYXV0byBjYXNlLCBzaW5jZSBsb2FkaW5nLmpzICYgbGF5b3V0LmpzIHdvbid0IGhhdmUgYWNjZXNzIHRvIHNlYXJjaCBwYXJhbXMsXG4gIC8vIHdlIGNhbiBzYWZlbHkgcmUtdXNlIHRoYXQgY2FjaGUgZW50cnkuIEJ1dCBmb3IgZnVsbCBwcmVmZXRjaGVzLCB3ZSBzaG91bGQgbm90XG4gIC8vIHJlLXVzZSB0aGUgY2FjaGUgZW50cnkgYXMgdGhlIHJlc3BvbnNlIG1heSBkaWZmZXIuXG4gIGlmIChpbmNsdWRlU2VhcmNoUGFyYW1zKSB7XG4gICAgLy8gaWYgd2UgaGF2ZSBhIGZ1bGwgcHJlZmV0Y2gsIHdlIGNhbiBpbmNsdWRlIHRoZSBzZWFyY2ggcGFyYW0gaW4gdGhlIGtleSxcbiAgICAvLyBhcyB3ZSdsbCBiZSBnZXR0aW5nIGJhY2sgYSBmdWxsIHJlc3BvbnNlLiBUaGUgc2VydmVyIG1pZ2h0IGhhdmUgcmVhZCB0aGUgc2VhcmNoXG4gICAgLy8gcGFyYW1zIHdoZW4gZ2VuZXJhdGluZyB0aGUgZnVsbCByZXNwb25zZS5cbiAgICBwYXRobmFtZUZyb21VcmwgKz0gdXJsLnNlYXJjaFxuICB9XG5cbiAgaWYgKHByZWZpeCkge1xuICAgIHJldHVybiBgJHtwcmVmaXh9JHtJTlRFUkNFUFRJT05fQ0FDSEVfS0VZX01BUktFUn0ke3BhdGhuYW1lRnJvbVVybH1gXG4gIH1cblxuICByZXR1cm4gcGF0aG5hbWVGcm9tVXJsXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVByZWZldGNoQ2FjaGVLZXkoXG4gIHVybDogVVJMLFxuICBraW5kOiBQcmVmZXRjaEtpbmQgfCB1bmRlZmluZWQsXG4gIG5leHRVcmw/OiBzdHJpbmcgfCBudWxsXG4pIHtcbiAgcmV0dXJuIGNyZWF0ZVByZWZldGNoQ2FjaGVLZXlJbXBsKHVybCwga2luZCA9PT0gUHJlZmV0Y2hLaW5kLkZVTEwsIG5leHRVcmwpXG59XG5cbmZ1bmN0aW9uIGdldEV4aXN0aW5nQ2FjaGVFbnRyeShcbiAgdXJsOiBVUkwsXG4gIGtpbmQ6IFByZWZldGNoS2luZCA9IFByZWZldGNoS2luZC5URU1QT1JBUlksXG4gIG5leHRVcmw6IHN0cmluZyB8IG51bGwsXG4gIHByZWZldGNoQ2FjaGU6IE1hcDxzdHJpbmcsIFByZWZldGNoQ2FjaGVFbnRyeT4sXG4gIGFsbG93QWxpYXNpbmc6IGJvb2xlYW5cbik6IEFsaWFzZWRQcmVmZXRjaENhY2hlRW50cnkgfCB1bmRlZmluZWQge1xuICAvLyBXZSBmaXJzdCBjaGVjayBpZiB0aGVyZSdzIGEgbW9yZSBzcGVjaWZpYyBpbnRlcmNlcHRpb24gcm91dGUgcHJlZmV0Y2ggZW50cnlcbiAgLy8gVGhpcyBpcyBiZWNhdXNlIHdoZW4gd2UgZGV0ZWN0IGEgcHJlZmV0Y2ggdGhhdCBjb3JyZXNwb25kcyB3aXRoIGFuIGludGVyY2VwdGlvbiByb3V0ZSwgd2UgcHJlZml4IGl0IHdpdGggbmV4dFVybCAoc2VlIGBjcmVhdGVQcmVmZXRjaENhY2hlS2V5YClcbiAgLy8gdG8gYXZvaWQgY29uZmxpY3RzIHdpdGggb3RoZXIgcGFnZXMgdGhhdCBtYXkgaGF2ZSB0aGUgc2FtZSBVUkwgYnV0IHJlbmRlciBkaWZmZXJlbnQgdGhpbmdzIGRlcGVuZGluZyBvbiB0aGUgYE5leHQtVVJMYCBoZWFkZXIuXG4gIGZvciAoY29uc3QgbWF5YmVOZXh0VXJsIG9mIFtuZXh0VXJsLCBudWxsXSkge1xuICAgIGNvbnN0IGNhY2hlS2V5V2l0aFBhcmFtcyA9IGNyZWF0ZVByZWZldGNoQ2FjaGVLZXlJbXBsKFxuICAgICAgdXJsLFxuICAgICAgdHJ1ZSxcbiAgICAgIG1heWJlTmV4dFVybFxuICAgIClcbiAgICBjb25zdCBjYWNoZUtleVdpdGhvdXRQYXJhbXMgPSBjcmVhdGVQcmVmZXRjaENhY2hlS2V5SW1wbChcbiAgICAgIHVybCxcbiAgICAgIGZhbHNlLFxuICAgICAgbWF5YmVOZXh0VXJsXG4gICAgKVxuXG4gICAgLy8gRmlyc3QsIHdlIGNoZWNrIGlmIHdlIGhhdmUgYSBjYWNoZSBlbnRyeSB0aGF0IGV4YWN0bHkgbWF0Y2hlcyB0aGUgVVJMXG4gICAgY29uc3QgY2FjaGVLZXlUb1VzZSA9IHVybC5zZWFyY2hcbiAgICAgID8gY2FjaGVLZXlXaXRoUGFyYW1zXG4gICAgICA6IGNhY2hlS2V5V2l0aG91dFBhcmFtc1xuXG4gICAgY29uc3QgZXhpc3RpbmdFbnRyeSA9IHByZWZldGNoQ2FjaGUuZ2V0KGNhY2hlS2V5VG9Vc2UpXG4gICAgaWYgKGV4aXN0aW5nRW50cnkgJiYgYWxsb3dBbGlhc2luZykge1xuICAgICAgLy8gV2Uga25vdyB3ZSdyZSByZXR1cm5pbmcgYW4gYWxpYXNlZCBlbnRyeSB3aGVuIHRoZSBwYXRobmFtZSBtYXRjaGVzIGJ1dCB0aGUgc2VhcmNoIHBhcmFtcyBkb24ndCxcbiAgICAgIGNvbnN0IGlzQWxpYXNlZCA9XG4gICAgICAgIGV4aXN0aW5nRW50cnkudXJsLnBhdGhuYW1lID09PSB1cmwucGF0aG5hbWUgJiZcbiAgICAgICAgZXhpc3RpbmdFbnRyeS51cmwuc2VhcmNoICE9PSB1cmwuc2VhcmNoXG5cbiAgICAgIGlmIChpc0FsaWFzZWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5leGlzdGluZ0VudHJ5LFxuICAgICAgICAgIGFsaWFzZWQ6IHRydWUsXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGV4aXN0aW5nRW50cnlcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgcmVxdWVzdCBjb250YWlucyBzZWFyY2ggcGFyYW1zLCBhbmQgd2UncmUgbm90IGRvaW5nIGEgZnVsbCBwcmVmZXRjaCwgd2UgY2FuIHJldHVybiB0aGVcbiAgICAvLyBwYXJhbS1sZXNzIGVudHJ5IGlmIGl0IGV4aXN0cy5cbiAgICAvLyBUaGlzIGlzIHRlY2huaWNhbGx5IGNvdmVyZWQgYnkgdGhlIGNoZWNrIGF0IHRoZSBib3R0b20gb2YgdGhpcyBmdW5jdGlvbiwgd2hpY2ggaXRlcmF0ZXMgb3ZlciBjYWNoZSBlbnRyaWVzLFxuICAgIC8vIGJ1dCBsZXRzIHVzIGFycml2ZSB0aGVyZSBxdWlja2VyIGluIHRoZSBwYXJhbS1mdWxsIGNhc2UuXG4gICAgY29uc3QgZW50cnlXaXRob3V0UGFyYW1zID0gcHJlZmV0Y2hDYWNoZS5nZXQoY2FjaGVLZXlXaXRob3V0UGFyYW1zKVxuICAgIGlmIChcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAnZGV2ZWxvcG1lbnQnICYmXG4gICAgICBhbGxvd0FsaWFzaW5nICYmXG4gICAgICB1cmwuc2VhcmNoICYmXG4gICAgICBraW5kICE9PSBQcmVmZXRjaEtpbmQuRlVMTCAmJlxuICAgICAgZW50cnlXaXRob3V0UGFyYW1zICYmXG4gICAgICAvLyBXZSBzaG91bGRuJ3QgcmV0dXJuIHRoZSBhbGlhc2VkIGVudHJ5IGlmIGl0IHdhcyByZWxvY2F0ZWQgdG8gYSBuZXcgY2FjaGUga2V5LlxuICAgICAgLy8gU2luY2UgaXQncyByZXdyaXR0ZW4sIGl0IGNvdWxkIHJlc3BvbmQgd2l0aCBhIGNvbXBsZXRlbHkgZGlmZmVyZW50IGxvYWRpbmcgc3RhdGUuXG4gICAgICAhZW50cnlXaXRob3V0UGFyYW1zLmtleS5pbmNsdWRlcyhJTlRFUkNFUFRJT05fQ0FDSEVfS0VZX01BUktFUilcbiAgICApIHtcbiAgICAgIHJldHVybiB7IC4uLmVudHJ5V2l0aG91dFBhcmFtcywgYWxpYXNlZDogdHJ1ZSB9XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgd2UndmUgZ290dGVuIHRvIHRoaXMgcG9pbnQsIHdlIGRpZG4ndCBmaW5kIGEgc3BlY2lmaWMgY2FjaGUgZW50cnkgdGhhdCBtYXRjaGVkXG4gIC8vIHRoZSByZXF1ZXN0IFVSTC5cbiAgLy8gV2UgYXR0ZW1wdCBhIHBhcnRpYWwgbWF0Y2ggYnkgY2hlY2tpbmcgaWYgdGhlcmUncyBhIGNhY2hlIGVudHJ5IHdpdGggdGhlIHNhbWUgcGF0aG5hbWUuXG4gIC8vIFJlZ2FyZGxlc3Mgb2Ygd2hhdCB3ZSBmaW5kLCBzaW5jZSBpdCBkb2Vzbid0IGNvcnJlc3BvbmQgd2l0aCB0aGUgcmVxdWVzdGVkIFVSTCwgd2UnbGwgbWFyayBpdCBcImFsaWFzZWRcIi5cbiAgLy8gVGhpcyB3aWxsIHNpZ25hbCB0byB0aGUgcm91dGVyIHRoYXQgaXQgc2hvdWxkIG9ubHkgYXBwbHkgdGhlIGxvYWRpbmcgc3RhdGUgb24gdGhlIHByZWZldGNoZWQgZGF0YS5cbiAgaWYgKFxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAnZGV2ZWxvcG1lbnQnICYmXG4gICAga2luZCAhPT0gUHJlZmV0Y2hLaW5kLkZVTEwgJiZcbiAgICBhbGxvd0FsaWFzaW5nXG4gICkge1xuICAgIGZvciAoY29uc3QgY2FjaGVFbnRyeSBvZiBwcmVmZXRjaENhY2hlLnZhbHVlcygpKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGNhY2hlRW50cnkudXJsLnBhdGhuYW1lID09PSB1cmwucGF0aG5hbWUgJiZcbiAgICAgICAgLy8gV2Ugc2hvdWxkbid0IHJldHVybiB0aGUgYWxpYXNlZCBlbnRyeSBpZiBpdCB3YXMgcmVsb2NhdGVkIHRvIGEgbmV3IGNhY2hlIGtleS5cbiAgICAgICAgLy8gU2luY2UgaXQncyByZXdyaXR0ZW4sIGl0IGNvdWxkIHJlc3BvbmQgd2l0aCBhIGNvbXBsZXRlbHkgZGlmZmVyZW50IGxvYWRpbmcgc3RhdGUuXG4gICAgICAgICFjYWNoZUVudHJ5LmtleS5pbmNsdWRlcyhJTlRFUkNFUFRJT05fQ0FDSEVfS0VZX01BUktFUilcbiAgICAgICkge1xuICAgICAgICByZXR1cm4geyAuLi5jYWNoZUVudHJ5LCBhbGlhc2VkOiB0cnVlIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkXG59XG5cbi8qKlxuICogUmV0dXJucyBhIHByZWZldGNoIGNhY2hlIGVudHJ5IGlmIG9uZSBleGlzdHMuIE90aGVyd2lzZSBjcmVhdGVzIGEgbmV3IG9uZSBhbmQgZW5xdWV1ZXMgYSBmZXRjaCByZXF1ZXN0XG4gKiB0byByZXRyaWV2ZSB0aGUgcHJlZmV0Y2ggZGF0YSBmcm9tIHRoZSBzZXJ2ZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRPckNyZWF0ZVByZWZldGNoQ2FjaGVFbnRyeSh7XG4gIHVybCxcbiAgbmV4dFVybCxcbiAgdHJlZSxcbiAgcHJlZmV0Y2hDYWNoZSxcbiAga2luZCxcbiAgYWxsb3dBbGlhc2luZyA9IHRydWUsXG59OiBQaWNrPFJlYWRvbmx5UmVkdWNlclN0YXRlLCAnbmV4dFVybCcgfCAncHJlZmV0Y2hDYWNoZScgfCAndHJlZSc+ICYge1xuICB1cmw6IFVSTFxuICBraW5kPzogUHJlZmV0Y2hLaW5kXG4gIGFsbG93QWxpYXNpbmc6IGJvb2xlYW5cbn0pOiBBbGlhc2VkUHJlZmV0Y2hDYWNoZUVudHJ5IHtcbiAgY29uc3QgZXhpc3RpbmdDYWNoZUVudHJ5ID0gZ2V0RXhpc3RpbmdDYWNoZUVudHJ5KFxuICAgIHVybCxcbiAgICBraW5kLFxuICAgIG5leHRVcmwsXG4gICAgcHJlZmV0Y2hDYWNoZSxcbiAgICBhbGxvd0FsaWFzaW5nXG4gIClcblxuICBpZiAoZXhpc3RpbmdDYWNoZUVudHJ5KSB7XG4gICAgLy8gR3JhYiB0aGUgbGF0ZXN0IHN0YXR1cyBvZiB0aGUgY2FjaGUgZW50cnkgYW5kIHVwZGF0ZSBpdFxuICAgIGV4aXN0aW5nQ2FjaGVFbnRyeS5zdGF0dXMgPSBnZXRQcmVmZXRjaEVudHJ5Q2FjaGVTdGF0dXMoZXhpc3RpbmdDYWNoZUVudHJ5KVxuXG4gICAgLy8gd2hlbiBga2luZGAgaXMgcHJvdmlkZWQsIGFuIGV4cGxpY2l0IHByZWZldGNoIHdhcyByZXF1ZXN0ZWQuXG4gICAgLy8gaWYgdGhlIHJlcXVlc3RlZCBwcmVmZXRjaCBpcyBcImZ1bGxcIiBhbmQgdGhlIGN1cnJlbnQgY2FjaGUgZW50cnkgd2Fzbid0LCB3ZSB3YW50IHRvIHJlLXByZWZldGNoIHdpdGggdGhlIG5ldyBpbnRlbnRcbiAgICBjb25zdCBzd2l0Y2hlZFRvRnVsbFByZWZldGNoID1cbiAgICAgIGV4aXN0aW5nQ2FjaGVFbnRyeS5raW5kICE9PSBQcmVmZXRjaEtpbmQuRlVMTCAmJlxuICAgICAga2luZCA9PT0gUHJlZmV0Y2hLaW5kLkZVTExcblxuICAgIGlmIChzd2l0Y2hlZFRvRnVsbFByZWZldGNoKSB7XG4gICAgICAvLyBJZiB3ZSBzd2l0Y2hlZCB0byBhIGZ1bGwgcHJlZmV0Y2gsIHZhbGlkYXRlIHRoYXQgdGhlIGV4aXN0aW5nIGNhY2hlIGVudHJ5IGNvbnRhaW5lZCBwYXJ0aWFsIGRhdGEuXG4gICAgICAvLyBJdCdzIHBvc3NpYmxlIHRoYXQgdGhlIGNhY2hlIGVudHJ5IHdhcyBzZWVkZWQgd2l0aCBmdWxsIGRhdGEgYnV0IGhhcyBhIGNhY2hlIHR5cGUgb2YgXCJhdXRvXCIgKGllIHdoZW4gY2FjaGUgZW50cmllc1xuICAgICAgLy8gYXJlIHNlZWRlZCBidXQgd2l0aG91dCBhIHByZWZldGNoIGludGVudClcbiAgICAgIGV4aXN0aW5nQ2FjaGVFbnRyeS5kYXRhLnRoZW4oKHByZWZldGNoUmVzcG9uc2UpID0+IHtcbiAgICAgICAgY29uc3QgaXNGdWxsUHJlZmV0Y2ggPVxuICAgICAgICAgIEFycmF5LmlzQXJyYXkocHJlZmV0Y2hSZXNwb25zZS5mbGlnaHREYXRhKSAmJlxuICAgICAgICAgIHByZWZldGNoUmVzcG9uc2UuZmxpZ2h0RGF0YS5zb21lKChmbGlnaHREYXRhKSA9PiB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBzdGFydGVkIHJlbmRlcmluZyBmcm9tIHRoZSByb290IGFuZCB3ZSByZXR1cm5lZCBSU0MgZGF0YSAoc2VlZERhdGEpLCB3ZSBhbHJlYWR5IGhhZCBhIGZ1bGwgcHJlZmV0Y2guXG4gICAgICAgICAgICByZXR1cm4gZmxpZ2h0RGF0YS5pc1Jvb3RSZW5kZXIgJiYgZmxpZ2h0RGF0YS5zZWVkRGF0YSAhPT0gbnVsbFxuICAgICAgICAgIH0pXG5cbiAgICAgICAgaWYgKCFpc0Z1bGxQcmVmZXRjaCkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVMYXp5UHJlZmV0Y2hFbnRyeSh7XG4gICAgICAgICAgICB0cmVlLFxuICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgbmV4dFVybCxcbiAgICAgICAgICAgIHByZWZldGNoQ2FjaGUsXG4gICAgICAgICAgICAvLyBJZiB3ZSBkaWRuJ3QgZ2V0IGFuIGV4cGxpY2l0IHByZWZldGNoIGtpbmQsIHdlIHdhbnQgdG8gc2V0IGEgdGVtcG9yYXJ5IGtpbmRcbiAgICAgICAgICAgIC8vIHJhdGhlciB0aGFuIGFzc3VtaW5nIHRoZSBzYW1lIGludGVudCBhcyB0aGUgcHJldmlvdXMgZW50cnksIHRvIGJlIGNvbnNpc3RlbnQgd2l0aCBob3cgd2VcbiAgICAgICAgICAgIC8vIGxhemlseSBjcmVhdGUgcHJlZmV0Y2ggZW50cmllcyB3aGVuIGludGVudCBpcyBsZWZ0IHVuc3BlY2lmaWVkLlxuICAgICAgICAgICAga2luZDoga2luZCA/PyBQcmVmZXRjaEtpbmQuVEVNUE9SQVJZLFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGV4aXN0aW5nIGNhY2hlIGVudHJ5IHdhcyBtYXJrZWQgYXMgdGVtcG9yYXJ5LCBpdCBtZWFucyBpdCB3YXMgbGF6aWx5IGNyZWF0ZWQgd2hlbiBhdHRlbXB0aW5nIHRvIGdldCBhbiBlbnRyeSxcbiAgICAvLyB3aGVyZSB3ZSBkaWRuJ3QgaGF2ZSB0aGUgcHJlZmV0Y2ggaW50ZW50LiBOb3cgdGhhdCB3ZSBoYXZlIHRoZSBpbnRlbnQgKGluIGBraW5kYCksIHdlIHdhbnQgdG8gdXBkYXRlIHRoZSBlbnRyeSB0byB0aGUgbW9yZSBhY2N1cmF0ZSBraW5kLlxuICAgIGlmIChraW5kICYmIGV4aXN0aW5nQ2FjaGVFbnRyeS5raW5kID09PSBQcmVmZXRjaEtpbmQuVEVNUE9SQVJZKSB7XG4gICAgICBleGlzdGluZ0NhY2hlRW50cnkua2luZCA9IGtpbmRcbiAgICB9XG5cbiAgICAvLyBXZSd2ZSBkZXRlcm1pbmVkIHRoYXQgdGhlIGV4aXN0aW5nIGVudHJ5IHdlIGZvdW5kIGlzIHN0aWxsIHZhbGlkLCBzbyB3ZSByZXR1cm4gaXQuXG4gICAgcmV0dXJuIGV4aXN0aW5nQ2FjaGVFbnRyeVxuICB9XG5cbiAgLy8gSWYgd2UgZGlkbid0IHJldHVybiBhbiBlbnRyeSwgY3JlYXRlIGEgbmV3IG9uZS5cbiAgcmV0dXJuIGNyZWF0ZUxhenlQcmVmZXRjaEVudHJ5KHtcbiAgICB0cmVlLFxuICAgIHVybCxcbiAgICBuZXh0VXJsLFxuICAgIHByZWZldGNoQ2FjaGUsXG4gICAga2luZDoga2luZCB8fCBQcmVmZXRjaEtpbmQuVEVNUE9SQVJZLFxuICB9KVxufVxuXG4vKlxuICogVXNlZCB0byB0YWtlIGFuIGV4aXN0aW5nIGNhY2hlIGVudHJ5IGFuZCBwcmVmaXggaXQgd2l0aCB0aGUgbmV4dFVybCwgaWYgaXQgZXhpc3RzLlxuICogVGhpcyBlbnN1cmVzIHRoYXQgd2UgZG9uJ3QgaGF2ZSBjb25mbGljdGluZyBjYWNoZSBlbnRyaWVzIGZvciB0aGUgc2FtZSBVUkwgKGFzIGlzIHRoZSBjYXNlIHdpdGggcm91dGUgaW50ZXJjZXB0aW9uKS5cbiAqL1xuZnVuY3Rpb24gcHJlZml4RXhpc3RpbmdQcmVmZXRjaENhY2hlRW50cnkoe1xuICB1cmwsXG4gIG5leHRVcmwsXG4gIHByZWZldGNoQ2FjaGUsXG4gIGV4aXN0aW5nQ2FjaGVLZXksXG59OiBQaWNrPFJlYWRvbmx5UmVkdWNlclN0YXRlLCAnbmV4dFVybCcgfCAncHJlZmV0Y2hDYWNoZSc+ICYge1xuICB1cmw6IFVSTFxuICBleGlzdGluZ0NhY2hlS2V5OiBzdHJpbmdcbn0pIHtcbiAgY29uc3QgZXhpc3RpbmdDYWNoZUVudHJ5ID0gcHJlZmV0Y2hDYWNoZS5nZXQoZXhpc3RpbmdDYWNoZUtleSlcbiAgaWYgKCFleGlzdGluZ0NhY2hlRW50cnkpIHtcbiAgICAvLyBuby1vcCAtLSB0aGVyZSB3YXNuJ3QgYW4gZW50cnkgdG8gbW92ZVxuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3QgbmV3Q2FjaGVLZXkgPSBjcmVhdGVQcmVmZXRjaENhY2hlS2V5KFxuICAgIHVybCxcbiAgICBleGlzdGluZ0NhY2hlRW50cnkua2luZCxcbiAgICBuZXh0VXJsXG4gIClcbiAgcHJlZmV0Y2hDYWNoZS5zZXQobmV3Q2FjaGVLZXksIHsgLi4uZXhpc3RpbmdDYWNoZUVudHJ5LCBrZXk6IG5ld0NhY2hlS2V5IH0pXG4gIHByZWZldGNoQ2FjaGUuZGVsZXRlKGV4aXN0aW5nQ2FjaGVLZXkpXG5cbiAgcmV0dXJuIG5ld0NhY2hlS2V5XG59XG5cbi8qKlxuICogVXNlIHRvIHNlZWQgdGhlIHByZWZldGNoIGNhY2hlIHdpdGggZGF0YSB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gZmV0Y2hlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNlZWRlZFByZWZldGNoQ2FjaGVFbnRyeSh7XG4gIG5leHRVcmwsXG4gIHRyZWUsXG4gIHByZWZldGNoQ2FjaGUsXG4gIHVybCxcbiAgZGF0YSxcbiAga2luZCxcbn06IFBpY2s8UmVhZG9ubHlSZWR1Y2VyU3RhdGUsICduZXh0VXJsJyB8ICd0cmVlJyB8ICdwcmVmZXRjaENhY2hlJz4gJiB7XG4gIHVybDogVVJMXG4gIGRhdGE6IEZldGNoU2VydmVyUmVzcG9uc2VSZXN1bHRcbiAga2luZDogUHJlZmV0Y2hLaW5kXG59KSB7XG4gIC8vIFRoZSBpbml0aWFsIGNhY2hlIGVudHJ5IHRlY2huaWNhbGx5IGluY2x1ZGVzIGZ1bGwgZGF0YSwgYnV0IGl0IGlzbid0IGV4cGxpY2l0bHkgcHJlZmV0Y2hlZCAtLSB3ZSBqdXN0IHNlZWQgdGhlXG4gIC8vIHByZWZldGNoIGNhY2hlIHNvIHRoYXQgd2UgY2FuIHNraXAgYW4gZXh0cmEgcHJlZmV0Y2ggcmVxdWVzdCBsYXRlciwgc2luY2Ugd2UgYWxyZWFkeSBoYXZlIHRoZSBkYXRhLlxuICAvLyBpZiB0aGUgcHJlZmV0Y2ggY29ycmVzcG9uZHMgd2l0aCBhbiBpbnRlcmNlcHRpb24gcm91dGUsIHdlIHVzZSB0aGUgbmV4dFVybCB0byBwcmVmaXggdGhlIGNhY2hlIGtleVxuICBjb25zdCBwcmVmZXRjaENhY2hlS2V5ID0gZGF0YS5jb3VsZEJlSW50ZXJjZXB0ZWRcbiAgICA/IGNyZWF0ZVByZWZldGNoQ2FjaGVLZXkodXJsLCBraW5kLCBuZXh0VXJsKVxuICAgIDogY3JlYXRlUHJlZmV0Y2hDYWNoZUtleSh1cmwsIGtpbmQpXG5cbiAgY29uc3QgcHJlZmV0Y2hFbnRyeSA9IHtcbiAgICB0cmVlQXRUaW1lT2ZQcmVmZXRjaDogdHJlZSxcbiAgICBkYXRhOiBQcm9taXNlLnJlc29sdmUoZGF0YSksXG4gICAga2luZCxcbiAgICBwcmVmZXRjaFRpbWU6IERhdGUubm93KCksXG4gICAgbGFzdFVzZWRUaW1lOiBEYXRlLm5vdygpLFxuICAgIHN0YWxlVGltZTogZGF0YS5zdGFsZVRpbWUsXG4gICAga2V5OiBwcmVmZXRjaENhY2hlS2V5LFxuICAgIHN0YXR1czogUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzLmZyZXNoLFxuICAgIHVybCxcbiAgfSBzYXRpc2ZpZXMgUHJlZmV0Y2hDYWNoZUVudHJ5XG5cbiAgcHJlZmV0Y2hDYWNoZS5zZXQocHJlZmV0Y2hDYWNoZUtleSwgcHJlZmV0Y2hFbnRyeSlcblxuICByZXR1cm4gcHJlZmV0Y2hFbnRyeVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBwcmVmZXRjaCBlbnRyeSBlbnRyeSBhbmQgZW5xdWV1ZXMgYSBmZXRjaCByZXF1ZXN0IHRvIHJldHJpZXZlIHRoZSBkYXRhLlxuICovXG5mdW5jdGlvbiBjcmVhdGVMYXp5UHJlZmV0Y2hFbnRyeSh7XG4gIHVybCxcbiAga2luZCxcbiAgdHJlZSxcbiAgbmV4dFVybCxcbiAgcHJlZmV0Y2hDYWNoZSxcbn06IFBpY2s8UmVhZG9ubHlSZWR1Y2VyU3RhdGUsICduZXh0VXJsJyB8ICd0cmVlJyB8ICdwcmVmZXRjaENhY2hlJz4gJiB7XG4gIHVybDogVVJMXG4gIGtpbmQ6IFByZWZldGNoS2luZFxufSk6IFByZWZldGNoQ2FjaGVFbnRyeSB7XG4gIGNvbnN0IHByZWZldGNoQ2FjaGVLZXkgPSBjcmVhdGVQcmVmZXRjaENhY2hlS2V5KHVybCwga2luZClcblxuICAvLyBpbml0aWF0ZXMgdGhlIGZldGNoIHJlcXVlc3QgZm9yIHRoZSBwcmVmZXRjaCBhbmQgYXR0YWNoZXMgYSBsaXN0ZW5lclxuICAvLyB0byB0aGUgcHJvbWlzZSB0byB1cGRhdGUgdGhlIHByZWZldGNoIGNhY2hlIGVudHJ5IHdoZW4gdGhlIHByb21pc2UgcmVzb2x2ZXMgKGlmIG5lY2Vzc2FyeSlcbiAgY29uc3QgZGF0YSA9IHByZWZldGNoUXVldWUuZW5xdWV1ZSgoKSA9PlxuICAgIGZldGNoU2VydmVyUmVzcG9uc2UodXJsLCB7XG4gICAgICBmbGlnaHRSb3V0ZXJTdGF0ZTogdHJlZSxcbiAgICAgIG5leHRVcmwsXG4gICAgICBwcmVmZXRjaEtpbmQ6IGtpbmQsXG4gICAgfSkudGhlbigocHJlZmV0Y2hSZXNwb25zZSkgPT4ge1xuICAgICAgLy8gVE9ETzogYGZldGNoU2VydmVyUmVzcG9uc2VgIHNob3VsZCBiZSBtb3JlIHRpZ2hseSBjb3VwbGVkIHRvIHRoZXNlIHByZWZldGNoIGNhY2hlIG9wZXJhdGlvbnNcbiAgICAgIC8vIHRvIGF2b2lkIGRyaWZ0IGJldHdlZW4gdGhpcyBjYWNoZSBrZXkgcHJlZml4aW5nIGxvZ2ljXG4gICAgICAvLyAod2hpY2ggaXMgY3VycmVudGx5IGRpcmVjdGx5IGluZmx1ZW5jZWQgYnkgdGhlIHNlcnZlciByZXNwb25zZSlcbiAgICAgIGxldCBuZXdDYWNoZUtleVxuXG4gICAgICBpZiAocHJlZmV0Y2hSZXNwb25zZS5jb3VsZEJlSW50ZXJjZXB0ZWQpIHtcbiAgICAgICAgLy8gRGV0ZXJtaW5lIGlmIHdlIG5lZWQgdG8gcHJlZml4IHRoZSBjYWNoZSBrZXkgd2l0aCB0aGUgbmV4dFVybFxuICAgICAgICBuZXdDYWNoZUtleSA9IHByZWZpeEV4aXN0aW5nUHJlZmV0Y2hDYWNoZUVudHJ5KHtcbiAgICAgICAgICB1cmwsXG4gICAgICAgICAgZXhpc3RpbmdDYWNoZUtleTogcHJlZmV0Y2hDYWNoZUtleSxcbiAgICAgICAgICBuZXh0VXJsLFxuICAgICAgICAgIHByZWZldGNoQ2FjaGUsXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSBwcmVmZXRjaCB3YXMgYSBjYWNoZSBoaXQsIHdlIHdhbnQgdG8gdXBkYXRlIHRoZSBleGlzdGluZyBjYWNoZSBlbnRyeSB0byByZWZsZWN0IHRoYXQgaXQgd2FzIGEgZnVsbCBwcmVmZXRjaC5cbiAgICAgIC8vIFRoaXMgaXMgYmVjYXVzZSB3ZSBrbm93IHRoYXQgYSBzdGF0aWMgcmVzcG9uc2Ugd2lsbCBjb250YWluIHRoZSBmdWxsIFJTQyBwYXlsb2FkLCBhbmQgY2FuIGJlIHVwZGF0ZWQgdG8gcmVzcGVjdCB0aGUgYHN0YXRpY2BcbiAgICAgIC8vIHN0YWxlVGltZS5cbiAgICAgIGlmIChwcmVmZXRjaFJlc3BvbnNlLnByZXJlbmRlcmVkKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nQ2FjaGVFbnRyeSA9IHByZWZldGNoQ2FjaGUuZ2V0KFxuICAgICAgICAgIC8vIGlmIHdlIHByZWZpeGVkIHRoZSBjYWNoZSBrZXkgZHVlIHRvIHJvdXRlIGludGVyY2VwdGlvbiwgd2Ugd2FudCB0byB1c2UgdGhlIG5ldyBrZXkuIE90aGVyd2lzZSB3ZSB1c2UgdGhlIG9yaWdpbmFsIGtleVxuICAgICAgICAgIG5ld0NhY2hlS2V5ID8/IHByZWZldGNoQ2FjaGVLZXlcbiAgICAgICAgKVxuICAgICAgICBpZiAoZXhpc3RpbmdDYWNoZUVudHJ5KSB7XG4gICAgICAgICAgZXhpc3RpbmdDYWNoZUVudHJ5LmtpbmQgPSBQcmVmZXRjaEtpbmQuRlVMTFxuICAgICAgICAgIGlmIChwcmVmZXRjaFJlc3BvbnNlLnN0YWxlVGltZSAhPT0gLTEpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIHN0YWxlIHRpbWUgdGhhdCB3YXMgY29sbGVjdGVkIGJ5IHRoZSBzZXJ2ZXIgZHVyaW5nXG4gICAgICAgICAgICAvLyBzdGF0aWMgZ2VuZXJhdGlvbi4gVXNlIHRoaXMgaW4gcGxhY2Ugb2YgdGhlIGRlZmF1bHQgc3RhbGUgdGltZS5cbiAgICAgICAgICAgIGV4aXN0aW5nQ2FjaGVFbnRyeS5zdGFsZVRpbWUgPSBwcmVmZXRjaFJlc3BvbnNlLnN0YWxlVGltZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJlZmV0Y2hSZXNwb25zZVxuICAgIH0pXG4gIClcblxuICBjb25zdCBwcmVmZXRjaEVudHJ5ID0ge1xuICAgIHRyZWVBdFRpbWVPZlByZWZldGNoOiB0cmVlLFxuICAgIGRhdGEsXG4gICAga2luZCxcbiAgICBwcmVmZXRjaFRpbWU6IERhdGUubm93KCksXG4gICAgbGFzdFVzZWRUaW1lOiBudWxsLFxuICAgIHN0YWxlVGltZTogLTEsXG4gICAga2V5OiBwcmVmZXRjaENhY2hlS2V5LFxuICAgIHN0YXR1czogUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzLmZyZXNoLFxuICAgIHVybCxcbiAgfVxuXG4gIHByZWZldGNoQ2FjaGUuc2V0KHByZWZldGNoQ2FjaGVLZXksIHByZWZldGNoRW50cnkpXG5cbiAgcmV0dXJuIHByZWZldGNoRW50cnlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBydW5lUHJlZmV0Y2hDYWNoZShcbiAgcHJlZmV0Y2hDYWNoZTogUmVhZG9ubHlSZWR1Y2VyU3RhdGVbJ3ByZWZldGNoQ2FjaGUnXVxuKSB7XG4gIGZvciAoY29uc3QgW2hyZWYsIHByZWZldGNoQ2FjaGVFbnRyeV0gb2YgcHJlZmV0Y2hDYWNoZSkge1xuICAgIGlmIChcbiAgICAgIGdldFByZWZldGNoRW50cnlDYWNoZVN0YXR1cyhwcmVmZXRjaENhY2hlRW50cnkpID09PVxuICAgICAgUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzLmV4cGlyZWRcbiAgICApIHtcbiAgICAgIHByZWZldGNoQ2FjaGUuZGVsZXRlKGhyZWYpXG4gICAgfVxuICB9XG59XG5cbi8vIFRoZXNlIHZhbHVlcyBhcmUgc2V0IGJ5IGBkZWZpbmUtZW52LXBsdWdpbmAgKGJhc2VkIG9uIGBuZXh0Q29uZmlnLmV4cGVyaW1lbnRhbC5zdGFsZVRpbWVzYClcbi8vIGFuZCBkZWZhdWx0IHRvIDUgbWludXRlcyAoc3RhdGljKSAvIDAgc2Vjb25kcyAoZHluYW1pYylcbmV4cG9ydCBjb25zdCBEWU5BTUlDX1NUQUxFVElNRV9NUyA9XG4gIE51bWJlcihwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1JPVVRFUl9EWU5BTUlDX1NUQUxFVElNRSkgKiAxMDAwXG5cbmV4cG9ydCBjb25zdCBTVEFUSUNfU1RBTEVUSU1FX01TID1cbiAgTnVtYmVyKHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfUk9VVEVSX1NUQVRJQ19TVEFMRVRJTUUpICogMTAwMFxuXG5mdW5jdGlvbiBnZXRQcmVmZXRjaEVudHJ5Q2FjaGVTdGF0dXMoe1xuICBraW5kLFxuICBwcmVmZXRjaFRpbWUsXG4gIGxhc3RVc2VkVGltZSxcbn06IFByZWZldGNoQ2FjaGVFbnRyeSk6IFByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cyB7XG4gIC8vIFdlIHdpbGwgcmUtdXNlIHRoZSBjYWNoZSBlbnRyeSBkYXRhIGZvciB1cCB0byB0aGUgYGR5bmFtaWNgIHN0YWxldGltZSB3aW5kb3cuXG4gIGlmIChEYXRlLm5vdygpIDwgKGxhc3RVc2VkVGltZSA/PyBwcmVmZXRjaFRpbWUpICsgRFlOQU1JQ19TVEFMRVRJTUVfTVMpIHtcbiAgICByZXR1cm4gbGFzdFVzZWRUaW1lXG4gICAgICA/IFByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cy5yZXVzYWJsZVxuICAgICAgOiBQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMuZnJlc2hcbiAgfVxuXG4gIC8vIEZvciBcImF1dG9cIiBwcmVmZXRjaGluZywgd2UnbGwgcmUtdXNlIG9ubHkgdGhlIGxvYWRpbmcgYm91bmRhcnkgZm9yIHVwIHRvIGBzdGF0aWNgIHN0YWxldGltZSB3aW5kb3cuXG4gIC8vIEEgc3RhbGUgZW50cnkgd2lsbCBvbmx5IHJlLXVzZSB0aGUgYGxvYWRpbmdgIGJvdW5kYXJ5LCBub3QgdGhlIGZ1bGwgZGF0YS5cbiAgLy8gVGhpcyB3aWxsIHRyaWdnZXIgYSBcImxhenkgZmV0Y2hcIiBmb3IgdGhlIGZ1bGwgZGF0YS5cbiAgaWYgKGtpbmQgPT09IFByZWZldGNoS2luZC5BVVRPKSB7XG4gICAgaWYgKERhdGUubm93KCkgPCBwcmVmZXRjaFRpbWUgKyBTVEFUSUNfU1RBTEVUSU1FX01TKSB7XG4gICAgICByZXR1cm4gUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzLnN0YWxlXG4gICAgfVxuICB9XG5cbiAgLy8gZm9yIFwiZnVsbFwiIHByZWZldGNoaW5nLCB3ZSdsbCByZS11c2UgdGhlIGNhY2hlIGVudHJ5IGRhdGEgZm9yIHVwIHRvIGBzdGF0aWNgIHN0YWxldGltZSB3aW5kb3cuXG4gIGlmIChraW5kID09PSBQcmVmZXRjaEtpbmQuRlVMTCkge1xuICAgIGlmIChEYXRlLm5vdygpIDwgcHJlZmV0Y2hUaW1lICsgU1RBVElDX1NUQUxFVElNRV9NUykge1xuICAgICAgcmV0dXJuIFByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cy5yZXVzYWJsZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMuZXhwaXJlZFxufVxuIl0sIm5hbWVzIjpbIkRZTkFNSUNfU1RBTEVUSU1FX01TIiwiU1RBVElDX1NUQUxFVElNRV9NUyIsImNyZWF0ZVNlZWRlZFByZWZldGNoQ2FjaGVFbnRyeSIsImdldE9yQ3JlYXRlUHJlZmV0Y2hDYWNoZUVudHJ5IiwicHJ1bmVQcmVmZXRjaENhY2hlIiwiSU5URVJDRVBUSU9OX0NBQ0hFX0tFWV9NQVJLRVIiLCJjcmVhdGVQcmVmZXRjaENhY2hlS2V5SW1wbCIsInVybCIsImluY2x1ZGVTZWFyY2hQYXJhbXMiLCJwcmVmaXgiLCJwYXRobmFtZUZyb21VcmwiLCJwYXRobmFtZSIsInNlYXJjaCIsImNyZWF0ZVByZWZldGNoQ2FjaGVLZXkiLCJraW5kIiwibmV4dFVybCIsIlByZWZldGNoS2luZCIsIkZVTEwiLCJnZXRFeGlzdGluZ0NhY2hlRW50cnkiLCJwcmVmZXRjaENhY2hlIiwiYWxsb3dBbGlhc2luZyIsIlRFTVBPUkFSWSIsIm1heWJlTmV4dFVybCIsImNhY2hlS2V5V2l0aFBhcmFtcyIsImNhY2hlS2V5V2l0aG91dFBhcmFtcyIsImNhY2hlS2V5VG9Vc2UiLCJleGlzdGluZ0VudHJ5IiwiZ2V0IiwiaXNBbGlhc2VkIiwiYWxpYXNlZCIsImVudHJ5V2l0aG91dFBhcmFtcyIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImtleSIsImluY2x1ZGVzIiwiY2FjaGVFbnRyeSIsInZhbHVlcyIsInVuZGVmaW5lZCIsInRyZWUiLCJleGlzdGluZ0NhY2hlRW50cnkiLCJzdGF0dXMiLCJnZXRQcmVmZXRjaEVudHJ5Q2FjaGVTdGF0dXMiLCJzd2l0Y2hlZFRvRnVsbFByZWZldGNoIiwiZGF0YSIsInRoZW4iLCJwcmVmZXRjaFJlc3BvbnNlIiwiaXNGdWxsUHJlZmV0Y2giLCJBcnJheSIsImlzQXJyYXkiLCJmbGlnaHREYXRhIiwic29tZSIsImlzUm9vdFJlbmRlciIsInNlZWREYXRhIiwiY3JlYXRlTGF6eVByZWZldGNoRW50cnkiLCJwcmVmaXhFeGlzdGluZ1ByZWZldGNoQ2FjaGVFbnRyeSIsImV4aXN0aW5nQ2FjaGVLZXkiLCJuZXdDYWNoZUtleSIsInNldCIsImRlbGV0ZSIsInByZWZldGNoQ2FjaGVLZXkiLCJjb3VsZEJlSW50ZXJjZXB0ZWQiLCJwcmVmZXRjaEVudHJ5IiwidHJlZUF0VGltZU9mUHJlZmV0Y2giLCJQcm9taXNlIiwicmVzb2x2ZSIsInByZWZldGNoVGltZSIsIkRhdGUiLCJub3ciLCJsYXN0VXNlZFRpbWUiLCJzdGFsZVRpbWUiLCJQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMiLCJmcmVzaCIsInByZWZldGNoUXVldWUiLCJlbnF1ZXVlIiwiZmV0Y2hTZXJ2ZXJSZXNwb25zZSIsImZsaWdodFJvdXRlclN0YXRlIiwicHJlZmV0Y2hLaW5kIiwicHJlcmVuZGVyZWQiLCJocmVmIiwicHJlZmV0Y2hDYWNoZUVudHJ5IiwiZXhwaXJlZCIsIk51bWJlciIsIl9fTkVYVF9DTElFTlRfUk9VVEVSX0RZTkFNSUNfU1RBTEVUSU1FIiwiX19ORVhUX0NMSUVOVF9ST1VURVJfU1RBVElDX1NUQUxFVElNRSIsInJldXNhYmxlIiwiQVVUTyIsInN0YWxlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/router-reducer/reducers/hmr-refresh-reducer.js":
/*!*****************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/router-reducer/reducers/hmr-refresh-reducer.js ***!
  \*****************************************************************************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"hmrRefreshReducer\", ({\n    enumerable: true,\n    get: function() {\n        return hmrRefreshReducer;\n    }\n}));\nconst _fetchserverresponse = __webpack_require__(/*! ../fetch-server-response */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/router-reducer/fetch-server-response.js\");\nconst _createhreffromurl = __webpack_require__(/*! ../create-href-from-url */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\");\nconst _applyrouterstatepatchtotree = __webpack_require__(/*! ../apply-router-state-patch-to-tree */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js\");\nconst _isnavigatingtonewrootlayout = __webpack_require__(/*! ../is-navigating-to-new-root-layout */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js\");\nconst _navigatereducer = __webpack_require__(/*! ./navigate-reducer */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js\");\nconst _handlemutable = __webpack_require__(/*! ../handle-mutable */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/router-reducer/handle-mutable.js\");\nconst _applyflightdata = __webpack_require__(/*! ../apply-flight-data */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/router-reducer/apply-flight-data.js\");\nconst _approuter = __webpack_require__(/*! ../../app-router */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/app-router.js\");\nconst _handlesegmentmismatch = __webpack_require__(/*! ../handle-segment-mismatch */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/router-reducer/handle-segment-mismatch.js\");\nconst _hasinterceptionrouteincurrenttree = __webpack_require__(/*! ./has-interception-route-in-current-tree */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js\");\n// A version of refresh reducer that keeps the cache around instead of wiping all of it.\nfunction hmrRefreshReducerImpl(state, action) {\n    const { origin } = action;\n    const mutable = {};\n    const href = state.canonicalUrl;\n    mutable.preserveCustomHistoryState = false;\n    const cache = (0, _approuter.createEmptyCacheNode)();\n    // If the current tree was intercepted, the nextUrl should be included in the request.\n    // This is to ensure that the refresh request doesn't get intercepted, accidentally triggering the interception route.\n    const includeNextUrl = (0, _hasinterceptionrouteincurrenttree.hasInterceptionRouteInCurrentTree)(state.tree);\n    // TODO-APP: verify that `href` is not an external url.\n    // Fetch data from the root of the tree.\n    const navigatedAt = Date.now();\n    cache.lazyData = (0, _fetchserverresponse.fetchServerResponse)(new URL(href, origin), {\n        flightRouterState: [\n            state.tree[0],\n            state.tree[1],\n            state.tree[2],\n            'refetch'\n        ],\n        nextUrl: includeNextUrl ? state.nextUrl : null,\n        isHmrRefresh: true\n    });\n    return cache.lazyData.then((param)=>{\n        let { flightData, canonicalUrl: canonicalUrlOverride } = param;\n        // Handle case when navigating to page in `pages` from `app`\n        if (typeof flightData === 'string') {\n            return (0, _navigatereducer.handleExternalUrl)(state, mutable, flightData, state.pushRef.pendingPush);\n        }\n        // Remove cache.lazyData as it has been resolved at this point.\n        cache.lazyData = null;\n        let currentTree = state.tree;\n        let currentCache = state.cache;\n        for (const normalizedFlightData of flightData){\n            const { tree: treePatch, isRootRender } = normalizedFlightData;\n            if (!isRootRender) {\n                // TODO-APP: handle this case better\n                console.log('REFRESH FAILED');\n                return state;\n            }\n            const newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)([\n                ''\n            ], currentTree, treePatch, state.canonicalUrl);\n            if (newTree === null) {\n                return (0, _handlesegmentmismatch.handleSegmentMismatch)(state, action, treePatch);\n            }\n            if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {\n                return (0, _navigatereducer.handleExternalUrl)(state, mutable, href, state.pushRef.pendingPush);\n            }\n            const canonicalUrlOverrideHref = canonicalUrlOverride ? (0, _createhreffromurl.createHrefFromUrl)(canonicalUrlOverride) : undefined;\n            if (canonicalUrlOverride) {\n                mutable.canonicalUrl = canonicalUrlOverrideHref;\n            }\n            const applied = (0, _applyflightdata.applyFlightData)(navigatedAt, currentCache, cache, normalizedFlightData);\n            if (applied) {\n                mutable.cache = cache;\n                currentCache = cache;\n            }\n            mutable.patchedTree = newTree;\n            mutable.canonicalUrl = href;\n            currentTree = newTree;\n        }\n        return (0, _handlemutable.handleMutable)(state, mutable);\n    }, ()=>state);\n}\nfunction hmrRefreshReducerNoop(state, _action) {\n    return state;\n}\nconst hmrRefreshReducer =  false ? 0 : hmrRefreshReducerImpl;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=hmr-refresh-reducer.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE1LjUuMTJfcmVhY3QtZG9tQDE5LjIuNF9yZWFjdEAxOS4yLjRfX3JlYWN0QDE5LjIuNC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL2htci1yZWZyZXNoLXJlZHVjZXIuanMiLCJtYXBwaW5ncyI6Ijs7OztxREErSGFBOzs7ZUFBQUE7OztpREEvSHVCOytDQUNGO3lEQUNVO3lEQUNBOzZDQU9WOzJDQUNKOzZDQUNFO3VDQUVLO21EQUNDOytEQUNZO0FBRWxELHdGQUF3RjtBQUN4RixTQUFTQyxzQkFDUEMsS0FBMkIsRUFDM0JDLE1BQXdCO0lBRXhCLE1BQU0sRUFBRUMsTUFBTSxFQUFFLEdBQUdEO0lBQ25CLE1BQU1FLFVBQW1CLENBQUM7SUFDMUIsTUFBTUMsT0FBT0osTUFBTUssWUFBWTtJQUUvQkYsUUFBUUcsMEJBQTBCLEdBQUc7SUFFckMsTUFBTUMsUUFBbUJDLENBQUFBLEdBQUFBLFdBQUFBLG9CQUFBQTtJQUN6QixzRkFBc0Y7SUFDdEYsc0hBQXNIO0lBQ3RILE1BQU1DLGlCQUFpQkMsQ0FBQUEsR0FBQUEsbUNBQUFBLGlDQUFpQyxFQUFDVixNQUFNVyxJQUFJO0lBRW5FLHVEQUF1RDtJQUN2RCx3Q0FBd0M7SUFDeEMsTUFBTUMsY0FBY0MsS0FBS0MsR0FBRztJQUM1QlAsTUFBTVEsUUFBUSxHQUFHQyxDQUFBQSxHQUFBQSxxQkFBQUEsbUJBQUFBLEVBQW9CLElBQUlDLElBQUliLE1BQU1GLFNBQVM7UUFDMURnQixtQkFBbUI7WUFBQ2xCLE1BQU1XLElBQUksQ0FBQyxFQUFFO1lBQUVYLE1BQU1XLElBQUksQ0FBQyxFQUFFO1lBQUVYLE1BQU1XLElBQUksQ0FBQyxFQUFFO1lBQUU7U0FBVTtRQUMzRVEsU0FBU1YsaUJBQWlCVCxNQUFNbUIsT0FBTyxHQUFHO1FBQzFDQyxjQUFjO0lBQ2hCO0lBRUEsT0FBT2IsTUFBTVEsUUFBUSxDQUFDTSxJQUFJLENBQ3hCO1lBQUMsRUFBRUMsVUFBVSxFQUFFakIsY0FBY2tCLG9CQUFvQixFQUFFO1FBQ2pELDREQUE0RDtRQUM1RCxJQUFJLE9BQU9ELGVBQWUsVUFBVTtZQUNsQyxPQUFPRSxDQUFBQSxHQUFBQSxpQkFBQUEsaUJBQUFBLEVBQ0x4QixPQUNBRyxTQUNBbUIsWUFDQXRCLE1BQU15QixPQUFPLENBQUNDLFdBQVc7UUFFN0I7UUFFQSwrREFBK0Q7UUFDL0RuQixNQUFNUSxRQUFRLEdBQUc7UUFFakIsSUFBSVksY0FBYzNCLE1BQU1XLElBQUk7UUFDNUIsSUFBSWlCLGVBQWU1QixNQUFNTyxLQUFLO1FBRTlCLEtBQUssTUFBTXNCLHdCQUF3QlAsV0FBWTtZQUM3QyxNQUFNLEVBQUVYLE1BQU1tQixTQUFTLEVBQUVDLFlBQVksRUFBRSxHQUFHRjtZQUMxQyxJQUFJLENBQUNFLGNBQWM7Z0JBQ2pCLG9DQUFvQztnQkFDcENDLFFBQVFDLEdBQUcsQ0FBQztnQkFDWixPQUFPakM7WUFDVDtZQUVBLE1BQU1rQyxVQUFVQyxDQUFBQSxHQUFBQSw2QkFBQUEsMkJBQUFBLEVBQ2Q7Z0JBQ0M7YUFBRyxFQUNKUixhQUNBRyxXQUNBOUIsTUFBTUssWUFBWTtZQUdwQixJQUFJNkIsWUFBWSxNQUFNO2dCQUNwQixPQUFPRSxDQUFBQSxHQUFBQSx1QkFBQUEscUJBQUFBLEVBQXNCcEMsT0FBT0MsUUFBUTZCO1lBQzlDO1lBRUEsSUFBSU8sQ0FBQUEsR0FBQUEsNkJBQUFBLDJCQUFBQSxFQUE0QlYsYUFBYU8sVUFBVTtnQkFDckQsT0FBT1YsQ0FBQUEsR0FBQUEsaUJBQUFBLGlCQUFBQSxFQUNMeEIsT0FDQUcsU0FDQUMsTUFDQUosTUFBTXlCLE9BQU8sQ0FBQ0MsV0FBVztZQUU3QjtZQUVBLE1BQU1ZLDJCQUEyQmYsdUJBQzdCZ0IsQ0FBQUEsR0FBQUEsbUJBQUFBLGlCQUFBQSxFQUFrQmhCLHdCQUNsQmlCO1lBRUosSUFBSWpCLHNCQUFzQjtnQkFDeEJwQixRQUFRRSxZQUFZLEdBQUdpQztZQUN6QjtZQUNBLE1BQU1HLFVBQVVDLENBQUFBLEdBQUFBLGlCQUFBQSxlQUFBQSxFQUNkOUIsYUFDQWdCLGNBQ0FyQixPQUNBc0I7WUFHRixJQUFJWSxTQUFTO2dCQUNYdEMsUUFBUUksS0FBSyxHQUFHQTtnQkFDaEJxQixlQUFlckI7WUFDakI7WUFFQUosUUFBUXdDLFdBQVcsR0FBR1Q7WUFDdEIvQixRQUFRRSxZQUFZLEdBQUdEO1lBRXZCdUIsY0FBY087UUFDaEI7UUFDQSxPQUFPVSxDQUFBQSxHQUFBQSxlQUFBQSxhQUFBQSxFQUFjNUMsT0FBT0c7SUFDOUIsR0FDQSxJQUFNSDtBQUVWO0FBRUEsU0FBUzZDLHNCQUNQN0MsS0FBMkIsRUFDM0I4QyxPQUF5QjtJQUV6QixPQUFPOUM7QUFDVDtBQUVPLE1BQU1GLG9CQXJCWVMsTUFzQkgsR0FDaEJzQyxDQUFxQkEsR0FDckI5QyIsInNvdXJjZXMiOlsiL3NyYy9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yZWR1Y2Vycy9obXItcmVmcmVzaC1yZWR1Y2VyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGZldGNoU2VydmVyUmVzcG9uc2UgfSBmcm9tICcuLi9mZXRjaC1zZXJ2ZXItcmVzcG9uc2UnXG5pbXBvcnQgeyBjcmVhdGVIcmVmRnJvbVVybCB9IGZyb20gJy4uL2NyZWF0ZS1ocmVmLWZyb20tdXJsJ1xuaW1wb3J0IHsgYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlIH0gZnJvbSAnLi4vYXBwbHktcm91dGVyLXN0YXRlLXBhdGNoLXRvLXRyZWUnXG5pbXBvcnQgeyBpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQgfSBmcm9tICcuLi9pcy1uYXZpZ2F0aW5nLXRvLW5ldy1yb290LWxheW91dCdcbmltcG9ydCB0eXBlIHtcbiAgUmVhZG9ubHlSZWR1Y2VyU3RhdGUsXG4gIFJlZHVjZXJTdGF0ZSxcbiAgSG1yUmVmcmVzaEFjdGlvbixcbiAgTXV0YWJsZSxcbn0gZnJvbSAnLi4vcm91dGVyLXJlZHVjZXItdHlwZXMnXG5pbXBvcnQgeyBoYW5kbGVFeHRlcm5hbFVybCB9IGZyb20gJy4vbmF2aWdhdGUtcmVkdWNlcidcbmltcG9ydCB7IGhhbmRsZU11dGFibGUgfSBmcm9tICcuLi9oYW5kbGUtbXV0YWJsZSdcbmltcG9ydCB7IGFwcGx5RmxpZ2h0RGF0YSB9IGZyb20gJy4uL2FwcGx5LWZsaWdodC1kYXRhJ1xuaW1wb3J0IHR5cGUgeyBDYWNoZU5vZGUgfSBmcm9tICcuLi8uLi8uLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB7IGNyZWF0ZUVtcHR5Q2FjaGVOb2RlIH0gZnJvbSAnLi4vLi4vYXBwLXJvdXRlcidcbmltcG9ydCB7IGhhbmRsZVNlZ21lbnRNaXNtYXRjaCB9IGZyb20gJy4uL2hhbmRsZS1zZWdtZW50LW1pc21hdGNoJ1xuaW1wb3J0IHsgaGFzSW50ZXJjZXB0aW9uUm91dGVJbkN1cnJlbnRUcmVlIH0gZnJvbSAnLi9oYXMtaW50ZXJjZXB0aW9uLXJvdXRlLWluLWN1cnJlbnQtdHJlZSdcblxuLy8gQSB2ZXJzaW9uIG9mIHJlZnJlc2ggcmVkdWNlciB0aGF0IGtlZXBzIHRoZSBjYWNoZSBhcm91bmQgaW5zdGVhZCBvZiB3aXBpbmcgYWxsIG9mIGl0LlxuZnVuY3Rpb24gaG1yUmVmcmVzaFJlZHVjZXJJbXBsKFxuICBzdGF0ZTogUmVhZG9ubHlSZWR1Y2VyU3RhdGUsXG4gIGFjdGlvbjogSG1yUmVmcmVzaEFjdGlvblxuKTogUmVkdWNlclN0YXRlIHtcbiAgY29uc3QgeyBvcmlnaW4gfSA9IGFjdGlvblxuICBjb25zdCBtdXRhYmxlOiBNdXRhYmxlID0ge31cbiAgY29uc3QgaHJlZiA9IHN0YXRlLmNhbm9uaWNhbFVybFxuXG4gIG11dGFibGUucHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGUgPSBmYWxzZVxuXG4gIGNvbnN0IGNhY2hlOiBDYWNoZU5vZGUgPSBjcmVhdGVFbXB0eUNhY2hlTm9kZSgpXG4gIC8vIElmIHRoZSBjdXJyZW50IHRyZWUgd2FzIGludGVyY2VwdGVkLCB0aGUgbmV4dFVybCBzaG91bGQgYmUgaW5jbHVkZWQgaW4gdGhlIHJlcXVlc3QuXG4gIC8vIFRoaXMgaXMgdG8gZW5zdXJlIHRoYXQgdGhlIHJlZnJlc2ggcmVxdWVzdCBkb2Vzbid0IGdldCBpbnRlcmNlcHRlZCwgYWNjaWRlbnRhbGx5IHRyaWdnZXJpbmcgdGhlIGludGVyY2VwdGlvbiByb3V0ZS5cbiAgY29uc3QgaW5jbHVkZU5leHRVcmwgPSBoYXNJbnRlcmNlcHRpb25Sb3V0ZUluQ3VycmVudFRyZWUoc3RhdGUudHJlZSlcblxuICAvLyBUT0RPLUFQUDogdmVyaWZ5IHRoYXQgYGhyZWZgIGlzIG5vdCBhbiBleHRlcm5hbCB1cmwuXG4gIC8vIEZldGNoIGRhdGEgZnJvbSB0aGUgcm9vdCBvZiB0aGUgdHJlZS5cbiAgY29uc3QgbmF2aWdhdGVkQXQgPSBEYXRlLm5vdygpXG4gIGNhY2hlLmxhenlEYXRhID0gZmV0Y2hTZXJ2ZXJSZXNwb25zZShuZXcgVVJMKGhyZWYsIG9yaWdpbiksIHtcbiAgICBmbGlnaHRSb3V0ZXJTdGF0ZTogW3N0YXRlLnRyZWVbMF0sIHN0YXRlLnRyZWVbMV0sIHN0YXRlLnRyZWVbMl0sICdyZWZldGNoJ10sXG4gICAgbmV4dFVybDogaW5jbHVkZU5leHRVcmwgPyBzdGF0ZS5uZXh0VXJsIDogbnVsbCxcbiAgICBpc0htclJlZnJlc2g6IHRydWUsXG4gIH0pXG5cbiAgcmV0dXJuIGNhY2hlLmxhenlEYXRhLnRoZW4oXG4gICAgKHsgZmxpZ2h0RGF0YSwgY2Fub25pY2FsVXJsOiBjYW5vbmljYWxVcmxPdmVycmlkZSB9KSA9PiB7XG4gICAgICAvLyBIYW5kbGUgY2FzZSB3aGVuIG5hdmlnYXRpbmcgdG8gcGFnZSBpbiBgcGFnZXNgIGZyb20gYGFwcGBcbiAgICAgIGlmICh0eXBlb2YgZmxpZ2h0RGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZUV4dGVybmFsVXJsKFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIG11dGFibGUsXG4gICAgICAgICAgZmxpZ2h0RGF0YSxcbiAgICAgICAgICBzdGF0ZS5wdXNoUmVmLnBlbmRpbmdQdXNoXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIGNhY2hlLmxhenlEYXRhIGFzIGl0IGhhcyBiZWVuIHJlc29sdmVkIGF0IHRoaXMgcG9pbnQuXG4gICAgICBjYWNoZS5sYXp5RGF0YSA9IG51bGxcblxuICAgICAgbGV0IGN1cnJlbnRUcmVlID0gc3RhdGUudHJlZVxuICAgICAgbGV0IGN1cnJlbnRDYWNoZSA9IHN0YXRlLmNhY2hlXG5cbiAgICAgIGZvciAoY29uc3Qgbm9ybWFsaXplZEZsaWdodERhdGEgb2YgZmxpZ2h0RGF0YSkge1xuICAgICAgICBjb25zdCB7IHRyZWU6IHRyZWVQYXRjaCwgaXNSb290UmVuZGVyIH0gPSBub3JtYWxpemVkRmxpZ2h0RGF0YVxuICAgICAgICBpZiAoIWlzUm9vdFJlbmRlcikge1xuICAgICAgICAgIC8vIFRPRE8tQVBQOiBoYW5kbGUgdGhpcyBjYXNlIGJldHRlclxuICAgICAgICAgIGNvbnNvbGUubG9nKCdSRUZSRVNIIEZBSUxFRCcpXG4gICAgICAgICAgcmV0dXJuIHN0YXRlXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBuZXdUcmVlID0gYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlKFxuICAgICAgICAgIC8vIFRPRE8tQVBQOiByZW1vdmUgJydcbiAgICAgICAgICBbJyddLFxuICAgICAgICAgIGN1cnJlbnRUcmVlLFxuICAgICAgICAgIHRyZWVQYXRjaCxcbiAgICAgICAgICBzdGF0ZS5jYW5vbmljYWxVcmxcbiAgICAgICAgKVxuXG4gICAgICAgIGlmIChuZXdUcmVlID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZVNlZ21lbnRNaXNtYXRjaChzdGF0ZSwgYWN0aW9uLCB0cmVlUGF0Y2gpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0KGN1cnJlbnRUcmVlLCBuZXdUcmVlKSkge1xuICAgICAgICAgIHJldHVybiBoYW5kbGVFeHRlcm5hbFVybChcbiAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgbXV0YWJsZSxcbiAgICAgICAgICAgIGhyZWYsXG4gICAgICAgICAgICBzdGF0ZS5wdXNoUmVmLnBlbmRpbmdQdXNoXG4gICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmID0gY2Fub25pY2FsVXJsT3ZlcnJpZGVcbiAgICAgICAgICA/IGNyZWF0ZUhyZWZGcm9tVXJsKGNhbm9uaWNhbFVybE92ZXJyaWRlKVxuICAgICAgICAgIDogdW5kZWZpbmVkXG5cbiAgICAgICAgaWYgKGNhbm9uaWNhbFVybE92ZXJyaWRlKSB7XG4gICAgICAgICAgbXV0YWJsZS5jYW5vbmljYWxVcmwgPSBjYW5vbmljYWxVcmxPdmVycmlkZUhyZWZcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcHBsaWVkID0gYXBwbHlGbGlnaHREYXRhKFxuICAgICAgICAgIG5hdmlnYXRlZEF0LFxuICAgICAgICAgIGN1cnJlbnRDYWNoZSxcbiAgICAgICAgICBjYWNoZSxcbiAgICAgICAgICBub3JtYWxpemVkRmxpZ2h0RGF0YVxuICAgICAgICApXG5cbiAgICAgICAgaWYgKGFwcGxpZWQpIHtcbiAgICAgICAgICBtdXRhYmxlLmNhY2hlID0gY2FjaGVcbiAgICAgICAgICBjdXJyZW50Q2FjaGUgPSBjYWNoZVxuICAgICAgICB9XG5cbiAgICAgICAgbXV0YWJsZS5wYXRjaGVkVHJlZSA9IG5ld1RyZWVcbiAgICAgICAgbXV0YWJsZS5jYW5vbmljYWxVcmwgPSBocmVmXG5cbiAgICAgICAgY3VycmVudFRyZWUgPSBuZXdUcmVlXG4gICAgICB9XG4gICAgICByZXR1cm4gaGFuZGxlTXV0YWJsZShzdGF0ZSwgbXV0YWJsZSlcbiAgICB9LFxuICAgICgpID0+IHN0YXRlXG4gIClcbn1cblxuZnVuY3Rpb24gaG1yUmVmcmVzaFJlZHVjZXJOb29wKFxuICBzdGF0ZTogUmVhZG9ubHlSZWR1Y2VyU3RhdGUsXG4gIF9hY3Rpb246IEhtclJlZnJlc2hBY3Rpb25cbik6IFJlZHVjZXJTdGF0ZSB7XG4gIHJldHVybiBzdGF0ZVxufVxuXG5leHBvcnQgY29uc3QgaG1yUmVmcmVzaFJlZHVjZXIgPVxuICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nXG4gICAgPyBobXJSZWZyZXNoUmVkdWNlck5vb3BcbiAgICA6IGhtclJlZnJlc2hSZWR1Y2VySW1wbFxuIl0sIm5hbWVzIjpbImhtclJlZnJlc2hSZWR1Y2VyIiwiaG1yUmVmcmVzaFJlZHVjZXJJbXBsIiwic3RhdGUiLCJhY3Rpb24iLCJvcmlnaW4iLCJtdXRhYmxlIiwiaHJlZiIsImNhbm9uaWNhbFVybCIsInByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlIiwiY2FjaGUiLCJjcmVhdGVFbXB0eUNhY2hlTm9kZSIsImluY2x1ZGVOZXh0VXJsIiwiaGFzSW50ZXJjZXB0aW9uUm91dGVJbkN1cnJlbnRUcmVlIiwidHJlZSIsIm5hdmlnYXRlZEF0IiwiRGF0ZSIsIm5vdyIsImxhenlEYXRhIiwiZmV0Y2hTZXJ2ZXJSZXNwb25zZSIsIlVSTCIsImZsaWdodFJvdXRlclN0YXRlIiwibmV4dFVybCIsImlzSG1yUmVmcmVzaCIsInRoZW4iLCJmbGlnaHREYXRhIiwiY2Fub25pY2FsVXJsT3ZlcnJpZGUiLCJoYW5kbGVFeHRlcm5hbFVybCIsInB1c2hSZWYiLCJwZW5kaW5nUHVzaCIsImN1cnJlbnRUcmVlIiwiY3VycmVudENhY2hlIiwibm9ybWFsaXplZEZsaWdodERhdGEiLCJ0cmVlUGF0Y2giLCJpc1Jvb3RSZW5kZXIiLCJjb25zb2xlIiwibG9nIiwibmV3VHJlZSIsImFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZSIsImhhbmRsZVNlZ21lbnRNaXNtYXRjaCIsImlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dCIsImNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZiIsImNyZWF0ZUhyZWZGcm9tVXJsIiwidW5kZWZpbmVkIiwiYXBwbGllZCIsImFwcGx5RmxpZ2h0RGF0YSIsInBhdGNoZWRUcmVlIiwiaGFuZGxlTXV0YWJsZSIsImhtclJlZnJlc2hSZWR1Y2VyTm9vcCIsIl9hY3Rpb24iLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/router-reducer/reducers/hmr-refresh-reducer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/react-client-callbacks/error-boundary-callbacks.js":
/*!**********************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/react-client-callbacks/error-boundary-callbacks.js ***!
  \**********************************************************************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("// This file is only used in app router due to the specific error state handling.\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    onCaughtError: function() {\n        return onCaughtError;\n    },\n    onUncaughtError: function() {\n        return onUncaughtError;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.15/node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _isnextroutererror = __webpack_require__(/*! ../components/is-next-router-error */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/is-next-router-error.js\");\nconst _bailouttocsr = __webpack_require__(/*! ../../shared/lib/lazy-dynamic/bailout-to-csr */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/shared/lib/lazy-dynamic/bailout-to-csr.js\");\nconst _reportglobalerror = __webpack_require__(/*! ./report-global-error */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/react-client-callbacks/report-global-error.js\");\nconst _errorboundary = __webpack_require__(/*! ../components/error-boundary */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/error-boundary.js\");\nconst _globalerror = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../components/builtin/global-error */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/builtin/global-error.js\"));\nconst devToolErrorMod =  true ? __webpack_require__(/*! ../../next-devtools/userspace/app/errors */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/next-devtools/userspace/app/errors/index.js\") : 0;\nfunction onCaughtError(thrownValue, errorInfo) {\n    var _errorInfo_errorBoundary;\n    const errorBoundaryComponent = (_errorInfo_errorBoundary = errorInfo.errorBoundary) == null ? void 0 : _errorInfo_errorBoundary.constructor;\n    let isImplicitErrorBoundary;\n    if (true) {\n        const { AppDevOverlayErrorBoundary } = __webpack_require__(/*! ../../next-devtools/userspace/app/app-dev-overlay-error-boundary */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/next-devtools/userspace/app/app-dev-overlay-error-boundary.js\");\n        isImplicitErrorBoundary = errorBoundaryComponent === AppDevOverlayErrorBoundary;\n    }\n    isImplicitErrorBoundary = isImplicitErrorBoundary || errorBoundaryComponent === _errorboundary.ErrorBoundaryHandler && errorInfo.errorBoundary.props.errorComponent === _globalerror.default;\n    // Skip the segment explorer triggered error\n    if (true) {\n        const { SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE } = __webpack_require__(/*! ../../next-devtools/userspace/app/segment-explorer-node */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/next-devtools/userspace/app/segment-explorer-node.js\");\n        if (thrownValue instanceof Error && thrownValue.message === SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE) {\n            return;\n        }\n    }\n    if (isImplicitErrorBoundary) {\n        // We don't consider errors caught unless they're caught by an explicit error\n        // boundary. The built-in ones are considered implicit.\n        // This mimics how the same app would behave without Next.js.\n        return onUncaughtError(thrownValue);\n    }\n    // Skip certain custom errors which are not expected to be reported on client\n    if ((0, _bailouttocsr.isBailoutToCSRError)(thrownValue) || (0, _isnextroutererror.isNextRouterError)(thrownValue)) return;\n    if (true) {\n        var _errorInfo_componentStack;\n        const errorBoundaryName = (errorBoundaryComponent == null ? void 0 : errorBoundaryComponent.displayName) || (errorBoundaryComponent == null ? void 0 : errorBoundaryComponent.name) || 'Unknown';\n        const componentThatErroredFrame = errorInfo == null ? void 0 : (_errorInfo_componentStack = errorInfo.componentStack) == null ? void 0 : _errorInfo_componentStack.split('\\n')[1];\n        var // example 1: at Page (http://localhost:3000/_next/static/chunks/pages/index.js?ts=1631600000000:2:1)\n        // example 2: Page@http://localhost:3000/_next/static/chunks/pages/index.js?ts=1631600000000:2:1\n        _componentThatErroredFrame_match;\n        // Match chrome or safari stack trace\n        const matches = (_componentThatErroredFrame_match = componentThatErroredFrame == null ? void 0 : componentThatErroredFrame.match(/\\s+at (\\w+)\\s+|(\\w+)@/)) != null ? _componentThatErroredFrame_match : [];\n        const componentThatErroredName = matches[1] || matches[2] || 'Unknown';\n        // Create error location with errored component and error boundary, to match the behavior of default React onCaughtError handler.\n        const errorBoundaryMessage = \"It was handled by the <\" + errorBoundaryName + \"> error boundary.\";\n        const componentErrorMessage = componentThatErroredName ? \"The above error occurred in the <\" + componentThatErroredName + \"> component.\" : \"The above error occurred in one of your components.\";\n        const errorLocation = componentErrorMessage + \" \" + errorBoundaryMessage;\n        const error = devToolErrorMod.decorateDevError(thrownValue);\n        // Log and report the error with location but without modifying the error stack\n        devToolErrorMod.originConsoleError('%o\\n\\n%s', thrownValue, errorLocation);\n        devToolErrorMod.handleClientError(error);\n    } else {}\n}\nfunction onUncaughtError(thrownValue) {\n    // Skip certain custom errors which are not expected to be reported on client\n    if ((0, _bailouttocsr.isBailoutToCSRError)(thrownValue) || (0, _isnextroutererror.isNextRouterError)(thrownValue)) return;\n    if (true) {\n        const error = devToolErrorMod.decorateDevError(thrownValue);\n        // TODO: Add an adendum to the overlay telling people about custom error boundaries.\n        (0, _reportglobalerror.reportGlobalError)(error);\n    } else {}\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=error-boundary-callbacks.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE1LjUuMTJfcmVhY3QtZG9tQDE5LjIuNF9yZWFjdEAxOS4yLjRfX3JlYWN0QDE5LjIuNC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9yZWFjdC1jbGllbnQtY2FsbGJhY2tzL2Vycm9yLWJvdW5kYXJ5LWNhbGxiYWNrcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxpRkFBaUY7Ozs7Ozs7Ozs7Ozs7SUFrQmpFQSxhQUFhO2VBQWJBOztJQStFQUMsZUFBZTtlQUFmQTs7OzsrQ0E5RmtCOzBDQUNFOytDQUNGOzJDQUNHO2tGQUNKO0FBRWpDLE1BQU1DLGtCQUNKQyxLQUFvQixHQUNmRyxtQkFBT0EsQ0FBQyxzTkFBMEMsSUFDbkQsQ0FJQztBQUVBLFNBQVNOLGNBQ2RhLFdBQW9CLEVBQ3BCQyxTQUEwRDtRQUUzQkE7SUFBL0IsTUFBTUMseUJBQUFBLENBQXlCRCwyQkFBQUEsVUFBVUUsYUFBQUEsS0FBYSxnQkFBdkJGLHlCQUF5QkcsV0FBVztJQUVuRSxJQUFJQztJQUVKLElBa0RxQyxJQWxEYixFQUFtQjtRQUN6QyxNQUFNLEVBQUVDLDBCQUEwQixFQUFFLEdBQ2xDYixtQkFBT0EsQ0FBQyxnUUFBa0U7UUFFNUVZLDBCQUNFSCwyQkFBMkJJO0lBQy9CO0lBRUFELDBCQUNFQSwyQkFDQ0gsMkJBQTJCSyxlQUFBQSxvQkFBb0IsSUFDN0NOLFVBQVVFLGFBQWEsQ0FDckJLLEtBQUssQ0FBQ0MsY0FBYyxLQUFLQyxhQUFBQSxPQUFvQjtJQUVwRCw0Q0FBNEM7SUFDNUMsSUFBSXBCLElBQW9CLEVBQW1CO1FBQ3pDLE1BQU0sRUFBRXFCLHdDQUF3QyxFQUFFLEdBQ2hEbEIsbUJBQU9BLENBQUMsOE9BQXlEO1FBQ25FLElBQ0VPLHVCQUF1QlksU0FDdkJaLFlBQVlhLE9BQU8sS0FBS0YsMENBQ3hCO1lBQ0E7UUFDRjtJQUNGO0lBRUEsSUFBSU4seUJBQXlCO1FBQzNCLDZFQUE2RTtRQUM3RSx1REFBdUQ7UUFDdkQsNkRBQTZEO1FBQzdELE9BQU9qQixnQkFBZ0JZO0lBQ3pCO0lBRUEsNkVBQTZFO0lBQzdFLElBQUljLENBQUFBLEdBQUFBLGNBQUFBLG1CQUFtQixFQUFDZCxnQkFBZ0JlLENBQUFBLEdBQUFBLG1CQUFBQSxpQkFBQUEsRUFBa0JmLGNBQWM7SUFFeEUsSUFBSVYsSUFBb0IsRUFBbUI7WUFPUFc7UUFObEMsTUFBTWUsb0JBRUosQ0FEQSwwQkFDQ2QsT0FBQUEsRUFEa0MsR0FDbENBLElBQUFBLHVCQUFnQ2UsV0FBQUEsTUFDakNmLDBCQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSx1QkFBd0JnQixJQUFBQSxLQUN4QjtRQUVGLE1BQU1DLDRCQUE0QmxCLGFBQUFBLE9BQUFBLEtBQUFBLElBQUFBLENBQUFBLDRCQUFBQSxVQUFXbUIsY0FBQUEsS0FBYyxnQkFBekJuQiwwQkFBMkJvQixLQUFLLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFLekUsc0RBRHNELCtDQUMrQztRQUNyRyxnR0FBZ0c7UUFDaEdGO1FBTEYscUNBQXFDO1FBQ3JDLE1BQU1HLFVBSUpILENBQUFBLG1DQUFBQSw2QkFBQUEsT0FBQUEsS0FBQUEsSUFBQUEsMEJBQTJCSSxLQUFLLENBQUMsb0NBQWpDSixtQ0FBNkQsRUFBRTtRQUNqRSxNQUFNSywyQkFBMkJGLE9BQU8sQ0FBQyxFQUFFLElBQUlBLE9BQU8sQ0FBQyxFQUFFLElBQUk7UUFFN0QsaUlBQWlJO1FBQ2pJLE1BQU1HLHVCQUF3Qiw0QkFBeUJULG9CQUFrQjtRQUN6RSxNQUFNVSx3QkFBd0JGLDJCQUN6QixzQ0FBbUNBLDJCQUF5QixpQkFDNUQ7UUFFTCxNQUFNRyxnQkFBbUJELHdCQUFzQixNQUFHRDtRQUNsRCxNQUFNOUIsUUFBUU4sZ0JBQWdCSyxnQkFBZ0IsQ0FBQ007UUFFL0MsK0VBQStFO1FBQy9FWCxnQkFBZ0JRLGtCQUFrQixDQUFDLFlBQVlHLGFBQWEyQjtRQUU1RHRDLGdCQUFnQk8saUJBQWlCLENBQUNEO0lBQ3BDLE9BQU8sRUFFTjtBQUNIO0FBRU8sU0FBU1AsZ0JBQWdCWSxXQUFvQjtJQUNsRCw2RUFBNkU7SUFDN0UsSUFBSWMsQ0FBQUEsR0FBQUEsY0FBQUEsbUJBQUFBLEVBQW9CZCxnQkFBZ0JlLENBQUFBLEdBQUFBLG1CQUFBQSxpQkFBQUEsRUFBa0JmLGNBQWM7SUFFeEUsSUFBSVYsSUFBb0IsRUFBbUI7UUFDekMsTUFBTUssUUFBUU4sZ0JBQWdCSyxnQkFBZ0IsQ0FBQ007UUFFL0Msb0ZBQW9GO1FBQ3BGNEIsQ0FBQUEsR0FBQUEsbUJBQUFBLGlCQUFBQSxFQUFrQmpDO0lBQ3BCLE9BQU8sRUFFTjtBQUNIIiwic291cmNlcyI6WyIvVXNlcnMvc2FiaW5lcmVzb2FnbGkvc3JjL2NsaWVudC9yZWFjdC1jbGllbnQtY2FsbGJhY2tzL2Vycm9yLWJvdW5kYXJ5LWNhbGxiYWNrcy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUaGlzIGZpbGUgaXMgb25seSB1c2VkIGluIGFwcCByb3V0ZXIgZHVlIHRvIHRoZSBzcGVjaWZpYyBlcnJvciBzdGF0ZSBoYW5kbGluZy5cblxuaW1wb3J0IHR5cGUgeyBFcnJvckluZm8gfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IGlzTmV4dFJvdXRlckVycm9yIH0gZnJvbSAnLi4vY29tcG9uZW50cy9pcy1uZXh0LXJvdXRlci1lcnJvcidcbmltcG9ydCB7IGlzQmFpbG91dFRvQ1NSRXJyb3IgfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL2xhenktZHluYW1pYy9iYWlsb3V0LXRvLWNzcidcbmltcG9ydCB7IHJlcG9ydEdsb2JhbEVycm9yIH0gZnJvbSAnLi9yZXBvcnQtZ2xvYmFsLWVycm9yJ1xuaW1wb3J0IHsgRXJyb3JCb3VuZGFyeUhhbmRsZXIgfSBmcm9tICcuLi9jb21wb25lbnRzL2Vycm9yLWJvdW5kYXJ5J1xuaW1wb3J0IERlZmF1bHRFcnJvckJvdW5kYXJ5IGZyb20gJy4uL2NvbXBvbmVudHMvYnVpbHRpbi9nbG9iYWwtZXJyb3InXG5cbmNvbnN0IGRldlRvb2xFcnJvck1vZDogdHlwZW9mIGltcG9ydCgnLi4vLi4vbmV4dC1kZXZ0b29scy91c2Vyc3BhY2UvYXBwL2Vycm9ycycpID1cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJ1xuICAgID8gKHJlcXVpcmUoJy4uLy4uL25leHQtZGV2dG9vbHMvdXNlcnNwYWNlL2FwcC9lcnJvcnMnKSBhcyB0eXBlb2YgaW1wb3J0KCcuLi8uLi9uZXh0LWRldnRvb2xzL3VzZXJzcGFjZS9hcHAvZXJyb3JzJykpXG4gICAgOiB7XG4gICAgICAgIGRlY29yYXRlRGV2RXJyb3I6IChlcnJvcjogdW5rbm93bikgPT4gZXJyb3IgYXMgRXJyb3IsXG4gICAgICAgIGhhbmRsZUNsaWVudEVycm9yOiAoKSA9PiB7fSxcbiAgICAgICAgb3JpZ2luQ29uc29sZUVycm9yOiBjb25zb2xlLmVycm9yLmJpbmQoY29uc29sZSksXG4gICAgICB9XG5cbmV4cG9ydCBmdW5jdGlvbiBvbkNhdWdodEVycm9yKFxuICB0aHJvd25WYWx1ZTogdW5rbm93bixcbiAgZXJyb3JJbmZvOiBFcnJvckluZm8gJiB7IGVycm9yQm91bmRhcnk/OiBSZWFjdC5Db21wb25lbnQgfVxuKSB7XG4gIGNvbnN0IGVycm9yQm91bmRhcnlDb21wb25lbnQgPSBlcnJvckluZm8uZXJyb3JCb3VuZGFyeT8uY29uc3RydWN0b3JcblxuICBsZXQgaXNJbXBsaWNpdEVycm9yQm91bmRhcnlcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNvbnN0IHsgQXBwRGV2T3ZlcmxheUVycm9yQm91bmRhcnkgfSA9XG4gICAgICByZXF1aXJlKCcuLi8uLi9uZXh0LWRldnRvb2xzL3VzZXJzcGFjZS9hcHAvYXBwLWRldi1vdmVybGF5LWVycm9yLWJvdW5kYXJ5JykgYXMgdHlwZW9mIGltcG9ydCgnLi4vLi4vbmV4dC1kZXZ0b29scy91c2Vyc3BhY2UvYXBwL2FwcC1kZXYtb3ZlcmxheS1lcnJvci1ib3VuZGFyeScpXG5cbiAgICBpc0ltcGxpY2l0RXJyb3JCb3VuZGFyeSA9XG4gICAgICBlcnJvckJvdW5kYXJ5Q29tcG9uZW50ID09PSBBcHBEZXZPdmVybGF5RXJyb3JCb3VuZGFyeVxuICB9XG5cbiAgaXNJbXBsaWNpdEVycm9yQm91bmRhcnkgPVxuICAgIGlzSW1wbGljaXRFcnJvckJvdW5kYXJ5IHx8XG4gICAgKGVycm9yQm91bmRhcnlDb21wb25lbnQgPT09IEVycm9yQm91bmRhcnlIYW5kbGVyICYmXG4gICAgICAoZXJyb3JJbmZvLmVycm9yQm91bmRhcnkhIGFzIEluc3RhbmNlVHlwZTx0eXBlb2YgRXJyb3JCb3VuZGFyeUhhbmRsZXI+KVxuICAgICAgICAucHJvcHMuZXJyb3JDb21wb25lbnQgPT09IERlZmF1bHRFcnJvckJvdW5kYXJ5KVxuXG4gIC8vIFNraXAgdGhlIHNlZ21lbnQgZXhwbG9yZXIgdHJpZ2dlcmVkIGVycm9yXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY29uc3QgeyBTRUdNRU5UX0VYUExPUkVSX1NJTVVMQVRFRF9FUlJPUl9NRVNTQUdFIH0gPVxuICAgICAgcmVxdWlyZSgnLi4vLi4vbmV4dC1kZXZ0b29scy91c2Vyc3BhY2UvYXBwL3NlZ21lbnQtZXhwbG9yZXItbm9kZScpIGFzIHR5cGVvZiBpbXBvcnQoJy4uLy4uL25leHQtZGV2dG9vbHMvdXNlcnNwYWNlL2FwcC9zZWdtZW50LWV4cGxvcmVyLW5vZGUnKVxuICAgIGlmIChcbiAgICAgIHRocm93blZhbHVlIGluc3RhbmNlb2YgRXJyb3IgJiZcbiAgICAgIHRocm93blZhbHVlLm1lc3NhZ2UgPT09IFNFR01FTlRfRVhQTE9SRVJfU0lNVUxBVEVEX0VSUk9SX01FU1NBR0VcbiAgICApIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxuXG4gIGlmIChpc0ltcGxpY2l0RXJyb3JCb3VuZGFyeSkge1xuICAgIC8vIFdlIGRvbid0IGNvbnNpZGVyIGVycm9ycyBjYXVnaHQgdW5sZXNzIHRoZXkncmUgY2F1Z2h0IGJ5IGFuIGV4cGxpY2l0IGVycm9yXG4gICAgLy8gYm91bmRhcnkuIFRoZSBidWlsdC1pbiBvbmVzIGFyZSBjb25zaWRlcmVkIGltcGxpY2l0LlxuICAgIC8vIFRoaXMgbWltaWNzIGhvdyB0aGUgc2FtZSBhcHAgd291bGQgYmVoYXZlIHdpdGhvdXQgTmV4dC5qcy5cbiAgICByZXR1cm4gb25VbmNhdWdodEVycm9yKHRocm93blZhbHVlKVxuICB9XG5cbiAgLy8gU2tpcCBjZXJ0YWluIGN1c3RvbSBlcnJvcnMgd2hpY2ggYXJlIG5vdCBleHBlY3RlZCB0byBiZSByZXBvcnRlZCBvbiBjbGllbnRcbiAgaWYgKGlzQmFpbG91dFRvQ1NSRXJyb3IodGhyb3duVmFsdWUpIHx8IGlzTmV4dFJvdXRlckVycm9yKHRocm93blZhbHVlKSkgcmV0dXJuXG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjb25zdCBlcnJvckJvdW5kYXJ5TmFtZSA9XG4gICAgICAvLyByZWFkIHJlYWN0IGNvbXBvbmVudCBkaXNwbGF5TmFtZVxuICAgICAgKGVycm9yQm91bmRhcnlDb21wb25lbnQgYXMgYW55KT8uZGlzcGxheU5hbWUgfHxcbiAgICAgIGVycm9yQm91bmRhcnlDb21wb25lbnQ/Lm5hbWUgfHxcbiAgICAgICdVbmtub3duJ1xuXG4gICAgY29uc3QgY29tcG9uZW50VGhhdEVycm9yZWRGcmFtZSA9IGVycm9ySW5mbz8uY29tcG9uZW50U3RhY2s/LnNwbGl0KCdcXG4nKVsxXVxuXG4gICAgLy8gTWF0Y2ggY2hyb21lIG9yIHNhZmFyaSBzdGFjayB0cmFjZVxuICAgIGNvbnN0IG1hdGNoZXMgPVxuICAgICAgLy8gcmVnZXggdG8gbWF0Y2ggdGhlIGZ1bmN0aW9uIG5hbWUgaW4gdGhlIHN0YWNrIHRyYWNlXG4gICAgICAvLyBleGFtcGxlIDE6IGF0IFBhZ2UgKGh0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9fbmV4dC9zdGF0aWMvY2h1bmtzL3BhZ2VzL2luZGV4LmpzP3RzPTE2MzE2MDAwMDAwMDA6MjoxKVxuICAgICAgLy8gZXhhbXBsZSAyOiBQYWdlQGh0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9fbmV4dC9zdGF0aWMvY2h1bmtzL3BhZ2VzL2luZGV4LmpzP3RzPTE2MzE2MDAwMDAwMDA6MjoxXG4gICAgICBjb21wb25lbnRUaGF0RXJyb3JlZEZyYW1lPy5tYXRjaCgvXFxzK2F0IChcXHcrKVxccyt8KFxcdyspQC8pID8/IFtdXG4gICAgY29uc3QgY29tcG9uZW50VGhhdEVycm9yZWROYW1lID0gbWF0Y2hlc1sxXSB8fCBtYXRjaGVzWzJdIHx8ICdVbmtub3duJ1xuXG4gICAgLy8gQ3JlYXRlIGVycm9yIGxvY2F0aW9uIHdpdGggZXJyb3JlZCBjb21wb25lbnQgYW5kIGVycm9yIGJvdW5kYXJ5LCB0byBtYXRjaCB0aGUgYmVoYXZpb3Igb2YgZGVmYXVsdCBSZWFjdCBvbkNhdWdodEVycm9yIGhhbmRsZXIuXG4gICAgY29uc3QgZXJyb3JCb3VuZGFyeU1lc3NhZ2UgPSBgSXQgd2FzIGhhbmRsZWQgYnkgdGhlIDwke2Vycm9yQm91bmRhcnlOYW1lfT4gZXJyb3IgYm91bmRhcnkuYFxuICAgIGNvbnN0IGNvbXBvbmVudEVycm9yTWVzc2FnZSA9IGNvbXBvbmVudFRoYXRFcnJvcmVkTmFtZVxuICAgICAgPyBgVGhlIGFib3ZlIGVycm9yIG9jY3VycmVkIGluIHRoZSA8JHtjb21wb25lbnRUaGF0RXJyb3JlZE5hbWV9PiBjb21wb25lbnQuYFxuICAgICAgOiBgVGhlIGFib3ZlIGVycm9yIG9jY3VycmVkIGluIG9uZSBvZiB5b3VyIGNvbXBvbmVudHMuYFxuXG4gICAgY29uc3QgZXJyb3JMb2NhdGlvbiA9IGAke2NvbXBvbmVudEVycm9yTWVzc2FnZX0gJHtlcnJvckJvdW5kYXJ5TWVzc2FnZX1gXG4gICAgY29uc3QgZXJyb3IgPSBkZXZUb29sRXJyb3JNb2QuZGVjb3JhdGVEZXZFcnJvcih0aHJvd25WYWx1ZSlcblxuICAgIC8vIExvZyBhbmQgcmVwb3J0IHRoZSBlcnJvciB3aXRoIGxvY2F0aW9uIGJ1dCB3aXRob3V0IG1vZGlmeWluZyB0aGUgZXJyb3Igc3RhY2tcbiAgICBkZXZUb29sRXJyb3JNb2Qub3JpZ2luQ29uc29sZUVycm9yKCclb1xcblxcbiVzJywgdGhyb3duVmFsdWUsIGVycm9yTG9jYXRpb24pXG5cbiAgICBkZXZUb29sRXJyb3JNb2QuaGFuZGxlQ2xpZW50RXJyb3IoZXJyb3IpXG4gIH0gZWxzZSB7XG4gICAgZGV2VG9vbEVycm9yTW9kLm9yaWdpbkNvbnNvbGVFcnJvcih0aHJvd25WYWx1ZSlcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gb25VbmNhdWdodEVycm9yKHRocm93blZhbHVlOiB1bmtub3duKSB7XG4gIC8vIFNraXAgY2VydGFpbiBjdXN0b20gZXJyb3JzIHdoaWNoIGFyZSBub3QgZXhwZWN0ZWQgdG8gYmUgcmVwb3J0ZWQgb24gY2xpZW50XG4gIGlmIChpc0JhaWxvdXRUb0NTUkVycm9yKHRocm93blZhbHVlKSB8fCBpc05leHRSb3V0ZXJFcnJvcih0aHJvd25WYWx1ZSkpIHJldHVyblxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY29uc3QgZXJyb3IgPSBkZXZUb29sRXJyb3JNb2QuZGVjb3JhdGVEZXZFcnJvcih0aHJvd25WYWx1ZSlcblxuICAgIC8vIFRPRE86IEFkZCBhbiBhZGVuZHVtIHRvIHRoZSBvdmVybGF5IHRlbGxpbmcgcGVvcGxlIGFib3V0IGN1c3RvbSBlcnJvciBib3VuZGFyaWVzLlxuICAgIHJlcG9ydEdsb2JhbEVycm9yKGVycm9yKVxuICB9IGVsc2Uge1xuICAgIHJlcG9ydEdsb2JhbEVycm9yKHRocm93blZhbHVlKVxuICB9XG59XG4iXSwibmFtZXMiOlsib25DYXVnaHRFcnJvciIsIm9uVW5jYXVnaHRFcnJvciIsImRldlRvb2xFcnJvck1vZCIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsInJlcXVpcmUiLCJkZWNvcmF0ZURldkVycm9yIiwiZXJyb3IiLCJoYW5kbGVDbGllbnRFcnJvciIsIm9yaWdpbkNvbnNvbGVFcnJvciIsImNvbnNvbGUiLCJiaW5kIiwidGhyb3duVmFsdWUiLCJlcnJvckluZm8iLCJlcnJvckJvdW5kYXJ5Q29tcG9uZW50IiwiZXJyb3JCb3VuZGFyeSIsImNvbnN0cnVjdG9yIiwiaXNJbXBsaWNpdEVycm9yQm91bmRhcnkiLCJBcHBEZXZPdmVybGF5RXJyb3JCb3VuZGFyeSIsIkVycm9yQm91bmRhcnlIYW5kbGVyIiwicHJvcHMiLCJlcnJvckNvbXBvbmVudCIsIkRlZmF1bHRFcnJvckJvdW5kYXJ5IiwiU0VHTUVOVF9FWFBMT1JFUl9TSU1VTEFURURfRVJST1JfTUVTU0FHRSIsIkVycm9yIiwibWVzc2FnZSIsImlzQmFpbG91dFRvQ1NSRXJyb3IiLCJpc05leHRSb3V0ZXJFcnJvciIsImVycm9yQm91bmRhcnlOYW1lIiwiZGlzcGxheU5hbWUiLCJuYW1lIiwiY29tcG9uZW50VGhhdEVycm9yZWRGcmFtZSIsImNvbXBvbmVudFN0YWNrIiwic3BsaXQiLCJtYXRjaGVzIiwibWF0Y2giLCJjb21wb25lbnRUaGF0RXJyb3JlZE5hbWUiLCJlcnJvckJvdW5kYXJ5TWVzc2FnZSIsImNvbXBvbmVudEVycm9yTWVzc2FnZSIsImVycm9yTG9jYXRpb24iLCJyZXBvcnRHbG9iYWxFcnJvciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/react-client-callbacks/error-boundary-callbacks.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/react-client-callbacks/on-recoverable-error.js":
/*!******************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/react-client-callbacks/on-recoverable-error.js ***!
  \******************************************************************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("// This module can be shared between both pages router and app router\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    isRecoverableError: function() {\n        return isRecoverableError;\n    },\n    onRecoverableError: function() {\n        return onRecoverableError;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.15/node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _bailouttocsr = __webpack_require__(/*! ../../shared/lib/lazy-dynamic/bailout-to-csr */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/shared/lib/lazy-dynamic/bailout-to-csr.js\");\nconst _iserror = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../../lib/is-error */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/lib/is-error.js\"));\nconst _reportglobalerror = __webpack_require__(/*! ./report-global-error */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/react-client-callbacks/report-global-error.js\");\nconst recoverableErrors = new WeakSet();\nfunction isRecoverableError(error) {\n    return recoverableErrors.has(error);\n}\nconst onRecoverableError = (error)=>{\n    // x-ref: https://github.com/facebook/react/pull/28736\n    let cause = (0, _iserror.default)(error) && 'cause' in error ? error.cause : error;\n    // Skip certain custom errors which are not expected to be reported on client\n    if ((0, _bailouttocsr.isBailoutToCSRError)(cause)) return;\n    if (true) {\n        const { decorateDevError } = __webpack_require__(/*! ../../next-devtools/userspace/app/errors/stitched-error */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/next-devtools/userspace/app/errors/stitched-error.js\");\n        const causeError = decorateDevError(cause);\n        recoverableErrors.add(causeError);\n        cause = causeError;\n    }\n    (0, _reportglobalerror.reportGlobalError)(cause);\n};\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=on-recoverable-error.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE1LjUuMTJfcmVhY3QtZG9tQDE5LjIuNF9yZWFjdEAxOS4yLjRfX3JlYWN0QDE5LjIuNC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9yZWFjdC1jbGllbnQtY2FsbGJhY2tzL29uLXJlY292ZXJhYmxlLWVycm9yLmpzIiwibWFwcGluZ3MiOiJBQUFBLHFFQUFxRTs7Ozs7Ozs7Ozs7OztJQVNyREEsa0JBQWtCO2VBQWxCQTs7SUFJSEMsa0JBQWtCO2VBQWxCQTs7OzswQ0FWdUI7OEVBQ2hCOytDQUNjO0FBRWxDLE1BQU1DLG9CQUFvQixJQUFJQztBQUV2QixTQUFTSCxtQkFBbUJJLEtBQVk7SUFDN0MsT0FBT0Ysa0JBQWtCRyxHQUFHLENBQUNEO0FBQy9CO0FBRU8sTUFBTUgscUJBQTZELENBQ3hFRztJQUVBLHNEQUFzRDtJQUN0RCxJQUFJRSxRQUFRQyxDQUFBQSxHQUFBQSxTQUFBQSxPQUFBQSxFQUFRSCxVQUFVLFdBQVdBLFFBQVFBLE1BQU1FLEtBQUssR0FBR0Y7SUFDL0QsNkVBQTZFO0lBQzdFLElBQUlJLENBQUFBLEdBQUFBLGNBQUFBLG1CQUFBQSxFQUFvQkYsUUFBUTtJQUVoQyxJQUFJRyxJQUFvQixFQUFtQjtRQUN6QyxNQUFNLEVBQUVHLGdCQUFnQixFQUFFLEdBQ3hCQyxtQkFBT0EsQ0FBQyw4T0FBeUQ7UUFDbkUsTUFBTUMsYUFBYUYsaUJBQWlCTjtRQUNwQ0osa0JBQWtCYSxHQUFHLENBQUNEO1FBQ3RCUixRQUFRUTtJQUNWO0lBRUFFLENBQUFBLEdBQUFBLG1CQUFBQSxpQkFBQUEsRUFBa0JWO0FBQ3BCIiwic291cmNlcyI6WyIvVXNlcnMvc2FiaW5lcmVzb2FnbGkvc3JjL2NsaWVudC9yZWFjdC1jbGllbnQtY2FsbGJhY2tzL29uLXJlY292ZXJhYmxlLWVycm9yLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRoaXMgbW9kdWxlIGNhbiBiZSBzaGFyZWQgYmV0d2VlbiBib3RoIHBhZ2VzIHJvdXRlciBhbmQgYXBwIHJvdXRlclxuXG5pbXBvcnQgdHlwZSB7IEh5ZHJhdGlvbk9wdGlvbnMgfSBmcm9tICdyZWFjdC1kb20vY2xpZW50J1xuaW1wb3J0IHsgaXNCYWlsb3V0VG9DU1JFcnJvciB9IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvbGF6eS1keW5hbWljL2JhaWxvdXQtdG8tY3NyJ1xuaW1wb3J0IGlzRXJyb3IgZnJvbSAnLi4vLi4vbGliL2lzLWVycm9yJ1xuaW1wb3J0IHsgcmVwb3J0R2xvYmFsRXJyb3IgfSBmcm9tICcuL3JlcG9ydC1nbG9iYWwtZXJyb3InXG5cbmNvbnN0IHJlY292ZXJhYmxlRXJyb3JzID0gbmV3IFdlYWtTZXQ8RXJyb3I+KClcblxuZXhwb3J0IGZ1bmN0aW9uIGlzUmVjb3ZlcmFibGVFcnJvcihlcnJvcjogRXJyb3IpOiBib29sZWFuIHtcbiAgcmV0dXJuIHJlY292ZXJhYmxlRXJyb3JzLmhhcyhlcnJvcilcbn1cblxuZXhwb3J0IGNvbnN0IG9uUmVjb3ZlcmFibGVFcnJvcjogSHlkcmF0aW9uT3B0aW9uc1snb25SZWNvdmVyYWJsZUVycm9yJ10gPSAoXG4gIGVycm9yXG4pID0+IHtcbiAgLy8geC1yZWY6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzI4NzM2XG4gIGxldCBjYXVzZSA9IGlzRXJyb3IoZXJyb3IpICYmICdjYXVzZScgaW4gZXJyb3IgPyBlcnJvci5jYXVzZSA6IGVycm9yXG4gIC8vIFNraXAgY2VydGFpbiBjdXN0b20gZXJyb3JzIHdoaWNoIGFyZSBub3QgZXhwZWN0ZWQgdG8gYmUgcmVwb3J0ZWQgb24gY2xpZW50XG4gIGlmIChpc0JhaWxvdXRUb0NTUkVycm9yKGNhdXNlKSkgcmV0dXJuXG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjb25zdCB7IGRlY29yYXRlRGV2RXJyb3IgfSA9XG4gICAgICByZXF1aXJlKCcuLi8uLi9uZXh0LWRldnRvb2xzL3VzZXJzcGFjZS9hcHAvZXJyb3JzL3N0aXRjaGVkLWVycm9yJykgYXMgdHlwZW9mIGltcG9ydCgnLi4vLi4vbmV4dC1kZXZ0b29scy91c2Vyc3BhY2UvYXBwL2Vycm9ycy9zdGl0Y2hlZC1lcnJvcicpXG4gICAgY29uc3QgY2F1c2VFcnJvciA9IGRlY29yYXRlRGV2RXJyb3IoY2F1c2UpXG4gICAgcmVjb3ZlcmFibGVFcnJvcnMuYWRkKGNhdXNlRXJyb3IpXG4gICAgY2F1c2UgPSBjYXVzZUVycm9yXG4gIH1cblxuICByZXBvcnRHbG9iYWxFcnJvcihjYXVzZSlcbn1cbiJdLCJuYW1lcyI6WyJpc1JlY292ZXJhYmxlRXJyb3IiLCJvblJlY292ZXJhYmxlRXJyb3IiLCJyZWNvdmVyYWJsZUVycm9ycyIsIldlYWtTZXQiLCJlcnJvciIsImhhcyIsImNhdXNlIiwiaXNFcnJvciIsImlzQmFpbG91dFRvQ1NSRXJyb3IiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJkZWNvcmF0ZURldkVycm9yIiwicmVxdWlyZSIsImNhdXNlRXJyb3IiLCJhZGQiLCJyZXBvcnRHbG9iYWxFcnJvciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/react-client-callbacks/on-recoverable-error.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/route-params.js":
/*!***********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/route-params.js ***!
  \***********************************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    doesStaticSegmentAppearInURL: function() {\n        return doesStaticSegmentAppearInURL;\n    },\n    getCacheKeyForDynamicParam: function() {\n        return getCacheKeyForDynamicParam;\n    },\n    getParamValueFromCacheKey: function() {\n        return getParamValueFromCacheKey;\n    },\n    getRenderedPathname: function() {\n        return getRenderedPathname;\n    },\n    getRenderedSearch: function() {\n        return getRenderedSearch;\n    },\n    parseDynamicParamFromURLPart: function() {\n        return parseDynamicParamFromURLPart;\n    },\n    urlToUrlWithoutFlightMarker: function() {\n        return urlToUrlWithoutFlightMarker;\n    }\n});\nconst _segment = __webpack_require__(/*! ../shared/lib/segment */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/shared/lib/segment.js\");\nconst _segmentvalueencoding = __webpack_require__(/*! ../shared/lib/segment-cache/segment-value-encoding */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/shared/lib/segment-cache/segment-value-encoding.js\");\nconst _approuterheaders = __webpack_require__(/*! ./components/app-router-headers */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/components/app-router-headers.js\");\nfunction getRenderedSearch(response) {\n    // If the server performed a rewrite, the search params used to render the\n    // page will be different from the params in the request URL. In this case,\n    // the response will include a header that gives the rewritten search query.\n    const rewrittenQuery = response.headers.get(_approuterheaders.NEXT_REWRITTEN_QUERY_HEADER);\n    if (rewrittenQuery !== null) {\n        return rewrittenQuery === '' ? '' : '?' + rewrittenQuery;\n    }\n    // If the header is not present, there was no rewrite, so we use the search\n    // query of the response URL.\n    return urlToUrlWithoutFlightMarker(new URL(response.url)).search;\n}\nfunction getRenderedPathname(response) {\n    // If the server performed a rewrite, the pathname used to render the\n    // page will be different from the pathname in the request URL. In this case,\n    // the response will include a header that gives the rewritten pathname.\n    const rewrittenPath = response.headers.get(_approuterheaders.NEXT_REWRITTEN_PATH_HEADER);\n    return rewrittenPath != null ? rewrittenPath : urlToUrlWithoutFlightMarker(new URL(response.url)).pathname;\n}\nfunction parseDynamicParamFromURLPart(paramType, pathnameParts, partIndex) {\n    // This needs to match the behavior in get-dynamic-param.ts.\n    switch(paramType){\n        // Catchalls\n        case 'c':\n        case 'ci':\n            {\n                // Catchalls receive all the remaining URL parts. If there are no\n                // remaining pathname parts, return an empty array.\n                return partIndex < pathnameParts.length ? pathnameParts.slice(partIndex).map((s)=>encodeURIComponent(s)) : [];\n            }\n        // Optional catchalls\n        case 'oc':\n            {\n                // Optional catchalls receive all the remaining URL parts, unless this is\n                // the end of the pathname, in which case they return null.\n                return partIndex < pathnameParts.length ? pathnameParts.slice(partIndex).map((s)=>encodeURIComponent(s)) : null;\n            }\n        // Dynamic\n        case 'd':\n        case 'di':\n            {\n                if (partIndex >= pathnameParts.length) {\n                    // The route tree expected there to be more parts in the URL than there\n                    // actually are. This could happen if the x-nextjs-rewritten-path header\n                    // is incorrectly set, or potentially due to bug in Next.js. TODO:\n                    // Should this be a hard error? During a prefetch, we can just abort.\n                    // During a client navigation, we could trigger a hard refresh. But if\n                    // it happens during initial render, we don't really have any\n                    // recovery options.\n                    return '';\n                }\n                return encodeURIComponent(pathnameParts[partIndex]);\n            }\n        default:\n            paramType;\n            return '';\n    }\n}\nfunction doesStaticSegmentAppearInURL(segment) {\n    // This is not a parameterized segment; however, we need to determine\n    // whether or not this segment appears in the URL. For example, this route\n    // groups do not appear in the URL, so they should be skipped. Any other\n    // special cases must be handled here.\n    // TODO: Consider encoding this directly into the router tree instead of\n    // inferring it on the client based on the segment type. Something like\n    // a `doesAppearInURL` flag in FlightRouterState.\n    if (segment === _segmentvalueencoding.ROOT_SEGMENT_REQUEST_KEY || // For some reason, the loader tree sometimes includes extra __PAGE__\n    // \"layouts\" when part of a parallel route. But it's not a leaf node.\n    // Otherwise, we wouldn't need this special case because pages are\n    // always leaf nodes.\n    // TODO: Investigate why the loader produces these fake page segments.\n    segment.startsWith(_segment.PAGE_SEGMENT_KEY) || // Route groups.\n    segment[0] === '(' && segment.endsWith(')') || segment === _segment.DEFAULT_SEGMENT_KEY || segment === '/_not-found') {\n        return false;\n    } else {\n        // All other segment types appear in the URL\n        return true;\n    }\n}\nfunction getCacheKeyForDynamicParam(paramValue, renderedSearch) {\n    // This needs to match the logic in get-dynamic-param.ts, until we're able to\n    // unify the various implementations so that these are always computed on\n    // the client.\n    if (typeof paramValue === 'string') {\n        // TODO: Refactor or remove this helper function to accept a string rather\n        // than the whole segment type. Also we can probably just append the\n        // search string instead of turning it into JSON.\n        const pageSegmentWithSearchParams = (0, _segment.addSearchParamsIfPageSegment)(paramValue, Object.fromEntries(new URLSearchParams(renderedSearch)));\n        return pageSegmentWithSearchParams;\n    } else if (paramValue === null) {\n        return '';\n    } else {\n        return paramValue.join('/');\n    }\n}\nfunction urlToUrlWithoutFlightMarker(url) {\n    const urlWithoutFlightParameters = new URL(url);\n    urlWithoutFlightParameters.searchParams.delete(_approuterheaders.NEXT_RSC_UNION_QUERY);\n    if (false) {}\n    return urlWithoutFlightParameters;\n}\nfunction getParamValueFromCacheKey(paramCacheKey, paramType) {\n    // Turn the cache key string sent by the server (as part of FlightRouterState)\n    // into a value that can be passed to `useParams` and client components.\n    const isCatchAll = paramType === 'c' || paramType === 'oc';\n    if (isCatchAll) {\n        // Catch-all param keys are a concatenation of the path segments.\n        // See equivalent logic in `getSelectedParams`.\n        // TODO: We should just pass the array directly, rather than concatenate\n        // it to a string and then split it back to an array. It needs to be an\n        // array in some places, like when passing a key React, but we can convert\n        // it at runtime in those places.\n        return paramCacheKey.split('/');\n    }\n    return paramCacheKey;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=route-params.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE1LjUuMTJfcmVhY3QtZG9tQDE5LjIuNF9yZWFjdEAxOS4yLjRfX3JlYWN0QDE5LjIuNC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9yb3V0ZS1wYXJhbXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBOEZnQkEsNEJBQTRCO2VBQTVCQTs7SUE0QkFDLDBCQUEwQjtlQUExQkE7O0lBd0NBQyx5QkFBeUI7ZUFBekJBOztJQTNIQUMsbUJBQW1CO2VBQW5CQTs7SUFoQkFDLGlCQUFpQjtlQUFqQkE7O0lBMEJBQyw0QkFBNEI7ZUFBNUJBOztJQWdHQUMsMkJBQTJCO2VBQTNCQTs7O3FDQTVJVDtrREFDa0M7OENBS2xDO0FBWUEsU0FBU0Ysa0JBQWtCRyxRQUFxQjtJQUNyRCwwRUFBMEU7SUFDMUUsMkVBQTJFO0lBQzNFLDRFQUE0RTtJQUM1RSxNQUFNQyxpQkFBaUJELFNBQVNFLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDQyxrQkFBQUEsMkJBQTJCO0lBQ3ZFLElBQUlILG1CQUFtQixNQUFNO1FBQzNCLE9BQ0VBLG1CQUFtQixLQUFLLEtBQUssTUFBTUE7SUFFdkM7SUFDQSwyRUFBMkU7SUFDM0UsNkJBQTZCO0lBQzdCLE9BQU9GLDRCQUE0QixJQUFJTSxJQUFJTCxTQUFTTSxHQUFHLEdBQ3BEQyxNQUFNO0FBQ1g7QUFFTyxTQUFTWCxvQkFBb0JJLFFBQXFCO0lBQ3ZELHFFQUFxRTtJQUNyRSw2RUFBNkU7SUFDN0Usd0VBQXdFO0lBQ3hFLE1BQU1RLGdCQUFnQlIsU0FBU0UsT0FBTyxDQUFDQyxHQUFHLENBQUNNLGtCQUFBQSwwQkFBMEI7SUFDckUsT0FDRUQsaUJBQUFBLE9BQUFBLGdCQUFpQlQsNEJBQTRCLElBQUlNLElBQUlMLFNBQVNNLEdBQUcsR0FBR0ksUUFBUTtBQUVoRjtBQUVPLFNBQVNaLDZCQUNkYSxTQUFpQyxFQUNqQ0MsYUFBNEIsRUFDNUJDLFNBQWlCO0lB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LXBhcmFtcy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IER5bmFtaWNQYXJhbVR5cGVzU2hvcnQgfSBmcm9tICcuLi9zZXJ2ZXIvYXBwLXJlbmRlci90eXBlcydcbmltcG9ydCB7XG4gIGFkZFNlYXJjaFBhcmFtc0lmUGFnZVNlZ21lbnQsXG4gIERFRkFVTFRfU0VHTUVOVF9LRVksXG4gIFBBR0VfU0VHTUVOVF9LRVksXG59IGZyb20gJy4uL3NoYXJlZC9saWIvc2VnbWVudCdcbmltcG9ydCB7IFJPT1RfU0VHTUVOVF9SRVFVRVNUX0tFWSB9IGZyb20gJy4uL3NoYXJlZC9saWIvc2VnbWVudC1jYWNoZS9zZWdtZW50LXZhbHVlLWVuY29kaW5nJ1xuaW1wb3J0IHtcbiAgTkVYVF9SRVdSSVRURU5fUEFUSF9IRUFERVIsXG4gIE5FWFRfUkVXUklUVEVOX1FVRVJZX0hFQURFUixcbiAgTkVYVF9SU0NfVU5JT05fUVVFUlksXG59IGZyb20gJy4vY29tcG9uZW50cy9hcHAtcm91dGVyLWhlYWRlcnMnXG5pbXBvcnQgdHlwZSB7IE5vcm1hbGl6ZWRTZWFyY2ggfSBmcm9tICcuL2NvbXBvbmVudHMvc2VnbWVudC1jYWNoZSdcbmltcG9ydCB0eXBlIHsgUlNDUmVzcG9uc2UgfSBmcm9tICcuL2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvZmV0Y2gtc2VydmVyLXJlc3BvbnNlJ1xuXG5leHBvcnQgdHlwZSBSb3V0ZVBhcmFtVmFsdWUgPSBzdHJpbmcgfCBBcnJheTxzdHJpbmc+IHwgbnVsbFxuXG5leHBvcnQgdHlwZSBSb3V0ZVBhcmFtID0ge1xuICBuYW1lOiBzdHJpbmdcbiAgdmFsdWU6IFJvdXRlUGFyYW1WYWx1ZVxuICB0eXBlOiBEeW5hbWljUGFyYW1UeXBlc1Nob3J0XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSZW5kZXJlZFNlYXJjaChyZXNwb25zZTogUlNDUmVzcG9uc2UpOiBOb3JtYWxpemVkU2VhcmNoIHtcbiAgLy8gSWYgdGhlIHNlcnZlciBwZXJmb3JtZWQgYSByZXdyaXRlLCB0aGUgc2VhcmNoIHBhcmFtcyB1c2VkIHRvIHJlbmRlciB0aGVcbiAgLy8gcGFnZSB3aWxsIGJlIGRpZmZlcmVudCBmcm9tIHRoZSBwYXJhbXMgaW4gdGhlIHJlcXVlc3QgVVJMLiBJbiB0aGlzIGNhc2UsXG4gIC8vIHRoZSByZXNwb25zZSB3aWxsIGluY2x1ZGUgYSBoZWFkZXIgdGhhdCBnaXZlcyB0aGUgcmV3cml0dGVuIHNlYXJjaCBxdWVyeS5cbiAgY29uc3QgcmV3cml0dGVuUXVlcnkgPSByZXNwb25zZS5oZWFkZXJzLmdldChORVhUX1JFV1JJVFRFTl9RVUVSWV9IRUFERVIpXG4gIGlmIChyZXdyaXR0ZW5RdWVyeSAhPT0gbnVsbCkge1xuICAgIHJldHVybiAoXG4gICAgICByZXdyaXR0ZW5RdWVyeSA9PT0gJycgPyAnJyA6ICc/JyArIHJld3JpdHRlblF1ZXJ5XG4gICAgKSBhcyBOb3JtYWxpemVkU2VhcmNoXG4gIH1cbiAgLy8gSWYgdGhlIGhlYWRlciBpcyBub3QgcHJlc2VudCwgdGhlcmUgd2FzIG5vIHJld3JpdGUsIHNvIHdlIHVzZSB0aGUgc2VhcmNoXG4gIC8vIHF1ZXJ5IG9mIHRoZSByZXNwb25zZSBVUkwuXG4gIHJldHVybiB1cmxUb1VybFdpdGhvdXRGbGlnaHRNYXJrZXIobmV3IFVSTChyZXNwb25zZS51cmwpKVxuICAgIC5zZWFyY2ggYXMgTm9ybWFsaXplZFNlYXJjaFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmVuZGVyZWRQYXRobmFtZShyZXNwb25zZTogUlNDUmVzcG9uc2UpOiBzdHJpbmcge1xuICAvLyBJZiB0aGUgc2VydmVyIHBlcmZvcm1lZCBhIHJld3JpdGUsIHRoZSBwYXRobmFtZSB1c2VkIHRvIHJlbmRlciB0aGVcbiAgLy8gcGFnZSB3aWxsIGJlIGRpZmZlcmVudCBmcm9tIHRoZSBwYXRobmFtZSBpbiB0aGUgcmVxdWVzdCBVUkwuIEluIHRoaXMgY2FzZSxcbiAgLy8gdGhlIHJlc3BvbnNlIHdpbGwgaW5jbHVkZSBhIGhlYWRlciB0aGF0IGdpdmVzIHRoZSByZXdyaXR0ZW4gcGF0aG5hbWUuXG4gIGNvbnN0IHJld3JpdHRlblBhdGggPSByZXNwb25zZS5oZWFkZXJzLmdldChORVhUX1JFV1JJVFRFTl9QQVRIX0hFQURFUilcbiAgcmV0dXJuIChcbiAgICByZXdyaXR0ZW5QYXRoID8/IHVybFRvVXJsV2l0aG91dEZsaWdodE1hcmtlcihuZXcgVVJMKHJlc3BvbnNlLnVybCkpLnBhdGhuYW1lXG4gIClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRHluYW1pY1BhcmFtRnJvbVVSTFBhcnQoXG4gIHBhcmFtVHlwZTogRHluYW1pY1BhcmFtVHlwZXNTaG9ydCxcbiAgcGF0aG5hbWVQYXJ0czogQXJyYXk8c3RyaW5nPixcbiAgcGFydEluZGV4OiBudW1iZXJcbik6IFJvdXRlUGFyYW1WYWx1ZSB7XG4gIC8vIFRoaXMgbmVlZHMgdG8gbWF0Y2ggdGhlIGJlaGF2aW9yIGluIGdldC1keW5hbWljLXBhcmFtLnRzLlxuICBzd2l0Y2ggKHBhcmFtVHlwZSkge1xuICAgIC8vIENhdGNoYWxsc1xuICAgIGNhc2UgJ2MnOlxuICAgIGNhc2UgJ2NpJzoge1xuICAgICAgLy8gQ2F0Y2hhbGxzIHJlY2VpdmUgYWxsIHRoZSByZW1haW5pbmcgVVJMIHBhcnRzLiBJZiB0aGVyZSBhcmUgbm9cbiAgICAgIC8vIHJlbWFpbmluZyBwYXRobmFtZSBwYXJ0cywgcmV0dXJuIGFuIGVtcHR5IGFycmF5LlxuICAgICAgcmV0dXJuIHBhcnRJbmRleCA8IHBhdGhuYW1lUGFydHMubGVuZ3RoXG4gICAgICAgID8gcGF0aG5hbWVQYXJ0cy5zbGljZShwYXJ0SW5kZXgpLm1hcCgocykgPT4gZW5jb2RlVVJJQ29tcG9uZW50KHMpKVxuICAgICAgICA6IFtdXG4gICAgfVxuICAgIC8vIE9wdGlvbmFsIGNhdGNoYWxsc1xuICAgIGNhc2UgJ29jJzoge1xuICAgICAgLy8gT3B0aW9uYWwgY2F0Y2hhbGxzIHJlY2VpdmUgYWxsIHRoZSByZW1haW5pbmcgVVJMIHBhcnRzLCB1bmxlc3MgdGhpcyBpc1xuICAgICAgLy8gdGhlIGVuZCBvZiB0aGUgcGF0aG5hbWUsIGluIHdoaWNoIGNhc2UgdGhleSByZXR1cm4gbnVsbC5cbiAgICAgIHJldHVybiBwYXJ0SW5kZXggPCBwYXRobmFtZVBhcnRzLmxlbmd0aFxuICAgICAgICA/IHBhdGhuYW1lUGFydHMuc2xpY2UocGFydEluZGV4KS5tYXAoKHMpID0+IGVuY29kZVVSSUNvbXBvbmVudChzKSlcbiAgICAgICAgOiBudWxsXG4gICAgfVxuICAgIC8vIER5bmFtaWNcbiAgICBjYXNlICdkJzpcbiAgICBjYXNlICdkaSc6IHtcbiAgICAgIGlmIChwYXJ0SW5kZXggPj0gcGF0aG5hbWVQYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgLy8gVGhlIHJvdXRlIHRyZWUgZXhwZWN0ZWQgdGhlcmUgdG8gYmUgbW9yZSBwYXJ0cyBpbiB0aGUgVVJMIHRoYW4gdGhlcmVcbiAgICAgICAgLy8gYWN0dWFsbHkgYXJlLiBUaGlzIGNvdWxkIGhhcHBlbiBpZiB0aGUgeC1uZXh0anMtcmV3cml0dGVuLXBhdGggaGVhZGVyXG4gICAgICAgIC8vIGlzIGluY29ycmVjdGx5IHNldCwgb3IgcG90ZW50aWFsbHkgZHVlIHRvIGJ1ZyBpbiBOZXh0LmpzLiBUT0RPOlxuICAgICAgICAvLyBTaG91bGQgdGhpcyBiZSBhIGhhcmQgZXJyb3I/IER1cmluZyBhIHByZWZldGNoLCB3ZSBjYW4ganVzdCBhYm9ydC5cbiAgICAgICAgLy8gRHVyaW5nIGEgY2xpZW50IG5hdmlnYXRpb24sIHdlIGNvdWxkIHRyaWdnZXIgYSBoYXJkIHJlZnJlc2guIEJ1dCBpZlxuICAgICAgICAvLyBpdCBoYXBwZW5zIGR1cmluZyBpbml0aWFsIHJlbmRlciwgd2UgZG9uJ3QgcmVhbGx5IGhhdmUgYW55XG4gICAgICAgIC8vIHJlY292ZXJ5IG9wdGlvbnMuXG4gICAgICAgIHJldHVybiAnJ1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChwYXRobmFtZVBhcnRzW3BhcnRJbmRleF0pXG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICBwYXJhbVR5cGUgc2F0aXNmaWVzIG5ldmVyXG4gICAgICByZXR1cm4gJydcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZG9lc1N0YXRpY1NlZ21lbnRBcHBlYXJJblVSTChzZWdtZW50OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgLy8gVGhpcyBpcyBub3QgYSBwYXJhbWV0ZXJpemVkIHNlZ21lbnQ7IGhvd2V2ZXIsIHdlIG5lZWQgdG8gZGV0ZXJtaW5lXG4gIC8vIHdoZXRoZXIgb3Igbm90IHRoaXMgc2VnbWVudCBhcHBlYXJzIGluIHRoZSBVUkwuIEZvciBleGFtcGxlLCB0aGlzIHJvdXRlXG4gIC8vIGdyb3VwcyBkbyBub3QgYXBwZWFyIGluIHRoZSBVUkwsIHNvIHRoZXkgc2hvdWxkIGJlIHNraXBwZWQuIEFueSBvdGhlclxuICAvLyBzcGVjaWFsIGNhc2VzIG11c3QgYmUgaGFuZGxlZCBoZXJlLlxuICAvLyBUT0RPOiBDb25zaWRlciBlbmNvZGluZyB0aGlzIGRpcmVjdGx5IGludG8gdGhlIHJvdXRlciB0cmVlIGluc3RlYWQgb2ZcbiAgLy8gaW5mZXJyaW5nIGl0IG9uIHRoZSBjbGllbnQgYmFzZWQgb24gdGhlIHNlZ21lbnQgdHlwZS4gU29tZXRoaW5nIGxpa2VcbiAgLy8gYSBgZG9lc0FwcGVhckluVVJMYCBmbGFnIGluIEZsaWdodFJvdXRlclN0YXRlLlxuICBpZiAoXG4gICAgc2VnbWVudCA9PT0gUk9PVF9TRUdNRU5UX1JFUVVFU1RfS0VZIHx8XG4gICAgLy8gRm9yIHNvbWUgcmVhc29uLCB0aGUgbG9hZGVyIHRyZWUgc29tZXRpbWVzIGluY2x1ZGVzIGV4dHJhIF9fUEFHRV9fXG4gICAgLy8gXCJsYXlvdXRzXCIgd2hlbiBwYXJ0IG9mIGEgcGFyYWxsZWwgcm91dGUuIEJ1dCBpdCdzIG5vdCBhIGxlYWYgbm9kZS5cbiAgICAvLyBPdGhlcndpc2UsIHdlIHdvdWxkbid0IG5lZWQgdGhpcyBzcGVjaWFsIGNhc2UgYmVjYXVzZSBwYWdlcyBhcmVcbiAgICAvLyBhbHdheXMgbGVhZiBub2Rlcy5cbiAgICAvLyBUT0RPOiBJbnZlc3RpZ2F0ZSB3aHkgdGhlIGxvYWRlciBwcm9kdWNlcyB0aGVzZSBmYWtlIHBhZ2Ugc2VnbWVudHMuXG4gICAgc2VnbWVudC5zdGFydHNXaXRoKFBBR0VfU0VHTUVOVF9LRVkpIHx8XG4gICAgLy8gUm91dGUgZ3JvdXBzLlxuICAgIChzZWdtZW50WzBdID09PSAnKCcgJiYgc2VnbWVudC5lbmRzV2l0aCgnKScpKSB8fFxuICAgIHNlZ21lbnQgPT09IERFRkFVTFRfU0VHTUVOVF9LRVkgfHxcbiAgICBzZWdtZW50ID09PSAnL19ub3QtZm91bmQnXG4gICkge1xuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2Uge1xuICAgIC8vIEFsbCBvdGhlciBzZWdtZW50IHR5cGVzIGFwcGVhciBpbiB0aGUgVVJMXG4gICAgcmV0dXJuIHRydWVcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2FjaGVLZXlGb3JEeW5hbWljUGFyYW0oXG4gIHBhcmFtVmFsdWU6IFJvdXRlUGFyYW1WYWx1ZSxcbiAgcmVuZGVyZWRTZWFyY2g6IE5vcm1hbGl6ZWRTZWFyY2hcbik6IHN0cmluZyB7XG4gIC8vIFRoaXMgbmVlZHMgdG8gbWF0Y2ggdGhlIGxvZ2ljIGluIGdldC1keW5hbWljLXBhcmFtLnRzLCB1bnRpbCB3ZSdyZSBhYmxlIHRvXG4gIC8vIHVuaWZ5IHRoZSB2YXJpb3VzIGltcGxlbWVudGF0aW9ucyBzbyB0aGF0IHRoZXNlIGFyZSBhbHdheXMgY29tcHV0ZWQgb25cbiAgLy8gdGhlIGNsaWVudC5cbiAgaWYgKHR5cGVvZiBwYXJhbVZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIC8vIFRPRE86IFJlZmFjdG9yIG9yIHJlbW92ZSB0aGlzIGhlbHBlciBmdW5jdGlvbiB0byBhY2NlcHQgYSBzdHJpbmcgcmF0aGVyXG4gICAgLy8gdGhhbiB0aGUgd2hvbGUgc2VnbWVudCB0eXBlLiBBbHNvIHdlIGNhbiBwcm9iYWJseSBqdXN0IGFwcGVuZCB0aGVcbiAgICAvLyBzZWFyY2ggc3RyaW5nIGluc3RlYWQgb2YgdHVybmluZyBpdCBpbnRvIEpTT04uXG4gICAgY29uc3QgcGFnZVNlZ21lbnRXaXRoU2VhcmNoUGFyYW1zID0gYWRkU2VhcmNoUGFyYW1zSWZQYWdlU2VnbWVudChcbiAgICAgIHBhcmFtVmFsdWUsXG4gICAgICBPYmplY3QuZnJvbUVudHJpZXMobmV3IFVSTFNlYXJjaFBhcmFtcyhyZW5kZXJlZFNlYXJjaCkpXG4gICAgKSBhcyBzdHJpbmdcbiAgICByZXR1cm4gcGFnZVNlZ21lbnRXaXRoU2VhcmNoUGFyYW1zXG4gIH0gZWxzZSBpZiAocGFyYW1WYWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiAnJ1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwYXJhbVZhbHVlLmpvaW4oJy8nKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cmxUb1VybFdpdGhvdXRGbGlnaHRNYXJrZXIodXJsOiBVUkwpOiBVUkwge1xuICBjb25zdCB1cmxXaXRob3V0RmxpZ2h0UGFyYW1ldGVycyA9IG5ldyBVUkwodXJsKVxuICB1cmxXaXRob3V0RmxpZ2h0UGFyYW1ldGVycy5zZWFyY2hQYXJhbXMuZGVsZXRlKE5FWFRfUlNDX1VOSU9OX1FVRVJZKVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChcbiAgICAgIHByb2Nlc3MuZW52Ll9fTkVYVF9DT05GSUdfT1VUUFVUID09PSAnZXhwb3J0JyAmJlxuICAgICAgdXJsV2l0aG91dEZsaWdodFBhcmFtZXRlcnMucGF0aG5hbWUuZW5kc1dpdGgoJy50eHQnKVxuICAgICkge1xuICAgICAgY29uc3QgeyBwYXRobmFtZSB9ID0gdXJsV2l0aG91dEZsaWdodFBhcmFtZXRlcnNcbiAgICAgIGNvbnN0IGxlbmd0aCA9IHBhdGhuYW1lLmVuZHNXaXRoKCcvaW5kZXgudHh0JykgPyAxMCA6IDRcbiAgICAgIC8vIFNsaWNlIG9mZiBgL2luZGV4LnR4dGAgb3IgYC50eHRgIGZyb20gdGhlIGVuZCBvZiB0aGUgcGF0aG5hbWVcbiAgICAgIHVybFdpdGhvdXRGbGlnaHRQYXJhbWV0ZXJzLnBhdGhuYW1lID0gcGF0aG5hbWUuc2xpY2UoMCwgLWxlbmd0aClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVybFdpdGhvdXRGbGlnaHRQYXJhbWV0ZXJzXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRQYXJhbVZhbHVlRnJvbUNhY2hlS2V5KFxuICBwYXJhbUNhY2hlS2V5OiBzdHJpbmcsXG4gIHBhcmFtVHlwZTogRHluYW1pY1BhcmFtVHlwZXNTaG9ydFxuKSB7XG4gIC8vIFR1cm4gdGhlIGNhY2hlIGtleSBzdHJpbmcgc2VudCBieSB0aGUgc2VydmVyIChhcyBwYXJ0IG9mIEZsaWdodFJvdXRlclN0YXRlKVxuICAvLyBpbnRvIGEgdmFsdWUgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIGB1c2VQYXJhbXNgIGFuZCBjbGllbnQgY29tcG9uZW50cy5cbiAgY29uc3QgaXNDYXRjaEFsbCA9IHBhcmFtVHlwZSA9PT0gJ2MnIHx8IHBhcmFtVHlwZSA9PT0gJ29jJ1xuICBpZiAoaXNDYXRjaEFsbCkge1xuICAgIC8vIENhdGNoLWFsbCBwYXJhbSBrZXlzIGFyZSBhIGNvbmNhdGVuYXRpb24gb2YgdGhlIHBhdGggc2VnbWVudHMuXG4gICAgLy8gU2VlIGVxdWl2YWxlbnQgbG9naWMgaW4gYGdldFNlbGVjdGVkUGFyYW1zYC5cbiAgICAvLyBUT0RPOiBXZSBzaG91bGQganVzdCBwYXNzIHRoZSBhcnJheSBkaXJlY3RseSwgcmF0aGVyIHRoYW4gY29uY2F0ZW5hdGVcbiAgICAvLyBpdCB0byBhIHN0cmluZyBhbmQgdGhlbiBzcGxpdCBpdCBiYWNrIHRvIGFuIGFycmF5LiBJdCBuZWVkcyB0byBiZSBhblxuICAgIC8vIGFycmF5IGluIHNvbWUgcGxhY2VzLCBsaWtlIHdoZW4gcGFzc2luZyBhIGtleSBSZWFjdCwgYnV0IHdlIGNhbiBjb252ZXJ0XG4gICAgLy8gaXQgYXQgcnVudGltZSBpbiB0aG9zZSBwbGFjZXMuXG4gICAgcmV0dXJuIHBhcmFtQ2FjaGVLZXkuc3BsaXQoJy8nKVxuICB9XG4gIHJldHVybiBwYXJhbUNhY2hlS2V5XG59XG4iXSwibmFtZXMiOlsiZG9lc1N0YXRpY1NlZ21lbnRBcHBlYXJJblVSTCIsImdldENhY2hlS2V5Rm9yRHluYW1pY1BhcmFtIiwiZ2V0UGFyYW1WYWx1ZUZyb21DYWNoZUtleSIsImdldFJlbmRlcmVkUGF0aG5hbWUiLCJnZXRSZW5kZXJlZFNlYXJjaCIsInBhcnNlRHluYW1pY1BhcmFtRnJvbVVSTFBhcnQiLCJ1cmxUb1VybFdpdGhvdXRGbGlnaHRNYXJrZXIiLCJyZXNwb25zZSIsInJld3JpdHRlblF1ZXJ5IiwiaGVhZGVycyIsImdldCIsIk5FWFRfUkVXUklUVEVOX1FVRVJZX0hFQURFUiIsIlVSTCIsInVybCIsInNlYXJjaCIsInJld3JpdHRlblBhdGgiLCJORVhUX1JFV1JJVFRFTl9QQVRIX0hFQURFUiIsInBhdGhuYW1lIiwicGFyYW1UeXBlIiwicGF0aG5hbWVQYXJ0cyIsInBhcnRJbmRleCIsImxlbmd0aCIsInNsaWNlIiwibWFwIiwicyIsImVuY29kZVVSSUNvbXBvbmVudCIsInNlZ21lbnQiLCJST09UX1NFR01FTlRfUkVRVUVTVF9LRVkiLCJzdGFydHNXaXRoIiwiUEFHRV9TRUdNRU5UX0tFWSIsImVuZHNXaXRoIiwiREVGQVVMVF9TRUdNRU5UX0tFWSIsInBhcmFtVmFsdWUiLCJyZW5kZXJlZFNlYXJjaCIsInBhZ2VTZWdtZW50V2l0aFNlYXJjaFBhcmFtcyIsImFkZFNlYXJjaFBhcmFtc0lmUGFnZVNlZ21lbnQiLCJPYmplY3QiLCJmcm9tRW50cmllcyIsIlVSTFNlYXJjaFBhcmFtcyIsImpvaW4iLCJ1cmxXaXRob3V0RmxpZ2h0UGFyYW1ldGVycyIsInNlYXJjaFBhcmFtcyIsImRlbGV0ZSIsIk5FWFRfUlNDX1VOSU9OX1FVRVJZIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiX19ORVhUX0NPTkZJR19PVVRQVVQiLCJwYXJhbUNhY2hlS2V5IiwiaXNDYXRjaEFsbCIsInNwbGl0Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/client/route-params.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/shared/lib/hooks-client-context.shared-runtime.js":
/*!**************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/shared/lib/hooks-client-context.shared-runtime.js ***!
  \**************************************************************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    PathParamsContext: function() {\n        return PathParamsContext;\n    },\n    PathnameContext: function() {\n        return PathnameContext;\n    },\n    SearchParamsContext: function() {\n        return SearchParamsContext;\n    }\n});\nconst _react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/compiled/react/index.js\");\nconst SearchParamsContext = (0, _react.createContext)(null);\nconst PathnameContext = (0, _react.createContext)(null);\nconst PathParamsContext = (0, _react.createContext)(null);\nif (true) {\n    SearchParamsContext.displayName = 'SearchParamsContext';\n    PathnameContext.displayName = 'PathnameContext';\n    PathParamsContext.displayName = 'PathParamsContext';\n} //# sourceMappingURL=hooks-client-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE1LjUuMTJfcmVhY3QtZG9tQDE5LjIuNF9yZWFjdEAxOS4yLjRfX3JlYWN0QDE5LjIuNC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvaG9va3MtY2xpZW50LWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBT2FBLGlCQUFpQjtlQUFqQkE7O0lBREFDLGVBQWU7ZUFBZkE7O0lBREFDLG1CQUFtQjtlQUFuQkE7OzttQ0FIaUI7QUFHdkIsTUFBTUEsc0JBQXNCQyxDQUFBQSxHQUFBQSxPQUFBQSxhQUFBQSxFQUFzQztBQUNsRSxNQUFNRixrQkFBa0JFLENBQUFBLEdBQUFBLE9BQUFBLGFBQUFBLEVBQTZCO0FBQ3JELE1BQU1ILG9CQUFvQkcsQ0FBQUEsR0FBQUEsT0FBQUEsYUFBQUEsRUFBNkI7QUFFOUQsSUFBSUMsSUFBb0IsRUFBbUI7SUFDekNGLG9CQUFvQkssV0FBVyxHQUFHO0lBQ2xDTixnQkFBZ0JNLFdBQVcsR0FBRztJQUM5QlAsa0JBQWtCTyxXQUFXLEdBQUc7QUFDbEMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWJpbmVyZXNvYWdsaS9zcmMvc2hhcmVkL2xpYi9ob29rcy1jbGllbnQtY29udGV4dC5zaGFyZWQtcnVudGltZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHR5cGUgeyBQYXJhbXMgfSBmcm9tICcuLi8uLi9zZXJ2ZXIvcmVxdWVzdC9wYXJhbXMnXG5cbmV4cG9ydCBjb25zdCBTZWFyY2hQYXJhbXNDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxVUkxTZWFyY2hQYXJhbXMgfCBudWxsPihudWxsKVxuZXhwb3J0IGNvbnN0IFBhdGhuYW1lQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8c3RyaW5nIHwgbnVsbD4obnVsbClcbmV4cG9ydCBjb25zdCBQYXRoUGFyYW1zQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8UGFyYW1zIHwgbnVsbD4obnVsbClcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgU2VhcmNoUGFyYW1zQ29udGV4dC5kaXNwbGF5TmFtZSA9ICdTZWFyY2hQYXJhbXNDb250ZXh0J1xuICBQYXRobmFtZUNvbnRleHQuZGlzcGxheU5hbWUgPSAnUGF0aG5hbWVDb250ZXh0J1xuICBQYXRoUGFyYW1zQ29udGV4dC5kaXNwbGF5TmFtZSA9ICdQYXRoUGFyYW1zQ29udGV4dCdcbn1cbiJdLCJuYW1lcyI6WyJQYXRoUGFyYW1zQ29udGV4dCIsIlBhdGhuYW1lQ29udGV4dCIsIlNlYXJjaFBhcmFtc0NvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiZGlzcGxheU5hbWUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@15.5.12_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/next/dist/shared/lib/hooks-client-context.shared-runtime.js\n"));

/***/ })

});