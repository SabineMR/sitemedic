---
phase: 47-message-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/156_message_polish.sql
  - web/app/api/messages/[messageId]/status/route.ts
  - web/app/(dashboard)/messages/components/MessageStatusIndicator.tsx
  - web/app/(dashboard)/messages/components/MessageItem.tsx
  - web/lib/queries/comms.hooks.ts
  - web/app/(dashboard)/messages/components/MessageThread.tsx
  - web/app/api/messages/conversations/[id]/read/route.ts
autonomous: true

must_haves:
  truths:
    - "Sender's own messages show a single grey tick when sent, double grey tick when delivered to the recipient, and blue double tick when read by the recipient"
    - "Status ticks update in real-time without page refresh when the recipient's client receives or reads a message"
    - "Message status can only advance forward (sent -> delivered -> read), never backwards"
    - "When a new message INSERT arrives via Realtime for someone else's message, the client automatically fires a delivered status PATCH"
    - "When a user opens a conversation thread, all unread messages from the other party are marked as read (status advanced to 'read')"
  artifacts:
    - path: "supabase/migrations/156_message_polish.sql"
      provides: "updated_at auto-trigger for messages table, tsvector FTS column + GIN index"
      contains: "updated_at_trigger"
    - path: "web/app/api/messages/[messageId]/status/route.ts"
      provides: "PATCH endpoint for advancing message status"
      exports: ["PATCH"]
    - path: "web/app/(dashboard)/messages/components/MessageStatusIndicator.tsx"
      provides: "Visual tick indicator component for message delivery status"
      exports: ["MessageStatusIndicator"]
    - path: "web/app/(dashboard)/messages/components/MessageItem.tsx"
      provides: "Message row with integrated status indicator"
      contains: "MessageStatusIndicator"
    - path: "web/lib/queries/comms.hooks.ts"
      provides: "Realtime UPDATE subscription for live status changes + auto-delivered logic"
      contains: "event: 'UPDATE'"
  key_links:
    - from: "web/lib/queries/comms.hooks.ts"
      to: "/api/messages/[messageId]/status"
      via: "fetch PATCH on Realtime INSERT for other user's message"
      pattern: "fetch.*api/messages.*status"
    - from: "web/app/(dashboard)/messages/components/MessageItem.tsx"
      to: "web/app/(dashboard)/messages/components/MessageStatusIndicator.tsx"
      via: "import and render for own messages"
      pattern: "MessageStatusIndicator"
    - from: "web/app/api/messages/[messageId]/status/route.ts"
      to: "messages table"
      via: "UPDATE with forward-only WHERE clause"
      pattern: "status.*WHERE"
---

<objective>
Add delivery/read status indicators to messages: single tick (Sent), double tick (Delivered), blue double tick (Read). Status updates happen in real-time via Supabase Realtime UPDATE subscriptions. "Delivered" fires when recipient's web client receives a message via Realtime INSERT. "Read" fires when a conversation thread is opened (existing mark-as-read logic extended). Only the sender sees their own message status ticks (professional messaging context -- no ambiguity).

Purpose: Completes the messaging UX by giving senders feedback on whether their messages have been received and read, matching standard professional messaging expectations (WhatsApp/Slack tick pattern).
Output: Migration with updated_at trigger, PATCH /api/messages/[messageId]/status API, MessageStatusIndicator component, Realtime UPDATE subscription, auto-delivered-on-Realtime logic.
</objective>

<execution_context>
@/Users/sabineresoagli/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sabineresoagli/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/47-message-polish/47-RESEARCH.md

# Existing files to modify
@web/app/(dashboard)/messages/components/MessageItem.tsx
@web/app/(dashboard)/messages/components/MessageThread.tsx
@web/lib/queries/comms.hooks.ts
@web/types/comms.types.ts
@web/app/api/messages/send/route.ts
@web/app/api/messages/conversations/[id]/read/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migration + Status API endpoint</name>
  <files>
    supabase/migrations/156_message_polish.sql
    web/app/api/messages/[messageId]/status/route.ts
  </files>
  <action>
**Migration (156_message_polish.sql):**

Create a migration that adds:

1. An `updated_at` auto-update trigger for the `messages` table (the `updated_at` column already exists from migration 143, but needs a trigger to auto-set on UPDATE):
```sql
CREATE OR REPLACE FUNCTION update_messages_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER messages_updated_at_trigger
  BEFORE UPDATE ON messages
  FOR EACH ROW
  EXECUTE FUNCTION update_messages_updated_at();
```

2. A `fts` tsvector generated column on `messages` for full-text search (used by Plan 47-02, but included here to avoid a second migration):
```sql
ALTER TABLE messages ADD COLUMN fts tsvector
  GENERATED ALWAYS AS (to_tsvector('english', COALESCE(content, ''))) STORED;

CREATE INDEX idx_messages_fts ON messages USING GIN (fts);
```

3. Enable Supabase Realtime for UPDATE events on messages table:
```sql
-- Ensure messages table has replica identity for Realtime UPDATE payloads
ALTER TABLE messages REPLICA IDENTITY FULL;
```

**Status API (PATCH /api/messages/[messageId]/status):**

Create `web/app/api/messages/[messageId]/status/route.ts`:
- Accept PATCH with JSON body `{ status: 'delivered' | 'read' }`
- Authenticate user and get orgId via `requireOrgId()`
- Validate the requested status is either 'delivered' or 'read'
- Forward-only enforcement: use a STATUS_ORDER map (`sent: 0, delivered: 1, read: 2`) and only UPDATE if the new status rank is higher than current
- SQL pattern: `UPDATE messages SET status = $new_status WHERE id = $messageId AND org_id = $orgId AND (CASE WHEN status = 'sent' THEN 0 WHEN status = 'delivered' THEN 1 WHEN status = 'read' THEN 2 END) < (CASE WHEN $new_status = 'delivered' THEN 1 WHEN $new_status = 'read' THEN 2 END)`
- Simpler approach: Fetch current status first, compare in JS, then UPDATE with WHERE clause including current status for optimistic concurrency
- Return 200 on success (even if no rows updated -- idempotent), 401/400 on auth/validation failure
- The user calling the endpoint must NOT be the message sender (you don't mark your own messages as delivered/read -- the other party does)
- Also accept a `conversationId` query param for batch read marking: when status='read', allow bulk-updating all messages in a conversation from the other sender to 'read'
  </action>
  <verify>
- Migration file exists at `supabase/migrations/156_message_polish.sql`
- API route file exists at `web/app/api/messages/[messageId]/status/route.ts`
- `pnpm build` succeeds (TypeScript compilation)
  </verify>
  <done>
- Migration adds updated_at trigger, fts tsvector column with GIN index, and REPLICA IDENTITY FULL
- PATCH endpoint validates forward-only status transitions and prevents self-marking
- Endpoint supports both single-message and conversation-batch status updates
  </done>
</task>

<task type="auto">
  <name>Task 2: Status indicator component + Realtime UPDATE subscription + auto-delivered logic</name>
  <files>
    web/app/(dashboard)/messages/components/MessageStatusIndicator.tsx
    web/app/(dashboard)/messages/components/MessageItem.tsx
    web/lib/queries/comms.hooks.ts
    web/app/(dashboard)/messages/components/MessageThread.tsx
    web/app/api/messages/conversations/[id]/read/route.ts
  </files>
  <action>
**MessageStatusIndicator component (NEW):**

Create `web/app/(dashboard)/messages/components/MessageStatusIndicator.tsx`:
- Client component ('use client')
- Props: `{ status: MessageStatus; className?: string }`
- Import `Check` and `CheckCheck` from `lucide-react`, `cn` from `@/lib/utils`
- Render logic:
  - `'sent'`: `<Check className="h-3.5 w-3.5 text-muted-foreground" />`
  - `'delivered'`: `<CheckCheck className="h-3.5 w-3.5 text-muted-foreground" />`
  - `'read'`: `<CheckCheck className="h-3.5 w-3.5 text-blue-500" />`
  - default: return null
- Export named `MessageStatusIndicator`

**MessageItem modification:**

Update `web/app/(dashboard)/messages/components/MessageItem.tsx`:
- Import `MessageStatusIndicator`
- Only show status ticks for the sender's own messages (`isOwnMessage === true`)
- Place the indicator inline after the timestamp, in the same row:
```tsx
<span className="text-[11px] text-muted-foreground mt-1 inline-flex items-center gap-1">
  {timeDisplay}
  {isOwnMessage && <MessageStatusIndicator status={message.status} />}
</span>
```

**Realtime UPDATE subscription (comms.hooks.ts):**

Modify `useRealtimeMessages` in `web/lib/queries/comms.hooks.ts`:
1. Add a third `.on()` listener for `UPDATE` events on the `messages` table (in addition to existing INSERT on messages and UPDATE on conversations):
```typescript
.on(
  'postgres_changes',
  {
    event: 'UPDATE',
    schema: 'public',
    table: 'messages',
    filter: `org_id=eq.${orgId}`,
  },
  (payload) => {
    const conversationId = payload.new?.conversation_id;
    if (conversationId) {
      queryClient.invalidateQueries({
        queryKey: ['messages', conversationId],
      });
    }
  }
)
```

2. Add auto-delivered logic to the existing INSERT listener. After the existing invalidation logic, check if the new message is from another user and fire a PATCH to mark it as 'delivered':
```typescript
// In the INSERT handler, after existing invalidation:
// Auto-mark as "delivered" when we receive another user's message
const newMsg = payload.new;
if (newMsg?.sender_id && newMsg.sender_id !== currentUserId && newMsg.status === 'sent') {
  fetch(`/api/messages/${newMsg.id}/status`, {
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ status: 'delivered' }),
  }).catch(console.error); // Fire-and-forget
}
```

3. The hook needs access to `currentUserId`. Inside `useRealtimeMessages`, call `realtimeSupabase.auth.getUser()` once on mount, store in a ref (`currentUserIdRef`), and use that ref for the sender comparison in the INSERT handler. This is self-contained and requires no changes to the hook's call sites.

**MessageThread read status advancement:**

Update `web/app/(dashboard)/messages/components/MessageThread.tsx`:
- In the existing mark-as-read `useEffect` (lines 85-107), after the existing PATCH to `/api/messages/conversations/${conversationId}/read`, also fire a PATCH to `/api/messages/${messageId}/status` with `{ status: 'read' }` for the conversation. Use the batch approach: PATCH `/api/messages/batch-read/status` or pass `conversationId` as a query param to the status endpoint.
- Simpler: Update the existing `/api/messages/conversations/[id]/read` route to ALSO advance all messages from the other sender to `status: 'read'`. This keeps the mark-as-read as a single call.

**Preferred approach for read marking:**
Modify the existing `/api/messages/conversations/[id]/read/route.ts` to also run:
```sql
UPDATE messages SET status = 'read'
WHERE conversation_id = $conversationId
  AND sender_id != $currentUserId
  AND status IN ('sent', 'delivered')
```
This way, opening a thread marks all other-party messages as 'read' in one DB call alongside the existing conversation_read_status upsert. No changes needed to MessageThread.tsx beyond what already exists.
  </action>
  <verify>
- `pnpm build` succeeds
- MessageStatusIndicator renders Check for 'sent', CheckCheck for 'delivered', blue CheckCheck for 'read'
- MessageItem shows ticks only for own messages
- Realtime hook has three listeners: INSERT messages, UPDATE messages, UPDATE conversations
- Opening a conversation thread advances other sender's messages to 'read'
  </verify>
  <done>
- MessageStatusIndicator component shows grey single tick (sent), grey double tick (delivered), blue double tick (read)
- Only the message sender sees their own status ticks
- Realtime UPDATE subscription invalidates message queries when status changes, causing ticks to update live
- Incoming messages from other users auto-fire 'delivered' status update via Realtime INSERT handler
- Opening a conversation thread marks all other sender's messages as 'read' via the existing mark-as-read endpoint
  </done>
</task>

</tasks>

<verification>
1. Send a message as user A -- it shows a single grey tick (sent)
2. Open the same conversation as user B -- user A's tick should advance to blue double tick (read) in real-time
3. If user B has the app open but on a different conversation, user A's tick should advance to grey double tick (delivered) when the Realtime INSERT fires
4. Status never goes backwards (read -> delivered is impossible)
5. `pnpm build` succeeds with no TypeScript errors
6. Broadcast messages do NOT show status ticks (only direct messages between two parties)
</verification>

<success_criteria>
- Each message in a conversation thread shows a delivery status indicator next to the timestamp
- Status updates in real-time without page refresh
- Forward-only state machine: sent -> delivered -> read
- Only the sender sees their own message status (clean professional layout)
</success_criteria>

<output>
After completion, create `.planning/phases/47-message-polish/47-01-SUMMARY.md`
</output>
