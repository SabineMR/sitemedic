---
phase: 47-message-polish
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - web/app/api/messages/search/route.ts
  - web/app/(dashboard)/messages/components/ConversationSearch.tsx
  - web/app/(dashboard)/messages/components/SearchResultItem.tsx
  - web/app/(dashboard)/messages/components/ConversationList.tsx
  - web/lib/queries/comms.ts
  - web/lib/queries/comms.hooks.ts
autonomous: true

must_haves:
  truths:
    - "Users can type a keyword in a search input and see matching messages from all their conversations"
    - "Search results show the matching message text (with context), the conversation it belongs to, and the sender name"
    - "Clicking a search result navigates to that conversation thread"
    - "Search only returns messages the user has access to (org-scoped via RLS)"
    - "Empty and short queries (< 2 chars) show no results gracefully"
  artifacts:
    - path: "web/app/api/messages/search/route.ts"
      provides: "Full-text search API endpoint using PostgreSQL tsvector"
      exports: ["GET"]
    - path: "web/app/(dashboard)/messages/components/ConversationSearch.tsx"
      provides: "Search overlay panel with input and results list"
      exports: ["ConversationSearch"]
    - path: "web/app/(dashboard)/messages/components/SearchResultItem.tsx"
      provides: "Single search result row with message preview and conversation context"
      exports: ["SearchResultItem"]
    - path: "web/app/(dashboard)/messages/components/ConversationList.tsx"
      provides: "Conversation list with search toggle button"
      contains: "ConversationSearch"
    - path: "web/lib/queries/comms.hooks.ts"
      provides: "useMessageSearch hook for debounced search queries"
      contains: "useMessageSearch"
  key_links:
    - from: "web/app/(dashboard)/messages/components/ConversationSearch.tsx"
      to: "/api/messages/search"
      via: "useMessageSearch hook with debounced query"
      pattern: "useMessageSearch"
    - from: "web/app/(dashboard)/messages/components/SearchResultItem.tsx"
      to: "messages/[conversationId]"
      via: "Next.js Link navigation to conversation thread"
      pattern: "href.*messages/"
    - from: "web/app/api/messages/search/route.ts"
      to: "messages.fts"
      via: "Supabase textSearch on tsvector column"
      pattern: "textSearch.*fts"
---

<objective>
Add cross-conversation keyword search so users can find messages across all their conversations. A search icon in the conversation list header opens a search panel with a text input. As the user types (debounced), results show matching messages with sender name, conversation name, message snippet, and timestamp. Clicking a result navigates to that conversation thread.

Purpose: Enables users to quickly find past messages without scrolling through individual conversations -- essential for professional messaging where compliance or reference information needs to be retrieved.
Output: Search API route using PostgreSQL FTS, ConversationSearch panel component, SearchResultItem component, useMessageSearch hook, ConversationList integration.
</objective>

<execution_context>
@/Users/sabineresoagli/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sabineresoagli/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/47-message-polish/47-RESEARCH.md

# Existing files to modify
@web/app/(dashboard)/messages/components/ConversationList.tsx
@web/lib/queries/comms.ts
@web/lib/queries/comms.hooks.ts
@web/types/comms.types.ts

# NOTE: The tsvector `fts` column and GIN index are created in Plan 47-01's migration (156_message_polish.sql).
# This plan depends on that column existing at runtime, but the files don't overlap (47-01 creates the migration, this plan creates the search API and UI).
# Wave 1 is fine because both plans modify different files.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Search API endpoint and query function</name>
  <files>
    web/app/api/messages/search/route.ts
    web/lib/queries/comms.ts
    web/lib/queries/comms.hooks.ts
    web/types/comms.types.ts
  </files>
  <action>
**Search result type (comms.types.ts):**

Add to `web/types/comms.types.ts`:
```typescript
/** Search result for cross-conversation message search */
export interface MessageSearchResult {
  id: string;
  conversation_id: string;
  content: string;
  sender_id: string;
  sender_name: string;
  created_at: string;
  conversation_name: string;
  conversation_type: ConversationType;
}
```

**Search API route (GET /api/messages/search):**

Create `web/app/api/messages/search/route.ts`:
- Accept GET with query params: `q` (search term, required, min 2 chars), `limit` (optional, default 50, max 100)
- Authenticate user and get orgId via `requireOrgId()`
- Get current user for sender name resolution context
- Use Supabase JS `textSearch()` with type 'websearch' and config 'english':
```typescript
const { data: messages, error } = await supabase
  .from('messages')
  .select('id, conversation_id, content, sender_id, created_at')
  .textSearch('fts', q, { type: 'websearch', config: 'english' })
  .eq('org_id', orgId)
  .is('deleted_at', null)
  .order('created_at', { ascending: false })
  .limit(parsedLimit);
```
- If no results or error, return `{ results: [] }`
- Enrich results with sender names and conversation names:
  1. Collect unique sender_ids from results -> bulk query medics table for name resolution (same pattern as `fetchMessagesForConversation`)
  2. Collect unique conversation_ids from results -> query conversations table for subject, medic_id, type
  3. Resolve conversation names: for broadcast = "Broadcasts", for direct = medic name (if admin) or "Admin" (if medic) -- same logic as `fetchConversationsWithUnread`
- Return `{ results: MessageSearchResult[] }`
- Handle empty/short queries gracefully (return empty results, not an error)

**Search query function (comms.ts):**

Add a client-side search function to `web/lib/queries/comms.ts`:
```typescript
export async function searchMessages(query: string): Promise<MessageSearchResult[]> {
  if (!query || query.trim().length < 2) return [];
  const res = await fetch(`/api/messages/search?q=${encodeURIComponent(query.trim())}&limit=50`);
  if (!res.ok) return [];
  const data = await res.json();
  return data.results ?? [];
}
```

**useMessageSearch hook (comms.hooks.ts):**

Add to `web/lib/queries/comms.hooks.ts`:
```typescript
import { searchMessages } from './comms';

export function useMessageSearch(query: string) {
  return useQuery({
    queryKey: ['message-search', query],
    queryFn: () => searchMessages(query),
    enabled: query.trim().length >= 2,
    staleTime: 60_000, // 1 minute
    placeholderData: (prev) => prev, // Keep previous results while loading new
  });
}
```
Import `MessageSearchResult` from comms.types.ts.
  </action>
  <verify>
- API route file exists at `web/app/api/messages/search/route.ts`
- `pnpm build` succeeds
- Search function and hook are exported from comms.ts and comms.hooks.ts
  </verify>
  <done>
- Search API uses PostgreSQL full-text search via Supabase textSearch('fts', ...) with websearch type
- Results enriched with sender names and conversation names
- Client-side hook provides debounced-friendly search with placeholderData for smooth UX
- Short queries (< 2 chars) return empty results without API call
  </done>
</task>

<task type="auto">
  <name>Task 2: Search UI components and ConversationList integration</name>
  <files>
    web/app/(dashboard)/messages/components/SearchResultItem.tsx
    web/app/(dashboard)/messages/components/ConversationSearch.tsx
    web/app/(dashboard)/messages/components/ConversationList.tsx
  </files>
  <action>
**SearchResultItem component (NEW):**

Create `web/app/(dashboard)/messages/components/SearchResultItem.tsx`:
- Client component ('use client')
- Props: `{ result: MessageSearchResult; onClick: () => void }`
- Layout: Compact row showing:
  - Top line: conversation name (bold) + timestamp (right-aligned, muted)
  - Middle line: message content snippet (truncated to ~120 chars, text-sm)
  - Bottom line: sender name (muted, text-xs)
- Use `Link` from next/link to navigate to `/messages/${result.conversation_id}` on click
- Truncate content: `result.content?.substring(0, 120) + (result.content?.length > 120 ? '...' : '')`
- Format timestamp using the same `formatMessageTime` pattern from MessageItem (extract to shared util or duplicate the small function)
- Hover state: `hover:bg-muted/50 cursor-pointer` for interactive feel
- Border bottom for visual separation between results

**ConversationSearch component (NEW):**

Create `web/app/(dashboard)/messages/components/ConversationSearch.tsx`:
- Client component ('use client')
- Props: `{ open: boolean; onClose: () => void }`
- When `open` is true, render an overlay panel that slides in over the conversation list area (position absolute, full height, white background, z-10)
- Contains:
  1. Header: "Search Messages" title + X close button (import `X` from lucide-react)
  2. Search input: autoFocus, with Search icon prefix, debounced onChange (300ms debounce using a useState + useEffect setTimeout pattern)
  3. Results area: scrollable list of SearchResultItem components
  4. Empty states:
     - No query yet: "Type to search across all conversations"
     - Query too short: "Enter at least 2 characters"
     - No results: "No messages found for \"{query}\""
     - Loading: show a subtle spinner or "Searching..." text
- Use `useMessageSearch` hook with the debounced query string
- On result click: navigate via router.push or Link, then call onClose()

**ConversationList integration:**

Update `web/app/(dashboard)/messages/components/ConversationList.tsx`:
- Import `ConversationSearch` component
- Add state: `const [searchOpen, setSearchOpen] = useState(false)`
- Replace the existing local-filter search input with a dual-purpose approach:
  - Keep the existing Input for local conversation name filtering (it already works well)
  - Add a small icon button (Search with a magnifying glass + "All" label or tooltip) next to the search input that toggles the full ConversationSearch overlay
  - OR: Add a text link below the search bar: "Search all messages..." that opens ConversationSearch
- Render `<ConversationSearch open={searchOpen} onClose={() => setSearchOpen(false)} />` as a sibling inside the conversation list container (absolute positioned, so it overlays the list when open)
  </action>
  <verify>
- `pnpm build` succeeds
- ConversationSearch component renders search input and results
- SearchResultItem navigates to the correct conversation on click
- ConversationList has a visible way to open the cross-conversation search
  </verify>
  <done>
- Cross-conversation search panel overlays conversation list with search input and results
- Results show message content, conversation name, sender name, and timestamp
- Clicking a result navigates to the conversation thread
- Search is debounced (300ms) and only fires for queries >= 2 characters
- Clean empty states for no query, short query, and no results
  </done>
</task>

</tasks>

<verification>
1. Open messages page, click "Search all messages" button
2. Type a keyword that exists in a message -- results appear after debounce
3. Results show conversation name, sender name, message snippet, and timestamp
4. Click a result -- navigates to that conversation thread
5. Type a keyword with no matches -- "No messages found" empty state appears
6. Type only 1 character -- no API call fires, "Enter at least 2 characters" shown
7. `pnpm build` succeeds with no TypeScript errors
</verification>

<success_criteria>
- Users can search across all their conversations by keyword
- Results show matching message, conversation, sender, and timestamp
- Clicking a result navigates to the conversation thread
- Search is fast (backed by PostgreSQL GIN index) and debounced
</success_criteria>

<output>
After completion, create `.planning/phases/47-message-polish/47-02-SUMMARY.md`
</output>
