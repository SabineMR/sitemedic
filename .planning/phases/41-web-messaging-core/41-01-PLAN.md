---
phase: 41-web-messaging-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - web/lib/queries/comms.ts
  - web/app/(dashboard)/messages/page.tsx
  - web/app/(dashboard)/messages/components/ConversationList.tsx
  - web/app/(dashboard)/messages/components/ConversationRow.tsx
  - web/app/(dashboard)/messages/components/EmptyState.tsx
  - web/components/dashboard/DashboardNav.tsx
  - web/app/(dashboard)/layout.tsx
autonomous: true

must_haves:
  truths:
    - "Authenticated users see a 'Messages' item in the sidebar navigation that navigates to /messages"
    - "The /messages page loads a two-panel layout with a conversation list sidebar (~300px) on the left and a content area on the right"
    - "The conversation list displays all direct conversations for the user's org, sorted by most recent message first"
    - "Each conversation row shows the other party's name, a truncated last message preview, relative timestamp, and an unread count badge"
    - "The unread count is computed by counting messages created after the user's last_read_at where sender_id is not the current user"
    - "When no conversations exist, an empty state is shown with a 'Start a conversation' button"
    - "The dashboard header includes a message icon with a total unread count badge that navigates to /messages"
  artifacts:
    - path: "web/lib/queries/comms.ts"
      provides: "Server-side and client-side query functions for conversations with unread counts"
      exports: ["fetchConversationsWithUnread", "useConversations"]
    - path: "web/app/(dashboard)/messages/page.tsx"
      provides: "Server component that fetches conversations and renders the two-panel messaging layout"
    - path: "web/app/(dashboard)/messages/components/ConversationList.tsx"
      provides: "Client component rendering the scrollable list of conversation rows with search filter"
      exports: ["ConversationList"]
    - path: "web/app/(dashboard)/messages/components/ConversationRow.tsx"
      provides: "Single conversation row component with name, preview, time, unread badge"
      exports: ["ConversationRow"]
    - path: "web/app/(dashboard)/messages/components/EmptyState.tsx"
      provides: "Empty state component for when no conversations exist"
      exports: ["EmptyState"]
    - path: "web/components/dashboard/DashboardNav.tsx"
      provides: "Updated navigation with Messages item"
      contains: "Messages"
    - path: "web/app/(dashboard)/layout.tsx"
      provides: "Updated header with message icon and unread badge"
      contains: "MessageSquare"
  key_links:
    - from: "web/app/(dashboard)/messages/page.tsx"
      to: "web/lib/queries/comms.ts"
      via: "Server component calls fetchConversationsWithUnread"
      pattern: "fetchConversationsWithUnread"
    - from: "web/app/(dashboard)/messages/components/ConversationList.tsx"
      to: "web/lib/queries/comms.ts"
      via: "Client component uses useConversations hook for polling"
      pattern: "useConversations"
    - from: "web/lib/queries/comms.ts"
      to: "supabase/migrations/143_comms_docs_schema.sql"
      via: "Queries conversations + messages + conversation_read_status tables"
      pattern: "from\\('conversations'\\)"
    - from: "web/components/dashboard/DashboardNav.tsx"
      to: "web/app/(dashboard)/messages/page.tsx"
      via: "Navigation links to /messages route"
      pattern: "href.*messages"
---

<objective>
Create the conversation list page, query functions, navigation entry, and header unread badge for the messaging section.

Purpose: This is the entry point for all messaging — users need to see their conversations, know which have unread messages, and navigate to the messaging section from both the sidebar and header. Without this foundation, the thread view (41-02) and new conversation flow (41-03) have nowhere to live.

Output: 1 query file (server + client functions), 1 page component, 3 UI components (ConversationList, ConversationRow, EmptyState), 2 modified files (DashboardNav, layout).
</objective>

<execution_context>
@/Users/sabineresoagli/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sabineresoagli/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/41-web-messaging-core/41-CONTEXT.md
@.planning/phases/41-web-messaging-core/41-RESEARCH.md

# Existing patterns to follow:
@web/lib/queries/workers.ts
@web/lib/queries/admin/medics.ts
@web/app/(dashboard)/workers/page.tsx
@web/components/dashboard/DashboardNav.tsx
@web/app/(dashboard)/layout.tsx

# Types and schema:
@web/types/comms.types.ts
@supabase/migrations/143_comms_docs_schema.sql

# Client patterns:
@web/lib/supabase/server.ts
@web/lib/supabase/client.ts
@web/contexts/org-context.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create conversation query functions and navigation updates</name>
  <files>web/lib/queries/comms.ts, web/components/dashboard/DashboardNav.tsx, web/app/(dashboard)/layout.tsx</files>
  <action>
**File 1: `web/lib/queries/comms.ts`**

Create query file following the pattern from `web/lib/queries/workers.ts` (server-side fetch + client-side useQuery hook):

```typescript
// Server-side function: fetchConversationsWithUnread
// Accepts supabase SupabaseClient instance
// Steps:
// 1. Get current user via supabase.auth.getUser()
// 2. Fetch all direct conversations for the user's org:
//    supabase.from('conversations').select('*').eq('type', 'direct').order('last_message_at', { ascending: false, nullsFirst: false })
// 3. For each conversation, fetch the user's read status from conversation_read_status
//    supabase.from('conversation_read_status').select('conversation_id, last_read_at').eq('user_id', userId)
// 4. For each conversation, compute unread_count by counting messages where:
//    - conversation_id matches
//    - created_at > last_read_at (or all messages if no read status)
//    - sender_id != current user
//    - deleted_at IS NULL
//    Use a single bulk query: supabase.from('messages').select('conversation_id, created_at, sender_id').in('conversation_id', conversationIds).is('deleted_at', null)
//    Then compute in JS (avoids N+1 queries)
// 5. For each conversation, resolve the other party's name:
//    - If current user role is 'medic': the other party is the org admin. Query the organizations table for org name, or look up the created_by user.
//    - If current user role is 'org_admin': the other party is the medic. Use conversations.medic_id to look up medics table (first_name, last_name).
//    Use a single bulk query on medics table: supabase.from('medics').select('id, first_name, last_name, user_id').in('id', medicIds)
// 6. Return array of ConversationWithUnread & { participant_name: string, participant_role: 'medic' | 'admin' }

// Define the return type:
export interface ConversationListItem {
  id: string;
  org_id: string;
  type: 'direct';
  medic_id: string | null;
  created_by: string;
  last_message_at: string | null;
  last_message_preview: string | null;
  created_at: string;
  updated_at: string;
  unread_count: number;
  participant_name: string;
  participant_role: 'medic' | 'admin';
}
```

Performance approach: Use 3 parallel queries (conversations, read statuses, messages for unread counts) instead of N+1. Compute unread counts in JavaScript by grouping messages per conversation and filtering by sender_id and read status.

Also add a `fetchTotalUnreadCount` function that returns the total number of unread messages across all conversations (for the header badge). This can call `fetchConversationsWithUnread` and sum the unread_count values, or use a more efficient approach with a single messages query.

Add a `useConversations` client-side hook following the workers.ts pattern:
```typescript
export function useConversations(initialData: ConversationListItem[]) {
  const supabase = createClient();
  return useQuery({
    queryKey: ['conversations'],
    queryFn: () => fetchConversationsWithUnread(supabase),
    initialData,
    refetchInterval: 30_000, // 30 seconds (more frequent than workers since messaging is time-sensitive)
  });
}
```

**File 2: `web/components/dashboard/DashboardNav.tsx`**

Add a "Messages" navigation item to the `navigation` array. Position it after "Analytics" (last item before a natural break — messaging is a cross-cutting concern).

```typescript
// Add import:
import { MessageSquare } from 'lucide-react';

// Add to navigation array:
{
  name: 'Messages',
  href: '/messages',
  icon: MessageSquare,
}
```

**File 3: `web/app/(dashboard)/layout.tsx`**

Add a message icon with unread count badge to the header bar (the `<header>` element that currently has `<SidebarTrigger />` and an empty `<div className="flex-1" />`).

After the `<div className="flex-1" />` spacer, add:
```tsx
// Add imports: MessageSquare from lucide-react, Link from next/link, Badge from @/components/ui/badge
// Add import: { fetchTotalUnreadCount } from '@/lib/queries/comms'

// In the header, after <div className="flex-1" />:
<Link href="/messages" className="relative p-2 text-muted-foreground hover:text-foreground transition-colors">
  <MessageSquare className="h-5 w-5" />
  {totalUnread > 0 && (
    <span className="absolute -top-0.5 -right-0.5 flex h-4 min-w-4 items-center justify-center rounded-full bg-destructive px-1 text-[10px] font-medium text-destructive-foreground">
      {totalUnread > 99 ? '99+' : totalUnread}
    </span>
  )}
</Link>
```

Fetch `totalUnread` in the server component body (after the auth check): `const totalUnread = await fetchTotalUnreadCount(supabase);`

This keeps the layout as a server component (no 'use client' needed) since the unread count is fetched at page load. Real-time updates are Phase 43.
  </action>
  <verify>
Run `grep "Messages" web/components/dashboard/DashboardNav.tsx` — should match the nav item.
Run `grep "MessageSquare" web/app/(dashboard)/layout.tsx` — should match the header icon.
Run `grep "fetchConversationsWithUnread" web/lib/queries/comms.ts` — should match the export.
Run `grep "useConversations" web/lib/queries/comms.ts` — should match the hook.
Run `grep "fetchTotalUnreadCount" web/lib/queries/comms.ts` — should match.
Run `grep "refetchInterval" web/lib/queries/comms.ts` — should show 30000.
  </verify>
  <done>Query functions exist for fetching conversations with computed unread counts and participant names. DashboardNav has "Messages" sidebar item linking to /messages. Layout header has MessageSquare icon with total unread badge navigating to /messages. All follow existing patterns — server-side fetch, client-side useQuery hook with 30-second polling.</done>
</task>

<task type="auto">
  <name>Task 2: Create the messaging page with two-panel layout and conversation list</name>
  <files>web/app/(dashboard)/messages/page.tsx, web/app/(dashboard)/messages/components/ConversationList.tsx, web/app/(dashboard)/messages/components/ConversationRow.tsx, web/app/(dashboard)/messages/components/EmptyState.tsx</files>
  <action>
**File 1: `web/app/(dashboard)/messages/page.tsx`**

Server component following the workers page pattern:

```typescript
import { createClient } from '@/lib/supabase/server';
import { fetchConversationsWithUnread } from '@/lib/queries/comms';
import { ConversationList } from './components/ConversationList';
import { EmptyState } from './components/EmptyState';

export default async function MessagesPage() {
  const supabase = await createClient();
  const conversations = await fetchConversationsWithUnread(supabase);

  return (
    <div className="flex h-[calc(100vh-theme(spacing.14)-theme(spacing.8))] lg:h-[calc(100vh-theme(spacing.16)-theme(spacing.12))]">
      {/* Left panel: conversation list (~300px, or full-width on mobile) */}
      <div className="w-full md:w-80 md:min-w-80 border-r flex flex-col">
        <div className="p-4 border-b flex items-center justify-between">
          <h1 className="text-lg font-semibold">Messages</h1>
          {/* New conversation button — placeholder, wired in 41-03 */}
        </div>
        {conversations.length === 0 ? (
          <EmptyState />
        ) : (
          <ConversationList initialConversations={conversations} />
        )}
      </div>

      {/* Right panel: message thread (empty state when no conversation selected) */}
      <div className="hidden md:flex flex-1 items-center justify-center text-muted-foreground">
        <div className="text-center">
          <p className="text-lg font-medium">Select a conversation</p>
          <p className="text-sm">Choose a conversation from the list to start messaging</p>
        </div>
      </div>
    </div>
  );
}
```

The height calculation subtracts the header height (h-14 on mobile, h-16 on desktop) plus padding. This makes the messaging panel fill the available viewport.

**File 2: `web/app/(dashboard)/messages/components/ConversationList.tsx`**

Client component ('use client') that renders the scrollable conversation list:

```typescript
'use client';

import { useState } from 'react';
import { useConversations, type ConversationListItem } from '@/lib/queries/comms';
import { ConversationRow } from './ConversationRow';
import { Input } from '@/components/ui/input';
import { Search } from 'lucide-react';

interface ConversationListProps {
  initialConversations: ConversationListItem[];
}

export function ConversationList({ initialConversations }: ConversationListProps) {
  const { data: conversations } = useConversations(initialConversations);
  const [search, setSearch] = useState('');
  const [selectedId, setSelectedId] = useState<string | null>(null);

  // Filter conversations by participant name (local filter)
  const filtered = conversations?.filter(c =>
    c.participant_name.toLowerCase().includes(search.toLowerCase())
  ) ?? [];

  return (
    <div className="flex flex-col flex-1 overflow-hidden">
      {/* Search bar */}
      <div className="p-3 border-b">
        <div className="relative">
          <Search className="absolute left-2.5 top-2.5 h-4 w-4 text-muted-foreground" />
          <Input
            placeholder="Search conversations..."
            value={search}
            onChange={(e) => setSearch(e.target.value)}
            className="pl-9 h-9"
          />
        </div>
      </div>

      {/* Scrollable conversation list */}
      <div className="flex-1 overflow-y-auto">
        {filtered.map((conversation) => (
          <ConversationRow
            key={conversation.id}
            conversation={conversation}
            isSelected={selectedId === conversation.id}
            onClick={() => setSelectedId(conversation.id)}
          />
        ))}
        {filtered.length === 0 && search && (
          <div className="p-4 text-center text-sm text-muted-foreground">
            No conversations matching "{search}"
          </div>
        )}
      </div>
    </div>
  );
}
```

**File 3: `web/app/(dashboard)/messages/components/ConversationRow.tsx`**

Client component for a single conversation row:

```typescript
'use client';

import Link from 'next/link';
import type { ConversationListItem } from '@/lib/queries/comms';
import { Badge } from '@/components/ui/badge';
import { cn } from '@/lib/utils';

interface ConversationRowProps {
  conversation: ConversationListItem;
  isSelected: boolean;
  onClick: () => void;
}

export function ConversationRow({ conversation, isSelected, onClick }: ConversationRowProps) {
  // Format relative time
  const timeDisplay = formatRelativeTime(conversation.last_message_at);

  // First letter of name for avatar
  const initial = conversation.participant_name.charAt(0).toUpperCase();

  return (
    <Link
      href={`/messages/${conversation.id}`}
      onClick={onClick}
      className={cn(
        'flex items-start gap-3 px-4 py-3 hover:bg-muted/50 transition-colors border-b',
        isSelected && 'bg-muted'
      )}
    >
      {/* Avatar circle with initial */}
      <div className="flex-shrink-0 w-10 h-10 rounded-full bg-primary/10 flex items-center justify-center">
        <span className="text-sm font-medium text-primary">{initial}</span>
      </div>

      {/* Content */}
      <div className="flex-1 min-w-0">
        <div className="flex items-center justify-between gap-2">
          <span className={cn(
            'text-sm truncate',
            conversation.unread_count > 0 ? 'font-semibold' : 'font-medium'
          )}>
            {conversation.participant_name}
          </span>
          <span className="text-xs text-muted-foreground flex-shrink-0">
            {timeDisplay}
          </span>
        </div>
        <div className="flex items-center justify-between gap-2 mt-0.5">
          <p className={cn(
            'text-xs truncate',
            conversation.unread_count > 0 ? 'text-foreground' : 'text-muted-foreground'
          )}>
            {conversation.last_message_preview || 'No messages yet'}
          </p>
          {conversation.unread_count > 0 && (
            <Badge variant="destructive" className="h-5 min-w-5 flex items-center justify-center rounded-full px-1.5 text-[10px]">
              {conversation.unread_count > 99 ? '99+' : conversation.unread_count}
            </Badge>
          )}
        </div>
        {/* Role indicator */}
        <span className="text-[10px] text-muted-foreground uppercase tracking-wider mt-0.5">
          {conversation.participant_role === 'medic' ? 'Medic' : 'Admin'}
        </span>
      </div>
    </Link>
  );
}

// Helper: format relative time (Today shows time, older shows date)
function formatRelativeTime(dateStr: string | null): string {
  if (!dateStr) return '';

  const date = new Date(dateStr);
  const now = new Date();
  const diffMs = now.getTime() - date.getTime();
  const diffMins = Math.floor(diffMs / 60000);
  const diffHours = Math.floor(diffMs / 3600000);
  const diffDays = Math.floor(diffMs / 86400000);

  // Today: show time (e.g., "10:30 AM")
  if (date.toDateString() === now.toDateString()) {
    return date.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' });
  }

  // Yesterday
  const yesterday = new Date(now);
  yesterday.setDate(yesterday.getDate() - 1);
  if (date.toDateString() === yesterday.toDateString()) {
    return 'Yesterday';
  }

  // This week: show day name
  if (diffDays < 7) {
    return date.toLocaleDateString('en-GB', { weekday: 'short' });
  }

  // Older: show date
  return date.toLocaleDateString('en-GB', { day: 'numeric', month: 'short' });
}
```

**File 4: `web/app/(dashboard)/messages/components/EmptyState.tsx`**

Simple empty state component:

```typescript
import { MessageSquare } from 'lucide-react';
import { Button } from '@/components/ui/button';

export function EmptyState() {
  return (
    <div className="flex-1 flex flex-col items-center justify-center p-8 text-center">
      <div className="w-16 h-16 rounded-full bg-muted flex items-center justify-center mb-4">
        <MessageSquare className="h-8 w-8 text-muted-foreground" />
      </div>
      <h3 className="text-lg font-medium mb-1">No conversations yet</h3>
      <p className="text-sm text-muted-foreground mb-4 max-w-[240px]">
        Start a conversation with a medic or admin to get things moving.
      </p>
      {/* Button wired to new-conversation flow in 41-03. For now, just a visual placeholder. */}
      <Button variant="default" disabled>
        Start a conversation
      </Button>
    </div>
  );
}
```
  </action>
  <verify>
Run `ls web/app/(dashboard)/messages/page.tsx web/app/(dashboard)/messages/components/ConversationList.tsx web/app/(dashboard)/messages/components/ConversationRow.tsx web/app/(dashboard)/messages/components/EmptyState.tsx` — all 4 files exist.
Run `grep "fetchConversationsWithUnread" web/app/(dashboard)/messages/page.tsx` — should match the server-side fetch.
Run `grep "useConversations" web/app/(dashboard)/messages/components/ConversationList.tsx` — should match the client hook.
Run `grep "unread_count" web/app/(dashboard)/messages/components/ConversationRow.tsx` — should match the badge logic.
Run `grep "No conversations yet" web/app/(dashboard)/messages/components/EmptyState.tsx` — should match.
Run `grep "'use client'" web/app/(dashboard)/messages/components/ConversationList.tsx` — should match (client component).
Run `grep -L "'use client'" web/app/(dashboard)/messages/page.tsx` — page.tsx should NOT have 'use client' (it's a server component).
  </verify>
  <done>Two-panel messaging layout with conversation list sidebar on the left and empty thread placeholder on the right. Conversation rows show participant avatar/initial, name (bold if unread), truncated preview, relative timestamp, unread count badge, and role indicator. Search filter on participant name. Empty state with icon and CTA. Server component fetches initial data, client component polls every 30 seconds via useQuery.</done>
</task>

</tasks>

<verification>
1. DashboardNav.tsx has "Messages" item with MessageSquare icon linking to /messages
2. Layout header has MessageSquare icon with unread count badge navigating to /messages
3. /messages route renders a two-panel layout (conversation list left, content area right)
4. Conversations are sorted by last_message_at descending (most recent first)
5. Each conversation row shows: participant name, last message preview, relative timestamp, unread badge
6. Unread count is computed correctly (messages after last_read_at, excluding own messages)
7. Empty state shows when no conversations exist
8. Search filter works on participant name
9. Server component pattern: page.tsx fetches data, passes to client components
10. Client component polls with 30-second refetch interval
</verification>

<success_criteria>
- Sidebar navigation includes "Messages" with MessageSquare icon
- Header shows message icon with unread count badge (0 = no badge visible)
- /messages page loads with two-panel layout
- Conversation list fetches from conversations table with unread counts computed from messages + conversation_read_status
- ConversationRow displays name, preview (truncated via CSS), relative time, unread badge
- Empty state renders when conversations array is empty
- No new npm packages required — uses existing shadcn/ui, lucide-react, @tanstack/react-query
</success_criteria>

<output>
After completion, create `.planning/phases/41-web-messaging-core/41-01-SUMMARY.md`
</output>
