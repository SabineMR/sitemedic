---
phase: 41-web-messaging-core
plan: 03
type: execute
wave: 2
depends_on: [41-01]
files_modified:
  - web/app/api/messages/conversations/route.ts
  - web/app/(dashboard)/messages/components/MedicPicker.tsx
  - web/app/(dashboard)/messages/components/EmptyState.tsx
  - web/app/(dashboard)/messages/page.tsx
  - web/app/(dashboard)/messages/[conversationId]/page.tsx
autonomous: true

must_haves:
  truths:
    - "An org admin can click a '+' button in the conversation list header, see a dialog listing all medics in their org, and start a new conversation with any medic"
    - "If a conversation already exists with that medic, clicking the medic opens the existing thread (no duplicate created)"
    - "A medic can click a 'Message Admin' button to create (or open) a single conversation with their org admin"
    - "After creating a new conversation, the user is redirected to the message thread for that conversation"
    - "The medic picker dialog shows which medics already have existing conversations (with a visual indicator)"
    - "The create conversation API uses INSERT ON CONFLICT to prevent duplicate direct conversations (enforced by the partial unique index)"
  artifacts:
    - path: "web/app/api/messages/conversations/route.ts"
      provides: "POST endpoint to create or find an existing direct conversation"
      exports: ["POST"]
    - path: "web/app/(dashboard)/messages/components/MedicPicker.tsx"
      provides: "Dialog component for admin to pick a medic and start a conversation"
      exports: ["MedicPicker"]
    - path: "web/app/(dashboard)/messages/components/EmptyState.tsx"
      provides: "Updated empty state with working 'Start a conversation' button"
    - path: "web/app/(dashboard)/messages/page.tsx"
      provides: "Updated page with '+' new conversation button in header"
    - path: "web/app/(dashboard)/messages/[conversationId]/page.tsx"
      provides: "Updated conversation page with '+' button in sidebar header"
  key_links:
    - from: "web/app/(dashboard)/messages/components/MedicPicker.tsx"
      to: "web/app/api/messages/conversations/route.ts"
      via: "Client POSTs to /api/messages/conversations to create or find conversation"
      pattern: "fetch.*api/messages/conversations"
    - from: "web/app/api/messages/conversations/route.ts"
      to: "supabase/migrations/143_comms_docs_schema.sql"
      via: "INSERT ON CONFLICT on conversations table using idx_conversations_org_medic_direct unique index"
      pattern: "ON CONFLICT\\|onConflict"
    - from: "web/app/(dashboard)/messages/components/MedicPicker.tsx"
      to: "web/lib/queries/admin/medics.ts"
      via: "Fetches org medic roster for the picker dialog"
      pattern: "from\\('medics'\\)"
---

<objective>
Create the new conversation flow: admin picks medic from org roster, medic messages admin, with duplicate prevention via INSERT ON CONFLICT.

Purpose: Without the ability to start new conversations, the messaging system only works for pre-existing conversations (which don't exist yet). This plan completes the conversation lifecycle — users can create, find, and open conversations with the right person.

Output: 1 API route (create/find conversation), 1 new component (MedicPicker dialog), 2 updated files (messages page and conversation page for the '+' button, EmptyState with working CTA).
</objective>

<execution_context>
@/Users/sabineresoagli/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sabineresoagli/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/41-web-messaging-core/41-CONTEXT.md
@.planning/phases/41-web-messaging-core/41-RESEARCH.md
@.planning/phases/41-web-messaging-core/41-01-SUMMARY.md

# Existing patterns:
@web/app/api/bookings/create/route.ts
@web/lib/queries/admin/medics.ts
@web/lib/organizations/org-resolver.ts
@web/contexts/org-context.tsx

# Types and schema (partial unique index on conversations):
@web/types/comms.types.ts
@supabase/migrations/143_comms_docs_schema.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create conversation API route with duplicate prevention</name>
  <files>web/app/api/messages/conversations/route.ts</files>
  <action>
**File: `web/app/api/messages/conversations/route.ts`**

POST route to create a new direct conversation or return the existing one. This handles the race condition described in RESEARCH.md (Pitfall 1).

```typescript
// POST /api/messages/conversations
// export const dynamic = 'force-dynamic';

// 1. Create supabase server client
// 2. Get authenticated user via supabase.auth.getUser() — return 401 if not authenticated
// 3. Get org_id via requireOrgId()
// 4. Get user role from user.app_metadata.role
// 5. Parse body: { medicId: string }
//    - For org_admin: medicId is required (which medic to message)
//    - For medic: medicId can be omitted — the API resolves it from the medic's own record
// 6. Resolve the medic_id:
//    - If role is 'medic': look up the medic record for this user
//      supabase.from('medics').select('id').eq('user_id', user.id).eq('org_id', orgId).single()
//      Use that medic.id as medicId
//    - If role is 'org_admin': use the medicId from the request body
//      Validate the medic belongs to this org:
//      supabase.from('medics').select('id').eq('id', medicId).eq('org_id', orgId).single()
//      Return 404 if medic not found in org
// 7. Try to create the conversation with INSERT ON CONFLICT:
//    - The partial unique index idx_conversations_org_medic_direct enforces (org_id, medic_id) WHERE type = 'direct'
//    - Approach: First try INSERT. If it fails with unique constraint violation (code 23505), SELECT the existing one.
//    - Alternatively, try a SELECT first, and only INSERT if none exists.
//    - Preferred approach for simplicity:
//      a. SELECT existing: supabase.from('conversations').select('id').eq('org_id', orgId).eq('medic_id', resolvedMedicId).eq('type', 'direct').maybeSingle()
//      b. If found: return { conversationId: existing.id, created: false }
//      c. If not found: INSERT new conversation:
//         supabase.from('conversations').insert({
//           org_id: orgId,
//           type: 'direct',
//           medic_id: resolvedMedicId,
//           created_by: user.id,
//         }).select('id').single()
//      d. If INSERT fails with unique violation (race condition): SELECT again
//         This handles the case where another request created the conversation between our SELECT and INSERT
//      e. Return { conversationId: newConversation.id, created: true }
// 8. Return 200 (existing) or 201 (created) with { conversationId, created }
```

Key implementation details:
- Use `maybeSingle()` for the initial SELECT (returns null if not found, doesn't throw)
- Catch unique constraint error (error.code === '23505') on INSERT and fall back to SELECT
- Always return the conversation ID so the client can redirect to `/messages/{conversationId}`
- The partial unique index in the DB prevents duplicate direct conversations per org+medic pair
  </action>
  <verify>
Run `ls web/app/api/messages/conversations/route.ts` — file exists.
Run `grep "force-dynamic" web/app/api/messages/conversations/route.ts` — should match.
Run `grep "requireOrgId" web/app/api/messages/conversations/route.ts` — should match org scoping.
Run `grep "23505\|unique\|maybeSingle\|ON CONFLICT\|conflict" web/app/api/messages/conversations/route.ts` — should match duplicate prevention logic.
Run `grep "medic_id\|medicId" web/app/api/messages/conversations/route.ts` — should match medic resolution.
Run `grep "role.*medic\|app_metadata.*role" web/app/api/messages/conversations/route.ts` — should match role-based logic.
  </verify>
  <done>Create conversation API route handles both admin (picks medic) and medic (auto-resolves self) flows. Uses SELECT-then-INSERT pattern with unique constraint catch for race condition prevention. Returns existing conversation ID if one already exists, or creates new one. Validates medic belongs to caller's org.</done>
</task>

<task type="auto">
  <name>Task 2: Create MedicPicker dialog and wire new conversation buttons</name>
  <files>web/app/(dashboard)/messages/components/MedicPicker.tsx, web/app/(dashboard)/messages/components/EmptyState.tsx, web/app/(dashboard)/messages/page.tsx, web/app/(dashboard)/messages/[conversationId]/page.tsx</files>
  <action>
**File 1: `web/app/(dashboard)/messages/components/MedicPicker.tsx`**

Client component dialog for admin to pick a medic. Also handles the medic's "Message Admin" flow:

```typescript
'use client';

import { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { useOrg } from '@/contexts/org-context';
import { createClient } from '@/lib/supabase/client';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Plus, Search, MessageSquare, Loader2 } from 'lucide-react';

interface Medic {
  id: string;
  user_id: string;
  first_name: string;
  last_name: string;
  has_conversation: boolean; // whether an existing conversation exists
  conversation_id: string | null;
}

interface MedicPickerProps {
  existingConversationMedicIds: string[]; // medic_ids that already have conversations
  existingConversations: Array<{ medic_id: string | null; id: string }>; // for mapping medic -> conversation
}

export function MedicPicker({ existingConversationMedicIds, existingConversations }: MedicPickerProps) {
  const router = useRouter();
  const { role } = useOrg();
  const [open, setOpen] = useState(false);
  const [medics, setMedics] = useState<Medic[]>([]);
  const [loading, setLoading] = useState(false);
  const [search, setSearch] = useState('');
  const [creating, setCreating] = useState<string | null>(null); // medic ID being created

  // Fetch medics when dialog opens (admin flow)
  useEffect(() => {
    if (!open || role !== 'org_admin') return;

    async function loadMedics() {
      setLoading(true);
      const supabase = createClient();
      const { data, error } = await supabase
        .from('medics')
        .select('id, user_id, first_name, last_name')
        .order('last_name', { ascending: true });

      if (error) {
        console.error('Error loading medics:', error);
        setLoading(false);
        return;
      }

      // Mark medics that already have conversations
      const medicList: Medic[] = (data || []).map(m => {
        const existingConv = existingConversations.find(c => c.medic_id === m.id);
        return {
          ...m,
          has_conversation: existingConversationMedicIds.includes(m.id),
          conversation_id: existingConv?.id ?? null,
        };
      });

      setMedics(medicList);
      setLoading(false);
    }

    loadMedics();
  }, [open, role, existingConversationMedicIds, existingConversations]);

  // Handle medic selection (admin flow)
  const handleSelectMedic = async (medic: Medic) => {
    // If conversation already exists, navigate to it
    if (medic.has_conversation && medic.conversation_id) {
      setOpen(false);
      router.push(`/messages/${medic.conversation_id}`);
      return;
    }

    // Create new conversation
    setCreating(medic.id);
    try {
      const res = await fetch('/api/messages/conversations', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ medicId: medic.id }),
      });

      if (!res.ok) {
        console.error('Failed to create conversation');
        return;
      }

      const { conversationId } = await res.json();
      setOpen(false);
      router.push(`/messages/${conversationId}`);
    } catch (err) {
      console.error('Error creating conversation:', err);
    } finally {
      setCreating(null);
    }
  };

  // Handle medic's "Message Admin" flow (single click, no picker needed)
  const handleMessageAdmin = async () => {
    setCreating('admin');
    try {
      const res = await fetch('/api/messages/conversations', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({}), // No medicId needed — API resolves from auth
      });

      if (!res.ok) {
        console.error('Failed to create conversation');
        return;
      }

      const { conversationId } = await res.json();
      router.push(`/messages/${conversationId}`);
    } catch (err) {
      console.error('Error creating conversation:', err);
    } finally {
      setCreating(null);
    }
  };

  // Medic flow: just a button, no dialog
  if (role === 'medic') {
    return (
      <Button
        onClick={handleMessageAdmin}
        disabled={creating === 'admin'}
        size="sm"
      >
        {creating === 'admin' ? (
          <Loader2 className="h-4 w-4 animate-spin mr-1" />
        ) : (
          <MessageSquare className="h-4 w-4 mr-1" />
        )}
        Message Admin
      </Button>
    );
  }

  // Admin flow: dialog with medic picker
  const filtered = medics.filter(m =>
    `${m.first_name} ${m.last_name}`.toLowerCase().includes(search.toLowerCase())
  );

  return (
    <Dialog open={open} onOpenChange={setOpen}>
      <DialogTrigger asChild>
        <Button size="icon" variant="ghost" className="h-8 w-8" title="New conversation">
          <Plus className="h-4 w-4" />
        </Button>
      </DialogTrigger>
      <DialogContent className="sm:max-w-md">
        <DialogHeader>
          <DialogTitle>New Conversation</DialogTitle>
        </DialogHeader>

        {/* Search */}
        <div className="relative">
          <Search className="absolute left-2.5 top-2.5 h-4 w-4 text-muted-foreground" />
          <Input
            placeholder="Search medics..."
            value={search}
            onChange={(e) => setSearch(e.target.value)}
            className="pl-9"
          />
        </div>

        {/* Medic list */}
        <div className="max-h-72 overflow-y-auto -mx-2">
          {loading && (
            <div className="flex items-center justify-center py-8">
              <Loader2 className="h-5 w-5 animate-spin text-muted-foreground" />
            </div>
          )}
          {!loading && filtered.length === 0 && (
            <div className="text-center text-sm text-muted-foreground py-8">
              {search ? 'No medics found' : 'No medics in your organisation'}
            </div>
          )}
          {!loading && filtered.map(medic => (
            <button
              key={medic.id}
              onClick={() => handleSelectMedic(medic)}
              disabled={creating === medic.id}
              className="w-full flex items-center gap-3 px-4 py-2.5 hover:bg-muted/50 rounded-md transition-colors text-left"
            >
              {/* Avatar */}
              <div className="flex-shrink-0 w-8 h-8 rounded-full bg-primary/10 flex items-center justify-center">
                <span className="text-xs font-medium text-primary">
                  {medic.first_name.charAt(0)}{medic.last_name.charAt(0)}
                </span>
              </div>
              {/* Name */}
              <div className="flex-1 min-w-0">
                <span className="text-sm font-medium">
                  {medic.first_name} {medic.last_name}
                </span>
              </div>
              {/* Existing conversation indicator */}
              {medic.has_conversation && (
                <span className="text-xs text-muted-foreground flex items-center gap-1">
                  <MessageSquare className="h-3 w-3" />
                  Existing
                </span>
              )}
              {creating === medic.id && (
                <Loader2 className="h-4 w-4 animate-spin text-muted-foreground" />
              )}
            </button>
          ))}
        </div>
      </DialogContent>
    </Dialog>
  );
}
```

**File 2: `web/app/(dashboard)/messages/components/EmptyState.tsx` (update)**

Update the EmptyState to accept a `role` prop and render either the MedicPicker (for admin) or "Message Admin" button (for medic). The "Start a conversation" button should no longer be disabled.

Replace the disabled Button placeholder with:
- For org_admin: render the MedicPicker component with empty existing conversations
- For medic: render a "Message Admin" button that calls the create conversation API

Accept props: `role: 'org_admin' | 'medic' | null`, `existingConversationMedicIds: string[]`, `existingConversations: Array<{ medic_id: string | null; id: string }>`.

The empty state should be a client component ('use client') since MedicPicker is a client component.

**File 3: `web/app/(dashboard)/messages/page.tsx` (update)**

Update the messages page to:
1. Pass the user's role to the conversation list header area
2. Render the MedicPicker "+" button (for admin) or "Message Admin" button (for medic) in the header next to "Messages" title
3. Get user role from the server component: `const role = user.app_metadata?.role as string;`
4. Pass `existingConversationMedicIds` (extracted from conversations: `conversations.filter(c => c.medic_id).map(c => c.medic_id!)`) and `existingConversations` (conversations mapped to `{ medic_id, id }`) to MedicPicker
5. Update EmptyState to pass these props too

Since MedicPicker is a client component, it can be rendered inside the server component page (Next.js supports this).

**File 4: `web/app/(dashboard)/messages/[conversationId]/page.tsx` (update)**

Add the same "+" / "Message Admin" button to the conversation list sidebar header in the [conversationId] page, so users can start new conversations from within an active thread view. Same pattern as the updates to messages/page.tsx above.
  </action>
  <verify>
Run `ls web/app/api/messages/conversations/route.ts` — file exists.
Run `ls web/app/(dashboard)/messages/components/MedicPicker.tsx` — file exists.
Run `grep "MedicPicker" web/app/(dashboard)/messages/page.tsx` — should match the import/usage.
Run `grep "Message Admin" web/app/(dashboard)/messages/components/MedicPicker.tsx` — should match the medic flow.
Run `grep "has_conversation\|Existing" web/app/(dashboard)/messages/components/MedicPicker.tsx` — should match the indicator for existing conversations.
Run `grep "Plus" web/app/(dashboard)/messages/page.tsx` — should match the '+' button (via MedicPicker).
Run `grep -L "disabled" web/app/(dashboard)/messages/components/EmptyState.tsx` — EmptyState should no longer have a disabled button.
  </verify>
  <done>Admin can click '+' to open a medic picker dialog showing all org medics, with existing conversations marked. Clicking a medic with an existing conversation opens it; clicking one without creates a new conversation and redirects. Medic sees a "Message Admin" button that creates/opens a conversation with their org admin. Duplicate prevention via SELECT-then-INSERT with unique constraint catch. EmptyState has a working CTA that opens the appropriate flow based on user role.</done>
</task>

</tasks>

<verification>
1. Admin sees '+' button in conversation list header that opens medic picker dialog
2. Medic picker shows all org medics with search filter
3. Medics with existing conversations show "Existing" indicator with MessageSquare icon
4. Clicking a medic with existing conversation navigates to that thread
5. Clicking a medic without existing conversation creates one and navigates to it
6. Medic sees "Message Admin" button instead of '+' picker
7. Medic clicking "Message Admin" creates (or finds) their admin conversation
8. Create conversation API returns 200 for existing, 201 for new
9. Race condition handled: concurrent creates don't produce duplicates
10. EmptyState "Start a conversation" button works (opens MedicPicker or triggers Message Admin)
11. '+' button also appears in the sidebar header when viewing a conversation thread
</verification>

<success_criteria>
- POST /api/messages/conversations creates new conversation or returns existing one
- Admin flow: medic picker dialog with org roster, search, existing conversation indicators
- Medic flow: single "Message Admin" button, no dialog needed
- No duplicate conversations possible (enforced by DB unique index + API logic)
- After creation, user is redirected to /messages/{conversationId}
- EmptyState CTA is functional, not disabled
- Works for both org_admin and medic roles
</success_criteria>

<output>
After completion, create `.planning/phases/41-web-messaging-core/41-03-SUMMARY.md`
</output>
