---
phase: 41-web-messaging-core
plan: 02
type: execute
wave: 2
depends_on: [41-01]
files_modified:
  - web/app/(dashboard)/messages/[conversationId]/page.tsx
  - web/app/(dashboard)/messages/components/MessageThread.tsx
  - web/app/(dashboard)/messages/components/MessageItem.tsx
  - web/app/(dashboard)/messages/components/MessageInput.tsx
  - web/app/api/messages/send/route.ts
  - web/app/api/messages/conversations/[id]/read/route.ts
  - web/lib/queries/comms.ts
autonomous: true

must_haves:
  truths:
    - "Navigating to /messages/{conversationId} shows the message thread with all messages for that conversation"
    - "Messages are displayed in a flat list (not chat bubbles), left-aligned, with sender avatar/initials, sender name, message content, and relative timestamp"
    - "The thread scrolls to the bottom (latest messages) on initial load"
    - "Users can type a message in a textarea and send it with Enter (Shift+Enter for newline) or by clicking a Send button"
    - "After sending, the new message appears in the thread and the conversation list updates (last_message_preview, last_message_at)"
    - "Opening a conversation marks it as read by upserting conversation_read_status with the current timestamp"
    - "The thread header shows the other party's name and a back button (for mobile navigation)"
  artifacts:
    - path: "web/app/(dashboard)/messages/[conversationId]/page.tsx"
      provides: "Server component that fetches messages and conversation details for a specific conversation"
    - path: "web/app/(dashboard)/messages/components/MessageThread.tsx"
      provides: "Client component rendering the message list with scroll-to-bottom and polling"
      exports: ["MessageThread"]
    - path: "web/app/(dashboard)/messages/components/MessageItem.tsx"
      provides: "Single message display component with avatar, name, content, timestamp"
      exports: ["MessageItem"]
    - path: "web/app/(dashboard)/messages/components/MessageInput.tsx"
      provides: "Textarea with Enter-to-send, Shift+Enter for newline, and Send button"
      exports: ["MessageInput"]
    - path: "web/app/api/messages/send/route.ts"
      provides: "POST endpoint to send a message in a conversation"
      exports: ["POST"]
    - path: "web/app/api/messages/conversations/[id]/read/route.ts"
      provides: "PATCH endpoint to mark a conversation as read"
      exports: ["PATCH"]
    - path: "web/lib/queries/comms.ts"
      provides: "Additional query functions for messages within a conversation"
      exports: ["fetchMessagesForConversation", "fetchConversationById", "useMessages"]
  key_links:
    - from: "web/app/(dashboard)/messages/[conversationId]/page.tsx"
      to: "web/lib/queries/comms.ts"
      via: "Server component calls fetchMessagesForConversation and fetchConversationById"
      pattern: "fetchMessagesForConversation"
    - from: "web/app/(dashboard)/messages/components/MessageInput.tsx"
      to: "web/app/api/messages/send/route.ts"
      via: "Client sends POST /api/messages/send with conversationId and content"
      pattern: "fetch.*api/messages/send"
    - from: "web/app/(dashboard)/messages/components/MessageThread.tsx"
      to: "web/app/api/messages/conversations/[id]/read/route.ts"
      via: "Client sends PATCH on mount to mark conversation as read"
      pattern: "api/messages/conversations.*read"
    - from: "web/app/api/messages/send/route.ts"
      to: "supabase/migrations/143_comms_docs_schema.sql"
      via: "Inserts into messages table and updates conversations.last_message_at/preview"
      pattern: "from\\('messages'\\)"
---

<objective>
Create the message thread view with message display, send functionality, and mark-as-read behavior.

Purpose: This is the core messaging experience — users select a conversation from the list (41-01) and land in a thread where they can read and send messages. Without this, messaging is just a list of names with no ability to communicate.

Output: 1 dynamic page, 3 UI components (MessageThread, MessageItem, MessageInput), 2 API routes (send message, mark-as-read), query function additions to comms.ts.
</objective>

<execution_context>
@/Users/sabineresoagli/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sabineresoagli/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/41-web-messaging-core/41-CONTEXT.md
@.planning/phases/41-web-messaging-core/41-RESEARCH.md
@.planning/phases/41-web-messaging-core/41-01-SUMMARY.md

# Existing patterns:
@web/app/api/admin/settings/route.ts
@web/app/api/bookings/create/route.ts
@web/lib/queries/comms.ts
@web/lib/organizations/org-resolver.ts

# Types and schema:
@web/types/comms.types.ts
@supabase/migrations/143_comms_docs_schema.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create send message and mark-as-read API routes, plus message query functions</name>
  <files>web/app/api/messages/send/route.ts, web/app/api/messages/conversations/[id]/read/route.ts, web/lib/queries/comms.ts</files>
  <action>
**File 1: `web/app/api/messages/send/route.ts`**

POST route to send a text message. Follow the pattern from `web/app/api/admin/settings/route.ts`:

```typescript
// POST /api/messages/send
// export const dynamic = 'force-dynamic';

// 1. Create supabase server client
// 2. Get authenticated user via supabase.auth.getUser() — return 401 if not authenticated
// 3. Get org_id via requireOrgId() from org-resolver
// 4. Parse body: { conversationId: string, content: string }
// 5. Validate:
//    - conversationId is required (non-empty string)
//    - content is required, trimmed, max 5000 chars
//    - Return 400 if invalid
// 6. Verify conversation exists and belongs to user's org:
//    supabase.from('conversations').select('id, org_id').eq('id', conversationId).eq('org_id', orgId).single()
//    Return 404 if not found
// 7. Insert message:
//    supabase.from('messages').insert({
//      conversation_id: conversationId,
//      org_id: orgId,
//      sender_id: user.id,
//      message_type: 'text',
//      content: content.trim(),
//      status: 'sent',
//    }).select().single()
// 8. Update conversation metadata (last_message_at, last_message_preview):
//    supabase.from('conversations').update({
//      last_message_at: message.created_at,
//      last_message_preview: content.trim().substring(0, 100),
//    }).eq('id', conversationId)
// 9. Also upsert the sender's own read status to now() so they don't see their own message as unread:
//    supabase.from('conversation_read_status').upsert({
//      user_id: user.id,
//      conversation_id: conversationId,
//      org_id: orgId,
//      last_read_at: new Date().toISOString(),
//    }, { onConflict: 'user_id,conversation_id' })
// 10. Return 201 with the created message
```

**File 2: `web/app/api/messages/conversations/[id]/read/route.ts`**

PATCH route to mark a conversation as read:

```typescript
// PATCH /api/messages/conversations/{id}/read
// export const dynamic = 'force-dynamic';

// 1. Create supabase server client
// 2. Get authenticated user
// 3. Get org_id via requireOrgId()
// 4. Extract conversation ID from URL params
// 5. Verify conversation exists and belongs to user's org:
//    supabase.from('conversations').select('id').eq('id', conversationId).eq('org_id', orgId).single()
//    Return 404 if not found
// 6. Upsert conversation_read_status:
//    supabase.from('conversation_read_status').upsert({
//      user_id: user.id,
//      conversation_id: conversationId,
//      org_id: orgId,
//      last_read_at: new Date().toISOString(),
//    }, { onConflict: 'user_id,conversation_id' })
// 7. Return 200 with { success: true }
```

**File 3: `web/lib/queries/comms.ts` (additions)**

Add these functions to the existing comms.ts file (created in 41-01):

```typescript
// fetchConversationById(supabase, conversationId)
// - Fetches a single conversation by ID
// - Returns Conversation | null
// - Uses: supabase.from('conversations').select('*').eq('id', conversationId).single()

// fetchMessagesForConversation(supabase, conversationId)
// - Fetches all messages for a conversation, ordered by created_at ASC (oldest first)
// - Joins sender info: for each message, resolve sender name by checking:
//   - Is sender in medics table? Use medics.first_name + ' ' + medics.last_name
//   - Otherwise, use auth user's email or a fallback "Admin"
// - Approach: fetch messages, then bulk-resolve sender names from medics table
//   supabase.from('messages')
//     .select('*')
//     .eq('conversation_id', conversationId)
//     .is('deleted_at', null)
//     .order('created_at', { ascending: true })
//     .limit(200)
// - Return array of MessageWithSender (from comms.types.ts)
// - For the sender_name resolution: query medics table for all unique sender_ids,
//   build a lookup map medicUserId -> fullName. For senders not in medics, label as "Admin".

// useMessages(conversationId, initialData)
// - Client-side useQuery hook for messages
// - queryKey: ['messages', conversationId]
// - refetchInterval: 10_000 (10 seconds — faster polling for active thread)
// - Uses fetchMessagesForConversation with browser client
```
  </action>
  <verify>
Run `ls web/app/api/messages/send/route.ts web/app/api/messages/conversations/*/read/route.ts` — both API route files exist.
Run `grep "force-dynamic" web/app/api/messages/send/route.ts` — should match.
Run `grep "requireOrgId" web/app/api/messages/send/route.ts` — should match org scoping.
Run `grep "last_message_preview" web/app/api/messages/send/route.ts` — should match the conversation update.
Run `grep "onConflict" web/app/api/messages/conversations/*/read/route.ts` — should match the upsert.
Run `grep "fetchMessagesForConversation" web/lib/queries/comms.ts` — should match.
Run `grep "useMessages" web/lib/queries/comms.ts` — should match.
  </verify>
  <done>Send message API route inserts message, updates conversation metadata (last_message_at, last_message_preview), and upserts sender's read status. Mark-as-read API route upserts conversation_read_status with current timestamp. Query functions fetch messages with sender name resolution (medic names from medics table, fallback "Admin" for non-medic senders). Client hook polls every 10 seconds for active thread.</done>
</task>

<task type="auto">
  <name>Task 2: Create message thread page and UI components</name>
  <files>web/app/(dashboard)/messages/[conversationId]/page.tsx, web/app/(dashboard)/messages/components/MessageThread.tsx, web/app/(dashboard)/messages/components/MessageItem.tsx, web/app/(dashboard)/messages/components/MessageInput.tsx</files>
  <action>
**File 1: `web/app/(dashboard)/messages/[conversationId]/page.tsx`**

Server component that fetches conversation and messages:

```typescript
import { createClient } from '@/lib/supabase/server';
import { fetchConversationById, fetchMessagesForConversation, fetchConversationsWithUnread } from '@/lib/queries/comms';
import { redirect } from 'next/navigation';
import { ConversationList } from '../components/ConversationList';
import { MessageThread } from '../components/MessageThread';

// Next.js dynamic route params
interface PageProps {
  params: Promise<{ conversationId: string }>;
}

export default async function ConversationPage({ params }: PageProps) {
  const { conversationId } = await params;
  const supabase = await createClient();

  // Fetch conversation details + messages + sidebar conversations in parallel
  const [conversation, messages, conversations] = await Promise.all([
    fetchConversationById(supabase, conversationId),
    fetchMessagesForConversation(supabase, conversationId),
    fetchConversationsWithUnread(supabase),
  ]);

  if (!conversation) {
    redirect('/messages');
  }

  // Get current user for the thread component
  const { data: { user } } = await supabase.auth.getUser();

  // Find participant name from conversations list (the one matching this conversation)
  const currentConversation = conversations.find(c => c.id === conversationId);
  const participantName = currentConversation?.participant_name ?? 'Unknown';

  return (
    <div className="flex h-[calc(100vh-theme(spacing.14)-theme(spacing.8))] lg:h-[calc(100vh-theme(spacing.16)-theme(spacing.12))]">
      {/* Left panel: conversation list (hidden on mobile when viewing a thread) */}
      <div className="hidden md:flex w-80 min-w-80 border-r flex-col">
        <div className="p-4 border-b flex items-center justify-between">
          <h1 className="text-lg font-semibold">Messages</h1>
        </div>
        <ConversationList
          initialConversations={conversations}
          selectedId={conversationId}
        />
      </div>

      {/* Right panel: message thread */}
      <div className="flex-1 flex flex-col">
        <MessageThread
          conversationId={conversationId}
          participantName={participantName}
          initialMessages={messages}
          currentUserId={user?.id ?? ''}
        />
      </div>
    </div>
  );
}
```

Update `ConversationList` to accept an optional `selectedId` prop (add to the interface in ConversationList.tsx if not already there). The selected conversation should have `isSelected={true}`.

**File 2: `web/app/(dashboard)/messages/components/MessageThread.tsx`**

Client component that displays the message list, handles mark-as-read, and includes the input:

```typescript
'use client';

import { useEffect, useRef } from 'react';
import { useMessages, type ConversationListItem } from '@/lib/queries/comms';
import type { MessageWithSender } from '@/types/comms.types';
import { MessageItem } from './MessageItem';
import { MessageInput } from './MessageInput';
import { ArrowLeft } from 'lucide-react';
import { Button } from '@/components/ui/button';
import Link from 'next/link';
import { useQueryClient } from '@tanstack/react-query';

interface MessageThreadProps {
  conversationId: string;
  participantName: string;
  initialMessages: MessageWithSender[];
  currentUserId: string;
}

export function MessageThread({ conversationId, participantName, initialMessages, currentUserId }: MessageThreadProps) {
  const { data: messages } = useMessages(conversationId, initialMessages);
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const queryClient = useQueryClient();

  // Scroll to bottom on initial load and when new messages arrive
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'auto' });
  }, [messages?.length]);

  // Mark as read on mount
  useEffect(() => {
    fetch(`/api/messages/conversations/${conversationId}/read`, {
      method: 'PATCH',
    }).then(() => {
      // Invalidate conversations list to update unread counts
      queryClient.invalidateQueries({ queryKey: ['conversations'] });
    }).catch(console.error);
  }, [conversationId, queryClient]);

  // Handle successful message send
  const handleMessageSent = () => {
    // Invalidate both messages and conversations queries
    queryClient.invalidateQueries({ queryKey: ['messages', conversationId] });
    queryClient.invalidateQueries({ queryKey: ['conversations'] });
  };

  return (
    <>
      {/* Thread header */}
      <div className="flex items-center gap-3 px-4 py-3 border-b bg-background">
        {/* Back button (visible on mobile) */}
        <Link href="/messages" className="md:hidden">
          <Button variant="ghost" size="icon" className="h-8 w-8">
            <ArrowLeft className="h-4 w-4" />
          </Button>
        </Link>
        <div>
          <h2 className="text-sm font-semibold">{participantName}</h2>
        </div>
      </div>

      {/* Message list */}
      <div className="flex-1 overflow-y-auto p-4 space-y-4">
        {messages && messages.length === 0 && (
          <div className="text-center text-sm text-muted-foreground py-8">
            No messages yet. Send the first message below.
          </div>
        )}
        {messages?.map((message) => (
          <MessageItem
            key={message.id}
            message={message}
            isOwnMessage={message.sender_id === currentUserId}
          />
        ))}
        <div ref={messagesEndRef} />
      </div>

      {/* Message input */}
      <MessageInput
        conversationId={conversationId}
        onMessageSent={handleMessageSent}
      />
    </>
  );
}
```

**File 3: `web/app/(dashboard)/messages/components/MessageItem.tsx`**

Single message display — flat list style like Slack/Teams (NOT chat bubbles per CONTEXT.md):

```typescript
'use client';

import type { MessageWithSender } from '@/types/comms.types';
import { cn } from '@/lib/utils';

interface MessageItemProps {
  message: MessageWithSender;
  isOwnMessage: boolean;
}

export function MessageItem({ message, isOwnMessage }: MessageItemProps) {
  const initial = (message.sender_name || '?').charAt(0).toUpperCase();
  const timeDisplay = formatMessageTime(message.created_at);

  return (
    <div className="flex gap-3">
      {/* Avatar */}
      <div className={cn(
        'flex-shrink-0 w-8 h-8 rounded-full flex items-center justify-center text-xs font-medium',
        isOwnMessage ? 'bg-primary/20 text-primary' : 'bg-muted text-muted-foreground'
      )}>
        {initial}
      </div>

      {/* Content */}
      <div className="flex-1 min-w-0">
        <div className="flex items-baseline gap-2">
          <span className="text-sm font-medium">
            {message.sender_name}
            {isOwnMessage && <span className="text-muted-foreground font-normal"> (you)</span>}
          </span>
        </div>
        <p className="text-sm mt-0.5 whitespace-pre-wrap break-words">
          {message.content}
        </p>
        <span className="text-[11px] text-muted-foreground mt-1 inline-block">
          {timeDisplay}
        </span>
      </div>
    </div>
  );
}

// Format message timestamp
function formatMessageTime(dateStr: string): string {
  const date = new Date(dateStr);
  const now = new Date();

  const timeStr = date.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' });

  // Today: just time
  if (date.toDateString() === now.toDateString()) {
    return timeStr;
  }

  // Yesterday
  const yesterday = new Date(now);
  yesterday.setDate(yesterday.getDate() - 1);
  if (date.toDateString() === yesterday.toDateString()) {
    return `Yesterday ${timeStr}`;
  }

  // Older: date + time
  const dateStr2 = date.toLocaleDateString('en-GB', { day: 'numeric', month: 'short' });
  return `${dateStr2} ${timeStr}`;
}
```

**File 4: `web/app/(dashboard)/messages/components/MessageInput.tsx`**

Textarea with Enter-to-send (Shift+Enter for newline) and a visible Send button:

```typescript
'use client';

import { useState, useRef } from 'react';
import { Button } from '@/components/ui/button';
import { Send } from 'lucide-react';

interface MessageInputProps {
  conversationId: string;
  onMessageSent: () => void;
}

export function MessageInput({ conversationId, onMessageSent }: MessageInputProps) {
  const [content, setContent] = useState('');
  const [sending, setSending] = useState(false);
  const textareaRef = useRef<HTMLTextAreaElement>(null);

  const handleSend = async () => {
    const trimmed = content.trim();
    if (!trimmed || sending) return;

    setSending(true);
    try {
      const res = await fetch('/api/messages/send', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ conversationId, content: trimmed }),
      });

      if (!res.ok) {
        const errorData = await res.json().catch(() => ({}));
        console.error('Failed to send message:', errorData);
        return;
      }

      setContent('');
      onMessageSent();

      // Auto-resize textarea back to default
      if (textareaRef.current) {
        textareaRef.current.style.height = 'auto';
      }
    } catch (err) {
      console.error('Error sending message:', err);
    } finally {
      setSending(false);
    }
  };

  const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSend();
    }
  };

  // Auto-resize textarea as content grows (up to max-height)
  const handleChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setContent(e.target.value);
    const textarea = e.target;
    textarea.style.height = 'auto';
    textarea.style.height = `${Math.min(textarea.scrollHeight, 160)}px`; // max ~5 lines
  };

  return (
    <div className="border-t p-3 bg-background">
      <div className="flex gap-2 items-end">
        <textarea
          ref={textareaRef}
          value={content}
          onChange={handleChange}
          onKeyDown={handleKeyDown}
          placeholder="Type a message..."
          rows={1}
          className="flex-1 resize-none rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 max-h-40 overflow-y-auto"
          disabled={sending}
        />
        <Button
          onClick={handleSend}
          disabled={!content.trim() || sending}
          size="icon"
          className="h-9 w-9 flex-shrink-0"
        >
          <Send className="h-4 w-4" />
        </Button>
      </div>
      <p className="text-[10px] text-muted-foreground mt-1">
        Press Enter to send, Shift+Enter for a new line
      </p>
    </div>
  );
}
```

**IMPORTANT:** Also update `ConversationList.tsx` (from 41-01) to accept an optional `selectedId` prop. Add `selectedId?: string` to the `ConversationListProps` interface and pass it to ConversationRow's `isSelected` prop instead of the local state default.
  </action>
  <verify>
Run `ls web/app/(dashboard)/messages/*/page.tsx` — the [conversationId] dynamic route page exists.
Run `ls web/app/(dashboard)/messages/components/MessageThread.tsx web/app/(dashboard)/messages/components/MessageItem.tsx web/app/(dashboard)/messages/components/MessageInput.tsx` — all 3 components exist.
Run `grep "Enter" web/app/(dashboard)/messages/components/MessageInput.tsx` — should match the Enter-to-send handler.
Run `grep "scrollIntoView" web/app/(dashboard)/messages/components/MessageThread.tsx` — should match scroll-to-bottom.
Run `grep "mark.*read\|conversations.*read" web/app/(dashboard)/messages/components/MessageThread.tsx` — should match mark-as-read call.
Run `grep "Slack\|left-aligned\|flex gap" web/app/(dashboard)/messages/components/MessageItem.tsx` — should match flat list layout (flex gap).
Run `grep "max-h-40\|max-height\|160" web/app/(dashboard)/messages/components/MessageInput.tsx` — should match textarea max-height.
  </verify>
  <done>Message thread page shows conversation with flat Slack-style message list (sender avatar, name, content, timestamp). Send via Enter or Send button, Shift+Enter for newline. Textarea auto-grows up to ~5 lines with overflow scroll. Mark-as-read fires on thread open. After sending, both messages and conversations queries are invalidated for fresh data. Two-panel layout maintained: conversation list sidebar + active thread. Back button for mobile navigation.</done>
</task>

</tasks>

<verification>
1. /messages/{conversationId} route loads with conversation header and message list
2. Messages displayed as flat list with sender avatar/initials, name, content, and timestamp
3. Own messages show "(you)" after sender name
4. Thread scrolls to bottom on initial load
5. Enter sends message, Shift+Enter inserts newline
6. Send button is disabled when textarea is empty or during send
7. After sending, message appears in thread (via query invalidation)
8. After sending, conversation list updates last_message_preview and timestamp
9. Opening a thread calls PATCH /api/messages/conversations/{id}/read
10. Mark-as-read invalidates conversations query (unread badge updates)
11. Textarea auto-resizes with max-height of 160px (overflow-y: auto beyond that)
12. API routes use org_id scoping via requireOrgId()
13. API routes return appropriate error codes (400, 401, 404, 500)
</verification>

<success_criteria>
- Dynamic route [conversationId] renders message thread for any valid conversation
- Messages fetched in ASC order (oldest first, scroll position at bottom)
- Send message API validates content (non-empty, max 5000 chars), inserts message, updates conversation metadata
- Mark-as-read API upserts conversation_read_status with current timestamp
- Flat message layout matches Slack/Teams style (not chat bubbles)
- Textarea Enter-to-send and Shift+Enter for newline work correctly
- No new npm packages — uses existing shadcn/ui, lucide-react, @tanstack/react-query
</success_criteria>

<output>
After completion, create `.planning/phases/41-web-messaging-core/41-02-SUMMARY.md`
</output>
