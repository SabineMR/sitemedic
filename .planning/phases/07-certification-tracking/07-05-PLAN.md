---
phase: 07-certification-tracking
plan: 05
type: execute
wave: 1
depends_on: ["07-04"]
files_modified:
  - app/treatment/new.tsx
  - app/treatment/templates.tsx
  - components/forms/WorkerSearchPicker.tsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Medic with expired certifications cannot complete a treatment log"
    - "Treatment form shows clear error message with expired cert types when validation fails"
    - "Quick template workflow also validates medic certs before creating treatment"
  artifacts:
    - path: "app/treatment/new.tsx"
      provides: "Certification validation on treatment completion"
      contains: "certifications/validate"
    - path: "app/treatment/templates.tsx"
      provides: "Certification validation on template selection"
      contains: "certifications/validate"
  key_links:
    - from: "app/treatment/new.tsx"
      to: "web/app/api/certifications/validate/route.ts"
      via: "fetch POST on handleCompleteTreatment"
      pattern: "certifications/validate"
    - from: "app/treatment/templates.tsx"
      to: "web/app/api/certifications/validate/route.ts"
      via: "fetch POST on handleTemplateSelect"
      pattern: "certifications/validate"
---

<objective>
Wire certification validation API into mobile treatment forms so medics with expired certifications are blocked from completing incident logging.

Purpose: Close the critical enforcement gap (CERT-06). The validation API exists at /api/certifications/validate and correctly returns 403 for expired certs, but zero callers exist in the codebase. Mobile treatment forms must call this API before allowing treatment completion.

Output: Treatment forms (new.tsx, templates.tsx) call validation API and block submission with user-friendly error when medic has expired certifications.
</objective>

<execution_context>
@/Users/sabineresoagli/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sabineresoagli/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-certification-tracking/07-04-SUMMARY.md

Key files to understand:
- web/app/api/certifications/validate/route.ts (the validation API -- POST with {worker_id} where worker_id is actually medic_id, returns 200 or 403 with expired_certs array)
- app/treatment/new.tsx (full treatment form with handleCompleteTreatment)
- app/treatment/templates.tsx (quick template workflow with handleTemplateSelect)
- src/lib/supabase.ts (Expo Supabase client with EXPO_PUBLIC_SUPABASE_URL)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add certification validation to treatment completion flow</name>
  <files>app/treatment/new.tsx, app/treatment/templates.tsx</files>
  <action>
  IMPORTANT CONTEXT: The validation API at /api/certifications/validate takes {worker_id} which is actually a medic_id. The mobile app medic (the person using the app) is the one who needs their certifications validated. The "worker" in the treatment form is the construction worker being treated -- they are NOT the ones with certifications.

  The validation should check the LOGGED-IN MEDIC's certifications, not the selected worker's. The medic_id is currently set to 'temp-medic' in the treatment form (TODO comment), but we should get it from the Supabase auth context.

  **In app/treatment/new.tsx:**

  1. Import supabase from '../../src/lib/supabase'
  2. Add a new state variable: `const [certValidationError, setCertValidationError] = useState<string | null>(null);`
  3. Create a helper function `validateMedicCertifications` that:
     - Gets the current user via `supabase.auth.getUser()`
     - Fetches POST to the Next.js web app validation endpoint. Use the environment variable pattern: `const webAppUrl = process.env.EXPO_PUBLIC_WEB_APP_URL || 'http://localhost:30500';`
     - POST to `${webAppUrl}/api/certifications/validate` with body `{ worker_id: userId }` (worker_id is the field name the API expects, but we pass the medic's user ID)
     - If response is 403, parse the JSON body to get `expired_certs` and `message`
     - Return `{ valid: boolean, message?: string, expired_certs?: string[] }`
     - If fetch fails (network error -- remember offline-first), return `{ valid: true }` to NOT block offline treatment logging. Add a console.warn about skipping validation due to network.

  4. In `handleCompleteTreatment`, BEFORE the existing validation checks (workerId, injuryTypeId, signatureUri), add the certification validation call:
     ```
     const certCheck = await validateMedicCertifications();
     if (!certCheck.valid) {
       setCertValidationError(certCheck.message || 'You have expired certifications');
       Alert.alert(
         'Expired Certifications',
         `You cannot log treatments while you have expired certifications: ${certCheck.expired_certs?.join(', ')}. Please renew your certifications to continue.`,
         [{ text: 'OK' }]
       );
       return;
     }
     setCertValidationError(null);
     ```

  5. Add a visual error banner ABOVE the worker selection section (before Section 1). Show it when certValidationError is not null:
     ```jsx
     {certValidationError && (
       <View style={styles.certErrorBanner}>
         <Text style={styles.certErrorText}>
           {certValidationError}
         </Text>
       </View>
     )}
     ```

  6. Add styles for certErrorBanner (red background #FEF2F2, red border #EF4444, same pattern as riddorBanner but red):
     ```
     certErrorBanner: {
       backgroundColor: '#FEF2F2',
       borderWidth: 2,
       borderColor: '#EF4444',
       borderRadius: 8,
       padding: 12,
       marginBottom: 16,
     },
     certErrorText: {
       fontSize: 16,
       fontWeight: '600',
       color: '#991B1B',
       textAlign: 'center',
     },
     ```

  **In app/treatment/templates.tsx:**

  1. Import supabase from '../../src/lib/supabase' and add Alert import (already imported)
  2. Add same certValidationError state and validateMedicCertifications helper function (identical logic)
  3. In `handleTemplateSelect`, AFTER the existing worker validation check (`if (!selectedWorkerId)`), add certification validation:
     ```
     const certCheck = await validateMedicCertifications();
     if (!certCheck.valid) {
       Alert.alert(
         'Expired Certifications',
         `You cannot log treatments while you have expired certifications: ${certCheck.expired_certs?.join(', ')}. Please renew your certifications to continue.`,
         [{ text: 'OK' }]
       );
       return;
     }
     ```
  4. Add the same certErrorBanner UI above worker selection section
  5. Add the same certError styles

  CRITICAL: The validation gracefully degrades when offline (returns valid: true). This preserves the offline-first architecture. Medics can always log treatments offline. The validation only blocks when the app CAN reach the API and the API confirms expired certs.

  Do NOT modify WorkerSearchPicker.tsx -- the worker being selected is a construction worker (patient), not the medic. Validation applies to the medic using the app.
  </action>
  <verify>
  1. Grep for 'certifications/validate' in app/treatment/new.tsx -- must find fetch call
  2. Grep for 'certifications/validate' in app/treatment/templates.tsx -- must find fetch call
  3. Grep for 'certValidationError' in both files -- must find state and UI rendering
  4. Grep for 'certErrorBanner' in both files -- must find style definition
  5. Grep for 'Expired Certifications' in both files -- must find Alert.alert calls
  6. Verify offline graceful degradation: grep for 'valid: true' in catch block of validateMedicCertifications
  </verify>
  <done>
  - app/treatment/new.tsx calls /api/certifications/validate before completing treatment
  - app/treatment/templates.tsx calls /api/certifications/validate before creating template treatment
  - Both show Alert with expired cert types on 403 response
  - Both show red error banner in UI when validation fails
  - Both gracefully degrade to allowing treatment when offline (fetch fails)
  - WorkerSearchPicker.tsx is NOT modified (workers are patients, not medics)
  </done>
</task>

</tasks>

<verification>
- `grep -r 'certifications/validate' app/treatment/` returns matches in both new.tsx and templates.tsx
- `grep -r 'certValidationError' app/treatment/` confirms state management in both files
- `grep -r 'Expired Certifications' app/treatment/` confirms user-facing error messages
- `grep -r 'valid: true' app/treatment/` confirms offline graceful degradation in catch blocks
- No changes to WorkerSearchPicker.tsx (worker selection is about patients, not medics)
</verification>

<success_criteria>
1. Treatment new.tsx calls validation API before completing treatment and blocks if medic has expired certs
2. Treatment templates.tsx calls validation API before creating template treatment and blocks if medic has expired certs
3. User sees clear Alert with specific expired cert types (e.g., "CSCS, IPAF")
4. Red error banner appears in UI when certification validation fails
5. Offline-first preserved: validation gracefully skipped when network unavailable
</success_criteria>

<output>
After completion, create `.planning/phases/07-certification-tracking/07-05-SUMMARY.md`
</output>
