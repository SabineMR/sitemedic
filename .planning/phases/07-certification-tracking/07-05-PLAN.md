---
phase: 07-certification-tracking
plan: 05
type: execute
wave: 1
depends_on: ["07-04"]
files_modified:
  - app/treatment/new.tsx
  - app/treatment/templates.tsx
  - src/types/env.d.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Medic with expired certifications cannot complete a treatment log"
    - "Treatment form shows clear error message with expired cert types when validation fails"
    - "Quick template workflow also validates medic certs before creating treatment"
  artifacts:
    - path: "app/treatment/new.tsx"
      provides: "Certification validation on treatment completion"
      contains: "certifications/validate"
    - path: "app/treatment/templates.tsx"
      provides: "Certification validation on template selection"
      contains: "certifications/validate"
    - path: "src/types/env.d.ts"
      provides: "EXPO_PUBLIC_WEB_APP_URL type declaration"
      contains: "EXPO_PUBLIC_WEB_APP_URL"
  key_links:
    - from: "app/treatment/new.tsx"
      to: "web/app/api/certifications/validate/route.ts"
      via: "fetch POST on handleCompleteTreatment"
      pattern: "certifications/validate"
    - from: "app/treatment/templates.tsx"
      to: "web/app/api/certifications/validate/route.ts"
      via: "fetch POST on handleTemplateSelect"
      pattern: "certifications/validate"
    - from: "app/treatment/new.tsx"
      to: "medics table via user_id lookup"
      via: "supabase.from('medics').select('id').eq('user_id', userId)"
      pattern: "eq\\('user_id'"
---

<objective>
Wire certification validation API into mobile treatment forms so medics with expired certifications are blocked from completing incident logging.

Purpose: Close the critical enforcement gap (CERT-06). The validation API exists at /api/certifications/validate and correctly returns 403 for expired certs, but zero callers exist in the codebase. Mobile treatment forms must call this API before allowing treatment completion.

Output: Treatment forms (new.tsx, templates.tsx) call validation API and block submission with user-friendly error when medic has expired certifications.
</objective>

<execution_context>
@/Users/sabineresoagli/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sabineresoagli/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-certification-tracking/07-04-SUMMARY.md

Key files to understand:
- web/app/api/certifications/validate/route.ts (the validation API -- POST with {worker_id} where worker_id is actually medic_id from medics table, returns 200 or 403 with expired_certs array)
- app/treatment/new.tsx (full treatment form with handleCompleteTreatment)
- app/treatment/templates.tsx (quick template workflow with handleTemplateSelect)
- src/lib/supabase.ts (Expo Supabase client with EXPO_PUBLIC_SUPABASE_URL)
- src/types/env.d.ts (Expo environment variable type declarations)
- supabase/migrations/002_business_operations.sql (medics table: id is auto-generated UUID, user_id references auth.users(id) -- these are DIFFERENT)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Configure EXPO_PUBLIC_WEB_APP_URL environment variable</name>
  <files>src/types/env.d.ts, .env, .env.example</files>
  <action>
  The plan uses EXPO_PUBLIC_WEB_APP_URL to call the Next.js web app validation API from the Expo mobile app. This env var does NOT exist yet -- it must be declared and configured.

  **In src/types/env.d.ts:**

  1. Add `EXPO_PUBLIC_WEB_APP_URL: string;` to BOTH the `@env` module declaration AND the `ProcessEnv` interface, alongside the existing EXPO_PUBLIC_SUPABASE_URL and EXPO_PUBLIC_SUPABASE_ANON_KEY declarations.

  **In .env:**

  2. Add a new line: `EXPO_PUBLIC_WEB_APP_URL=http://localhost:30500`
  (Port 30500 is the SiteMedic web app dev server port)

  **In .env.example:**

  3. Add a new line: `EXPO_PUBLIC_WEB_APP_URL=http://localhost:30500`
  With a comment: `# Web app URL for mobile->web API calls (certification validation)`
  </action>
  <verify>
  1. Grep for 'EXPO_PUBLIC_WEB_APP_URL' in src/types/env.d.ts -- must find 2 declarations (module + ProcessEnv)
  2. Grep for 'EXPO_PUBLIC_WEB_APP_URL' in .env -- must find the variable set to http://localhost:30500
  3. Grep for 'EXPO_PUBLIC_WEB_APP_URL' in .env.example -- must find the variable with comment
  </verify>
  <done>
  - EXPO_PUBLIC_WEB_APP_URL declared in TypeScript env types (both @env module and ProcessEnv)
  - .env has EXPO_PUBLIC_WEB_APP_URL=http://localhost:30500
  - .env.example has EXPO_PUBLIC_WEB_APP_URL with descriptive comment
  </done>
</task>

<task type="auto">
  <name>Task 2: Add certification validation to treatment completion flow with correct medic ID mapping</name>
  <files>app/treatment/new.tsx, app/treatment/templates.tsx</files>
  <action>
  CRITICAL ARCHITECTURE NOTE -- medics.id vs auth.users.id:
  The medics table has TWO different IDs:
  - `id` (UUID PRIMARY KEY, auto-generated) -- this is what the validation API expects as `worker_id`
  - `user_id` (UUID REFERENCES auth.users(id)) -- this is what supabase.auth.getUser() returns

  These are DIFFERENT values. The validation API does `.eq('id', worker_id)` against the medics table.
  So we MUST first look up the medic record by `user_id` to get the medics table `id`, then pass THAT to the validation API.

  **In app/treatment/new.tsx:**

  1. Import supabase from '../../src/lib/supabase'
  2. Add a new state variable: `const [certValidationError, setCertValidationError] = useState<string | null>(null);`
  3. Create a helper function `validateMedicCertifications` that:
     a. Gets the current user via `const { data: { user } } = await supabase.auth.getUser()`
     b. If no user, return `{ valid: true }` (offline/unauthenticated -- don't block)
     c. Look up the medic record to get medics.id:
        ```typescript
        const { data: medic, error: medicError } = await supabase
          .from('medics')
          .select('id')
          .eq('user_id', user.id)
          .single();
        ```
     d. If medic lookup fails (no medic record for this user), return `{ valid: true }` with console.warn('No medic record found for user, skipping cert validation')
     e. Use medic.id (NOT user.id) to call the validation API:
        ```typescript
        const webAppUrl = process.env.EXPO_PUBLIC_WEB_APP_URL || 'http://localhost:30500';
        const response = await fetch(`${webAppUrl}/api/certifications/validate`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ worker_id: medic.id }),
        });
        ```
     f. If response is 403, parse the JSON body to get `expired_certs` and `message`
     g. Return `{ valid: boolean, message?: string, expired_certs?: string[] }`
     h. If fetch fails (network error -- remember offline-first), return `{ valid: true }` to NOT block offline treatment logging. Add a console.warn about skipping validation due to network.

  4. In `handleCompleteTreatment`, BEFORE the existing validation checks (workerId, injuryTypeId, signatureUri), add the certification validation call:
     ```
     const certCheck = await validateMedicCertifications();
     if (!certCheck.valid) {
       setCertValidationError(certCheck.message || 'You have expired certifications');
       Alert.alert(
         'Expired Certifications',
         `You cannot log treatments while you have expired certifications: ${certCheck.expired_certs?.join(', ')}. Please renew your certifications to continue.`,
         [{ text: 'OK' }]
       );
       return;
     }
     setCertValidationError(null);
     ```

  5. Add a visual error banner ABOVE the worker selection section (before Section 1). Show it when certValidationError is not null:
     ```jsx
     {certValidationError && (
       <View style={styles.certErrorBanner}>
         <Text style={styles.certErrorText}>
           {certValidationError}
         </Text>
       </View>
     )}
     ```

  6. Add styles for certErrorBanner (red background #FEF2F2, red border #EF4444, same pattern as riddorBanner but red):
     ```
     certErrorBanner: {
       backgroundColor: '#FEF2F2',
       borderWidth: 2,
       borderColor: '#EF4444',
       borderRadius: 8,
       padding: 12,
       marginBottom: 16,
     },
     certErrorText: {
       fontSize: 16,
       fontWeight: '600',
       color: '#991B1B',
       textAlign: 'center',
     },
     ```

  **In app/treatment/templates.tsx:**

  1. Import supabase from '../../src/lib/supabase' and add Alert import (already imported)
  2. Add same certValidationError state and validateMedicCertifications helper function (identical logic including the medics table lookup by user_id)
  3. In `handleTemplateSelect`, AFTER the existing worker validation check (`if (!selectedWorkerId)`), add certification validation:
     ```
     const certCheck = await validateMedicCertifications();
     if (!certCheck.valid) {
       Alert.alert(
         'Expired Certifications',
         `You cannot log treatments while you have expired certifications: ${certCheck.expired_certs?.join(', ')}. Please renew your certifications to continue.`,
         [{ text: 'OK' }]
       );
       return;
     }
     ```
  4. Add the same certErrorBanner UI above worker selection section
  5. Add the same certError styles

  CRITICAL: The validation gracefully degrades when offline (returns valid: true). This preserves the offline-first architecture. Medics can always log treatments offline. The validation only blocks when the app CAN reach the API and the API confirms expired certs.

  CRITICAL: The medic ID mapping uses `.eq('user_id', user.id)` to look up the medics table record, then passes `medic.id` to the validation API. Do NOT pass `user.id` directly -- it would cause a 404 from the validation API because `medics.id != auth.users.id`.

  Do NOT modify WorkerSearchPicker.tsx -- the worker being selected is a construction worker (patient), not the medic. Validation applies to the medic using the app.
  </action>
  <verify>
  1. Grep for 'certifications/validate' in app/treatment/new.tsx -- must find fetch call
  2. Grep for 'certifications/validate' in app/treatment/templates.tsx -- must find fetch call
  3. Grep for "eq('user_id'" in app/treatment/new.tsx -- must find medic lookup by user_id (NOT by id)
  4. Grep for "eq('user_id'" in app/treatment/templates.tsx -- must find medic lookup by user_id
  5. Grep for 'worker_id: medic.id' in both files -- must confirm we pass medic table ID, not auth user ID
  6. Grep for 'certValidationError' in both files -- must find state and UI rendering
  7. Grep for 'certErrorBanner' in both files -- must find style definition
  8. Grep for 'Expired Certifications' in both files -- must find Alert.alert calls
  9. Verify offline graceful degradation: grep for 'valid: true' in catch block of validateMedicCertifications
  10. Verify EXPO_PUBLIC_WEB_APP_URL usage: grep for 'EXPO_PUBLIC_WEB_APP_URL' in both files
  </verify>
  <done>
  - app/treatment/new.tsx looks up medic by user_id to get medics.id, then calls /api/certifications/validate with correct medic table ID
  - app/treatment/templates.tsx does the same user_id -> medics.id mapping before validation
  - Both show Alert with expired cert types on 403 response
  - Both show red error banner in UI when validation fails
  - Both gracefully degrade to allowing treatment when offline (fetch fails) or when no medic record found
  - WorkerSearchPicker.tsx is NOT modified (workers are patients, not medics)
  - EXPO_PUBLIC_WEB_APP_URL used for API URL with localhost:30500 fallback
  </done>
</task>

</tasks>

<verification>
- `grep -r 'certifications/validate' app/treatment/` returns matches in both new.tsx and templates.tsx
- `grep -r "eq('user_id'" app/treatment/` confirms medic lookup by user_id in both files (NOT by id)
- `grep -r 'worker_id: medic.id' app/treatment/` confirms correct medic table ID passed to API
- `grep -r 'certValidationError' app/treatment/` confirms state management in both files
- `grep -r 'Expired Certifications' app/treatment/` confirms user-facing error messages
- `grep -r 'valid: true' app/treatment/` confirms offline graceful degradation in catch blocks
- `grep -r 'EXPO_PUBLIC_WEB_APP_URL' src/types/env.d.ts` confirms type declaration exists
- `grep 'EXPO_PUBLIC_WEB_APP_URL' .env` confirms env var is configured
- No changes to WorkerSearchPicker.tsx (worker selection is about patients, not medics)
</verification>

<success_criteria>
1. EXPO_PUBLIC_WEB_APP_URL declared in env.d.ts (both @env module and ProcessEnv) and set in .env and .env.example
2. Treatment new.tsx looks up medic by user_id, gets medics.id, and calls validation API with correct ID
3. Treatment templates.tsx does the same user_id-to-medics.id mapping before calling validation API
4. User sees clear Alert with specific expired cert types (e.g., "CSCS, IPAF")
5. Red error banner appears in UI when certification validation fails
6. Offline-first preserved: validation gracefully skipped when network unavailable or medic record not found
7. No 404 errors from validation API due to ID mismatch (medics.id used, not auth.users.id)
</success_criteria>

<output>
After completion, create `.planning/phases/07-certification-tracking/07-05-SUMMARY.md`
</output>
