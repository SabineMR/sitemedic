---
phase: 06-riddor-auto-flagging
plan: 07
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/031_riddor_auto_detect_trigger.sql
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Treatment INSERT or UPDATE on treatments table automatically invokes riddor-detector Edge Function"
    - "riddor_incidents table is populated when treatment matches RIDDOR criteria (no manual call needed)"
    - "Duplicate detection calls for same treatment are handled gracefully (idempotent)"
    - "Dashboard shows auto-flagged RIDDOR incidents with deadline countdown"
    - "Deadline email cron finds incidents to notify about"
  artifacts:
    - path: "supabase/migrations/031_riddor_auto_detect_trigger.sql"
      provides: "PostgreSQL trigger that calls riddor-detector Edge Function via pg_net on treatment INSERT/UPDATE"
      contains: "CREATE TRIGGER"
  key_links:
    - from: "treatments table INSERT/UPDATE"
      to: "riddor-detector Edge Function"
      via: "pg_net.http_post in trigger function"
      pattern: "net\\.http_post.*riddor-detector"
    - from: "riddor-detector Edge Function"
      to: "riddor_incidents table"
      via: "INSERT query (already wired in 06-01)"
      pattern: "riddor_incidents.*insert"
---

<objective>
Wire the RIDDOR auto-detection trigger into the data pipeline by creating a PostgreSQL database trigger on the treatments table that automatically calls the riddor-detector Edge Function via pg_net whenever a treatment is created or updated.

Purpose: This is the PRIMARY gap blocking Phase 6 goal achievement. The riddor-detector Edge Function exists and is correct (176 lines, 8 HSE criteria, confidence scoring), but NOTHING calls it automatically. The riddor_incidents table stays empty, making the dashboard, email notifications, and analytics all non-functional. This trigger completes the data pipeline: Treatment saved -> Trigger fires -> riddor-detector called -> riddor_incidents populated -> Dashboard/emails/analytics all work.

Output: A PostgreSQL migration creating a trigger function and trigger on the treatments table.
</objective>

<execution_context>
@/Users/sabineresoagli/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sabineresoagli/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-riddor-auto-flagging/06-VERIFICATION.md
@.planning/phases/06-riddor-auto-flagging/06-01-SUMMARY.md

# Key reference files
@supabase/functions/riddor-detector/index.ts
@supabase/migrations/018_riddor_incidents.sql
@supabase/migrations/021_riddor_deadline_cron.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PostgreSQL trigger migration for RIDDOR auto-detection</name>
  <files>supabase/migrations/031_riddor_auto_detect_trigger.sql</files>
  <action>
    Create a new Supabase migration that:

    1. Ensures pg_net extension is enabled: `CREATE EXTENSION IF NOT EXISTS pg_net;`

    2. Creates a trigger function `detect_riddor_on_treatment()` that:
       - Fires AFTER INSERT OR UPDATE on the `treatments` table
       - Uses `pg_net.http_post()` to call the `riddor-detector` Edge Function asynchronously (non-blocking, does NOT delay the treatment INSERT/UPDATE transaction)
       - Sends `{"treatment_id": NEW.id}` as the JSON body
       - Authenticates with service_role_key from Vault secrets (same pattern as migration 021_riddor_deadline_cron.sql: `SELECT decrypted_secret FROM vault.decrypted_secrets WHERE name = 'service_role_key'` for the Authorization header, and `SELECT decrypted_secret FROM vault.decrypted_secrets WHERE name = 'project_url'` for the base URL)
       - Returns NEW (does not modify the treatment row)
       - Includes a condition: Only fire when the treatment has a non-null `injury_type` field (skip incomplete drafts that haven't selected an injury yet, avoiding unnecessary Edge Function calls)

    3. Creates the trigger on the treatments table:
       ```sql
       CREATE TRIGGER riddor_auto_detect_trigger
         AFTER INSERT OR UPDATE ON treatments
         FOR EACH ROW
         WHEN (NEW.injury_type IS NOT NULL)
         EXECUTE FUNCTION detect_riddor_on_treatment();
       ```

    4. The trigger fires on UPDATE as well because:
       - Treatments start as drafts and get completed (injury_type may be added later)
       - Auto-save may update treatment data progressively
       - The riddor-detector Edge Function is idempotent (uses UNIQUE constraint on treatment_id in riddor_incidents, ignores PostgreSQL 23505 duplicate errors)

    5. Add migration comments documenting:
       - Purpose: Completes the RIDDOR auto-detection data pipeline
       - Why pg_net: Non-blocking async HTTP call (does not delay treatment writes)
       - Why Vault: Secure service_role_key storage (same pattern as 021)
       - Idempotency: Safe to call multiple times per treatment (Edge Function handles duplicates)

    IMPORTANT: Use pg_net.http_post (NOT net.http_post). The function name in pg_net is `net.http_post` when the extension is loaded in the `net` schema, but check the pattern used in migration 021 and match it exactly. Migration 021 uses `net.http_post` so use the same.

    IMPORTANT: Do NOT use `pg_net.http_post` as a function name. The extension creates functions in the `net` schema, so it's `net.http_post()`. Match migration 021 pattern exactly.

    The migration should be idempotent:
    - Drop trigger if exists before creating: `DROP TRIGGER IF EXISTS riddor_auto_detect_trigger ON treatments;`
    - Use `CREATE OR REPLACE FUNCTION` for the trigger function
  </action>
  <verify>
    1. File exists: `ls supabase/migrations/031_riddor_auto_detect_trigger.sql`
    2. Contains trigger creation: `grep 'CREATE TRIGGER' supabase/migrations/031_riddor_auto_detect_trigger.sql`
    3. Contains pg_net call: `grep 'net.http_post' supabase/migrations/031_riddor_auto_detect_trigger.sql`
    4. Contains vault secret pattern: `grep 'vault.decrypted_secrets' supabase/migrations/031_riddor_auto_detect_trigger.sql`
    5. Contains idempotency: `grep 'DROP TRIGGER IF EXISTS' supabase/migrations/031_riddor_auto_detect_trigger.sql`
    6. Contains injury_type guard: `grep 'injury_type IS NOT NULL' supabase/migrations/031_riddor_auto_detect_trigger.sql`
  </verify>
  <done>
    PostgreSQL trigger exists on treatments table that:
    - Fires AFTER INSERT OR UPDATE when injury_type IS NOT NULL
    - Calls riddor-detector Edge Function via net.http_post (non-blocking)
    - Authenticates with Vault service_role_key
    - Is idempotent (safe to re-run migration)

    Data pipeline is complete:
    Treatment saved -> Trigger fires -> riddor-detector called -> riddor_incidents populated -> Dashboard/emails/analytics all receive data
  </done>
</task>

</tasks>

<verification>
1. Migration file exists and is syntactically valid SQL
2. Trigger pattern matches existing pg_cron pattern in migration 021 (Vault secrets, net.http_post)
3. Trigger only fires when injury_type IS NOT NULL (avoids wasted Edge Function calls on empty drafts)
4. Trigger is idempotent (DROP IF EXISTS before CREATE)
5. Non-blocking: pg_net.http_post is async, does not delay treatment INSERT/UPDATE
</verification>

<success_criteria>
The data pipeline gap is closed: treatments table INSERT/UPDATE automatically invokes riddor-detector Edge Function, which populates riddor_incidents table when RIDDOR criteria are matched. This unblocks dashboard (06-04), email notifications (06-05), and analytics (06-06) which all query riddor_incidents.
</success_criteria>

<output>
After completion, create `.planning/phases/06-riddor-auto-flagging/06-07-SUMMARY.md`
</output>
