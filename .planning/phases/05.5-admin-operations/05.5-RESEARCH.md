# Phase 5.5: Admin Operations Dashboards - Research

**Researched:** 2026-02-16
**Domain:** Next.js 15 admin dashboard with data visualization, bulk operations, and territory management
**Confidence:** HIGH

## Summary

Researched implementation approaches for a comprehensive admin dashboard with 6 major functional areas: bookings management, medic roster, territory coverage maps, revenue tracking, timesheet approval, and client management. The phase extends the existing Phase 4 web dashboard (Next.js 15 + shadcn/ui + TanStack Query + Supabase) with admin-specific capabilities.

**Key findings:**
- Next.js 15 App Router with Server Components for initial data load, Client Components for interactivity
- TanStack Table v8 with row selection is the established pattern for bulk operations (already used in codebase)
- Recharts (already installed) is optimal for React admin dashboards with revenue/utilization charts
- React Leaflet (already installed) supports territory heat maps with color-coded overlays
- Batch timesheet approval (20 in <5 min) requires PostgreSQL bulk upsert with 500-1000 row batches
- Optimistic updates via TanStack Query onMutate provide instant feedback for approval workflows

**Primary recommendation:** Extend existing Phase 4 patterns with row selection, add Recharts components for revenue dashboard, implement PostgreSQL batch operations via Server Actions, use optimistic updates for admin approval workflows.

## Standard Stack

The established libraries/tools for this domain:

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| Next.js | 15.x | App Router, Server Components, Server Actions | Industry standard for React SSR/SSG, already in codebase |
| TanStack Table | 8.x | Data tables with sorting, filtering, row selection | Best-in-class headless table library, already used in Phase 4 |
| TanStack Query | 5.x | Server state management, optimistic updates | De facto standard for data fetching in React, already in codebase |
| shadcn/ui | latest | UI component library (tables, dialogs, badges) | Already established in Phase 4, consistent design system |
| Recharts | 3.x | Revenue charts, utilization graphs | React-native charting, already installed, best for React dashboards |
| React Leaflet | 5.x | Territory coverage maps | Leaflet integration for React, already installed in Phase 4 |
| Supabase | 2.x | PostgreSQL backend, RLS, batch operations | Already established in Phase 1.5 for database |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| date-fns | 4.x | Date formatting, range calculations | Already installed, for timesheet filtering by week |
| Zustand | 5.x | Client-side state (filters, selections) | Already installed, lightweight state for UI state |
| lucide-react | 0.x | Icons for badges, alerts, actions | Already installed, consistent with Phase 4 |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Recharts | Chart.js | Chart.js has better performance with >10k data points, but Recharts has better React integration and is already installed |
| React Leaflet | Google Maps React | Google Maps has better geocoding, but Leaflet is open-source, no API key required, already installed |
| Server Actions | Route Handlers | Route Handlers give more control, but Server Actions are simpler for form mutations and already used in codebase |

**Installation:**
```bash
# No new packages required - all dependencies already installed in Phase 4
# Verify installed packages:
pnpm list recharts react-leaflet @tanstack/react-table
```

## Architecture Patterns

### Recommended Project Structure
```
web/app/(dashboard)/admin/
├── page.tsx                    # Admin overview landing page
├── bookings/
│   └── page.tsx               # Bookings management with approval workflow
├── medics/
│   └── page.tsx               # Medic roster with availability calendar
├── territories/
│   └── page.tsx               # Territory coverage map
├── revenue/
│   └── page.tsx               # Revenue dashboard with charts
├── timesheets/
│   └── page.tsx               # Batch timesheet approval
└── clients/
    └── page.tsx               # Client management

web/components/admin/
├── booking-approval-table.tsx  # Bulk approve/reject/reassign
├── medic-roster-table.tsx      # Availability, assignments, utilization
├── territory-map.tsx           # Leaflet map with color-coded regions
├── revenue-charts.tsx          # Recharts components
├── timesheet-batch-approval.tsx # Batch selection with <5 min target
├── client-management-table.tsx  # Payment terms, Net 30 upgrades
├── admin-stat-card.tsx         # Reusable metric card
├── admin-alert-banner.tsx      # Coverage gaps, cash flow warnings
└── bulk-action-toolbar.tsx     # Floating toolbar for selected items

web/lib/queries/admin/
├── bookings.ts                 # useBookings, approveBookings mutation
├── medics.ts                   # useMedics, updateAvailability
├── territories.ts              # useTerritories, utilization calculations
├── revenue.ts                  # useRevenue, cash flow projections
├── timesheets.ts               # usePendingTimesheets, batchApprove
└── clients.ts                  # useClients, upgradeToNet30

web/app/api/admin/             # Server Actions for batch operations
├── approve-bookings/route.ts
├── batch-approve-timesheets/route.ts
└── update-territory-assignments/route.ts
```

### Pattern 1: Server Component with Client Data Table
**What:** Server Component fetches initial data, passes to Client Component for interactivity
**When to use:** All admin pages (consistent with Phase 4 reports pattern)
**Example:**
```typescript
// Source: Existing codebase - web/app/(dashboard)/reports/page.tsx
// web/app/(dashboard)/admin/bookings/page.tsx
import { createClient } from '@/lib/supabase/server';
import { fetchPendingBookings } from '@/lib/queries/admin/bookings';
import { BookingApprovalTable } from '@/components/admin/booking-approval-table';

export const dynamic = 'force-dynamic';

export default async function BookingsPage() {
  const supabase = await createClient();
  const initialBookings = await fetchPendingBookings(supabase);

  return (
    <div className="space-y-6">
      <div>
        <h1 className="text-3xl font-bold tracking-tight">Bookings</h1>
        <p className="text-muted-foreground">
          Approve, reject, or reassign medic bookings
        </p>
      </div>
      <BookingApprovalTable initialData={initialBookings} />
    </div>
  );
}
```

### Pattern 2: Row Selection with Bulk Actions Toolbar
**What:** TanStack Table row selection with floating action toolbar
**When to use:** Any table with bulk operations (bookings, timesheets, clients)
**Example:**
```typescript
// Source: https://ui.shadcn.com/docs/components/radix/data-table (verified official docs)
'use client';

import { useState } from 'react';
import { useReactTable, getCoreRowModel } from '@tanstack/react-table';
import { Button } from '@/components/ui/button';
import { Checkbox } from '@/components/ui/checkbox';

// Column definition with checkbox
const columns = [
  {
    id: "select",
    header: ({ table }) => (
      <Checkbox
        checked={
          table.getIsAllPageRowsSelected() ||
          (table.getIsSomePageRowsSelected() && "indeterminate")
        }
        onCheckedChange={(value) => table.toggleAllPageRowsSelected(!!value)}
        aria-label="Select all"
      />
    ),
    cell: ({ row }) => (
      <Checkbox
        checked={row.getIsSelected()}
        onCheckedChange={(value) => row.toggleSelected(!!value)}
        aria-label="Select row"
      />
    ),
  },
  // ... other columns
];

export function TimesheetBatchApproval({ initialData }) {
  const [rowSelection, setRowSelection] = useState({});

  const table = useReactTable({
    data: initialData,
    columns,
    onRowSelectionChange: setRowSelection,
    state: { rowSelection },
    getCoreRowModel: getCoreRowModel(),
  });

  const selectedCount = table.getFilteredSelectedRowModel().rows.length;

  return (
    <>
      {selectedCount > 0 && (
        <div className="flex items-center gap-2 p-4 bg-muted">
          <span>{selectedCount} selected</span>
          <Button onClick={handleBatchApprove}>Approve All</Button>
          <Button variant="destructive" onClick={handleBatchReject}>Reject All</Button>
        </div>
      )}
      {/* Table rendering */}
    </>
  );
}
```

### Pattern 3: Optimistic Updates for Approval Workflows
**What:** Instantly update UI before server confirms, rollback on error
**When to use:** Booking approval, timesheet approval, client upgrades
**Example:**
```typescript
// Source: https://tanstack.com/query/latest/docs/framework/react/guides/optimistic-updates (verified)
import { useMutation, useQueryClient } from '@tanstack/react-query';

export function useApproveBookings() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (bookingIds: string[]) => approveBookings(bookingIds),

    // Optimistically update UI before server responds
    onMutate: async (bookingIds) => {
      await queryClient.cancelQueries({ queryKey: ['bookings'] });

      const previousBookings = queryClient.getQueryData(['bookings']);

      queryClient.setQueryData(['bookings'], (old) =>
        old.map(b => bookingIds.includes(b.id)
          ? { ...b, status: 'confirmed' }
          : b
        )
      );

      return { previousBookings };
    },

    // Rollback on error
    onError: (err, bookingIds, context) => {
      queryClient.setQueryData(['bookings'], context.previousBookings);
      toast.error('Failed to approve bookings');
    },

    // Refetch after mutation settles
    onSettled: () => {
      queryClient.invalidateQueries({ queryKey: ['bookings'] });
    },
  });
}
```

### Pattern 4: Batch Operations via PostgreSQL Bulk Upsert
**What:** Single database query for multiple row updates (avoid N+1 queries)
**When to use:** Timesheet batch approval, bulk territory reassignments
**Example:**
```typescript
// Source: https://supaexplorer.com/best-practices/supabase-postgres/data-batch-inserts/
// Batch approve timesheets - Server Action
export async function batchApproveTimesheets(timesheetIds: string[], adminId: string) {
  const supabase = await createClient();

  // Batch update using PostgreSQL upsert (500-1000 rows optimal)
  const updates = timesheetIds.map(id => ({
    id,
    payout_status: 'admin_approved',
    admin_approved_at: new Date().toISOString(),
    admin_approved_by: adminId,
  }));

  // Single query for all updates
  const { data, error } = await supabase
    .from('timesheets')
    .upsert(updates, { onConflict: 'id' });

  if (error) throw error;
  return data;
}
```

### Pattern 5: Territory Map with Color-Coded Utilization
**What:** React Leaflet map with polygons colored by utilization thresholds
**When to use:** Territory coverage page
**Example:**
```typescript
// Source: https://github.com/OpenGov/react-leaflet-heatmap-layer (community pattern)
import { MapContainer, TileLayer, Polygon, Popup } from 'react-leaflet';

export function TerritoryMap({ territories }) {
  const getUtilizationColor = (utilization: number) => {
    if (utilization < 50) return '#22c55e'; // green
    if (utilization < 80) return '#eab308'; // yellow
    return '#ef4444'; // red
  };

  return (
    <MapContainer center={[51.505, -0.09]} zoom={6}>
      <TileLayer url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png" />
      {territories.map(territory => (
        <Polygon
          key={territory.id}
          positions={territory.boundary}
          pathOptions={{
            fillColor: getUtilizationColor(territory.utilization),
            fillOpacity: 0.6,
            color: '#000',
            weight: 1,
          }}
        >
          <Popup>
            <div>
              <h3>{territory.postcode_sector}</h3>
              <p>Utilization: {territory.utilization}%</p>
              <p>Primary: {territory.primary_medic_name}</p>
            </div>
          </Popup>
        </Polygon>
      ))}
    </MapContainer>
  );
}
```

### Pattern 6: Revenue Dashboard with Recharts
**What:** Line charts for cash flow trends, bar charts for territory comparison
**When to use:** Revenue dashboard page
**Example:**
```typescript
// Source: Recharts official patterns (React-specific charting library)
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from 'recharts';

export function CashFlowChart({ data }) {
  return (
    <ResponsiveContainer width="100%" height={400}>
      <LineChart data={data}>
        <CartesianGrid strokeDasharray="3 3" />
        <XAxis dataKey="week" />
        <YAxis />
        <Tooltip />
        <Legend />
        <Line
          type="monotone"
          dataKey="revenue"
          stroke="#22c55e"
          name="Revenue Collected"
        />
        <Line
          type="monotone"
          dataKey="payouts"
          stroke="#ef4444"
          name="Medic Payouts"
        />
        <Line
          type="monotone"
          dataKey="gap"
          stroke="#eab308"
          name="Cash Flow Gap"
          strokeDasharray="5 5"
        />
      </LineChart>
    </ResponsiveContainer>
  );
}
```

### Pattern 7: Alert Banners for Admin Warnings
**What:** Dismissible banners for coverage gaps, cash flow warnings
**When to use:** Admin overview page, territory page, revenue page
**Example:**
```typescript
// Source: Standard shadcn/ui Alert component pattern
import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';
import { AlertTriangle } from 'lucide-react';

export function AdminAlertBanner({ alerts }) {
  return (
    <div className="space-y-4">
      {alerts.map(alert => (
        <Alert key={alert.id} variant={alert.severity}>
          <AlertTriangle className="h-4 w-4" />
          <AlertTitle>{alert.title}</AlertTitle>
          <AlertDescription>{alert.message}</AlertDescription>
        </Alert>
      ))}
    </div>
  );
}

// Usage on admin overview:
// - Coverage gap alert when rejection rate >10%
// - Cash flow warning when gap >30 days
// - Pending approval counts
```

### Pattern 8: Debounced Search for Performance
**What:** Delay search API calls until user stops typing (300-500ms)
**When to use:** All admin tables with search (bookings, medics, clients)
**Example:**
```typescript
// Source: Standard React debounce pattern
import { useState, useEffect } from 'react';
import { Input } from '@/components/ui/input';

export function DebouncedSearch({ onSearch }) {
  const [searchTerm, setSearchTerm] = useState('');

  useEffect(() => {
    const timer = setTimeout(() => {
      onSearch(searchTerm);
    }, 300); // 300ms debounce

    return () => clearTimeout(timer);
  }, [searchTerm, onSearch]);

  return (
    <Input
      placeholder="Search bookings..."
      value={searchTerm}
      onChange={(e) => setSearchTerm(e.target.value)}
    />
  );
}
```

### Anti-Patterns to Avoid
- **Individual API calls in loops:** Don't approve timesheets one-by-one (N+1 queries). Use batch upsert.
- **No optimistic updates:** Don't wait for server response to update UI. Users expect instant feedback.
- **Missing confirmation dialogs:** Don't allow destructive bulk actions without confirmation.
- **No undo mechanism:** After bulk actions, provide 5-10 second undo window via toast notification.
- **Client-side only state:** Don't store row selection only in browser. Lost on refresh. Use URL params for filters.

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Data table with sorting/filtering | Custom table component | TanStack Table + shadcn/ui DataTable | Already in codebase, handles edge cases (pagination, column visibility, global filters) |
| Row selection state | Manual checkbox state | TanStack Table row selection API | Handles select-all, indeterminate states, pagination-aware selection |
| Chart components | Custom SVG/Canvas charts | Recharts (already installed) | Responsive, accessible, handles data edge cases (empty states, tooltips) |
| Map rendering | Custom Leaflet integration | React Leaflet (already installed) | Handles React lifecycle, memory leaks, tile loading |
| Optimistic updates | Manual cache mutations | TanStack Query onMutate | Handles rollback, concurrent mutations, cache invalidation |
| Batch database updates | Multiple UPDATE queries | PostgreSQL bulk upsert via Supabase | 10-100x faster, single transaction, atomic |
| Date range filtering | Custom date logic | date-fns (already installed) | Handles timezones, edge cases, week calculations |
| Debouncing | Manual setTimeout cleanup | useEffect with cleanup | Prevents memory leaks, handles rapid state changes |

**Key insight:** Admin dashboards have complex state management (row selection, filters, optimistic updates) that is error-prone to build from scratch. TanStack Table + TanStack Query provide battle-tested solutions for these problems.

## Common Pitfalls

### Pitfall 1: N+1 Query Problem in Batch Operations
**What goes wrong:** Approving 20 timesheets with 20 individual UPDATE queries takes 5-10 seconds (fails <5 min requirement)
**Why it happens:** Developers default to looping through selected IDs and calling API for each
**How to avoid:** Use PostgreSQL bulk upsert with 500-1000 row batches
**Warning signs:** Server logs show dozens of identical queries with different IDs
**Performance target:** 20 timesheets in <5 seconds with single bulk upsert

### Pitfall 2: Missing Optimistic Updates in Approval Workflows
**What goes wrong:** UI freezes waiting for server response, feels sluggish
**Why it happens:** Developers wait for mutation success before updating UI
**How to avoid:** Use TanStack Query onMutate to update cache immediately, rollback on error
**Warning signs:** Users click approve button and see no feedback for 1-2 seconds

### Pitfall 3: Row Selection Lost on Pagination
**What goes wrong:** User selects items on page 1, navigates to page 2, selections cleared
**Why it happens:** Row selection state not preserved across pagination
**How to avoid:** TanStack Table tracks selections by row ID (not index), persists across pages
**Warning signs:** Users complain "I selected 20 items but only 10 got approved"

### Pitfall 4: Unbounded Search Queries Overload Database
**What goes wrong:** User types in search box, 10+ queries fire to database
**Why it happens:** No debouncing on search input
**How to avoid:** 300-500ms debounce on search input before triggering query
**Warning signs:** Database query logs show rapid-fire identical searches with slight text differences

### Pitfall 5: Color-Coded Maps Without Accessibility
**What goes wrong:** Color-blind users can't distinguish green/yellow/red territories
**Why it happens:** Relying solely on color to convey utilization information
**How to avoid:** Add text labels, patterns, or icons alongside colors
**Warning signs:** Accessibility audit flags color contrast issues

### Pitfall 6: Cash Flow Projections Without Null Handling
**What goes wrong:** Dashboard crashes when no payments recorded for a period
**Why it happens:** Chart components don't handle empty data arrays
**How to avoid:** Recharts handles empty states gracefully, add fallback UI for no-data
**Warning signs:** Console errors "Cannot read property 'map' of undefined"

### Pitfall 7: Bulk Operations Without Confirmation
**What goes wrong:** Admin accidentally approves/rejects wrong items
**Why it happens:** No confirmation dialog for destructive actions
**How to avoid:** Show confirmation modal with item count and action summary
**Warning signs:** Support tickets "I accidentally rejected 50 timesheets"

### Pitfall 8: Server Actions Called Sequentially Instead of in Parallel
**What goes wrong:** Batch approval of 20 items takes 20x longer than necessary
**Why it happens:** Awaiting each Server Action call in a loop
**How to avoid:** Use Promise.all() for independent operations, or single bulk Server Action
**Warning signs:** Network tab shows sequential requests instead of parallel

### Pitfall 9: Missing Loading States During Batch Operations
**What goes wrong:** Users don't know if their bulk action is processing
**Why it happens:** No loading indicator for mutations
**How to avoid:** TanStack Query mutation provides isLoading state, show progress indicator
**Warning signs:** Users click approve button multiple times because no feedback

### Pitfall 10: Territory Map Overlays Obscure Interaction
**What goes wrong:** Can't click on polygons because another layer is on top
**Why it happens:** Z-index conflicts between map layers
**How to avoid:** Leaflet manages layer order, use pane system for explicit z-ordering
**Warning signs:** Popups don't open when clicking territories

## Code Examples

Verified patterns from official sources:

### Batch Timesheet Approval (Performance Target: 20 in <5 min)
```typescript
// Source: Next.js Server Actions + Supabase batch operations
// web/app/api/admin/batch-approve-timesheets/route.ts
'use server';

import { createClient } from '@/lib/supabase/server';
import { revalidatePath } from 'next/cache';

export async function batchApproveTimesheets(
  timesheetIds: string[],
  adminId: string
) {
  const supabase = await createClient();

  // Validate batch size (optimal: 500-1000 rows)
  if (timesheetIds.length > 1000) {
    throw new Error('Batch size too large. Approve in chunks of 1000.');
  }

  // Single bulk upsert (10-100x faster than individual UPDATEs)
  const updates = timesheetIds.map(id => ({
    id,
    payout_status: 'admin_approved',
    admin_approved_at: new Date().toISOString(),
    admin_approved_by: adminId,
  }));

  const { data, error } = await supabase
    .from('timesheets')
    .upsert(updates, { onConflict: 'id' });

  if (error) throw error;

  revalidatePath('/admin/timesheets');
  return { success: true, count: timesheetIds.length };
}
```

### Confirmation Dialog for Destructive Actions
```typescript
// Source: shadcn/ui Dialog + AlertDialog pattern
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from '@/components/ui/alert-dialog';

export function BulkActionConfirmation({
  open,
  onOpenChange,
  selectedCount,
  action,
  onConfirm
}) {
  return (
    <AlertDialog open={open} onOpenChange={onOpenChange}>
      <AlertDialogContent>
        <AlertDialogHeader>
          <AlertDialogTitle>
            {action === 'approve' ? 'Approve' : 'Reject'} {selectedCount} timesheets?
          </AlertDialogTitle>
          <AlertDialogDescription>
            This will {action} {selectedCount} timesheet(s).
            {action === 'reject' && ' This action cannot be undone.'}
          </AlertDialogDescription>
        </AlertDialogHeader>
        <AlertDialogFooter>
          <AlertDialogCancel>Cancel</AlertDialogCancel>
          <AlertDialogAction onClick={onConfirm}>
            Confirm {action === 'approve' ? 'Approval' : 'Rejection'}
          </AlertDialogAction>
        </AlertDialogFooter>
      </AlertDialogContent>
    </AlertDialog>
  );
}
```

### Sidebar Navigation Extension for Admin Pages
```typescript
// Source: Existing codebase - web/app/(dashboard)/layout.tsx (extend navigation array)
// Add to existing navigation array:
const navigation = [
  // ... existing items (Overview, Treatments, Near-Misses, Workers, Reports)
  {
    name: 'Admin',
    href: '/admin',
    icon: Shield, // lucide-react icon
    children: [
      { name: 'Overview', href: '/admin', icon: LayoutDashboard },
      { name: 'Bookings', href: '/admin/bookings', icon: Calendar },
      { name: 'Medics', href: '/admin/medics', icon: Users },
      { name: 'Territories', href: '/admin/territories', icon: Map },
      { name: 'Revenue', href: '/admin/revenue', icon: DollarSign },
      { name: 'Timesheets', href: '/admin/timesheets', icon: Clock },
      { name: 'Clients', href: '/admin/clients', icon: Building },
    ],
  },
];
```

### Coverage Gap Alert Calculation
```typescript
// Source: Business logic derived from Phase 5.5 requirements
export function calculateCoverageGaps(territories: Territory[]) {
  return territories
    .filter(t => {
      // Alert when rejection rate >10%
      const rejectionRate = t.rejected_bookings / t.total_bookings;
      return rejectionRate > 0.10;
    })
    .map(t => ({
      id: t.id,
      postcode_sector: t.postcode_sector,
      rejectionRate: (t.rejected_bookings / t.total_bookings * 100).toFixed(1),
      severity: 'warning' as const,
      title: `Coverage Gap in ${t.postcode_sector}`,
      message: `${t.rejected_bookings} of ${t.total_bookings} bookings rejected (${(t.rejected_bookings / t.total_bookings * 100).toFixed(1)}%). Consider assigning additional medics.`,
    }));
}
```

### Cash Flow Gap Warning
```typescript
// Source: Business logic derived from Phase 5.5 requirements
export function calculateCashFlowGap(revenue: RevenueData) {
  // Warn when paying medics >30 days before collecting from clients
  const daysToCollect = revenue.avg_collection_days; // Net 30 clients average
  const daysToPayMedics = 7; // Friday payouts (weekly)
  const gap = daysToCollect - daysToPayMedics;

  if (gap > 30) {
    return {
      severity: 'destructive' as const,
      title: 'Cash Flow Warning',
      message: `Platform is paying medics ${daysToPayMedics} days after shift, but collecting from clients in ${daysToCollect} days (${gap}-day gap). Consider requiring prepayment for high-volume clients.`,
    };
  }

  return null;
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Route Handlers for mutations | Server Actions | Next.js 13+ (2023) | Simpler API, automatic revalidation, type-safe |
| Custom table state management | TanStack Table v8 | 2022 | Headless UI, better TypeScript, row selection built-in |
| react-query v3 | TanStack Query v5 | 2023 | Improved optimistic updates, better DevTools |
| Chart.js with react-chartjs-2 | Recharts | Recharts more React-native (2020+) | Better React integration, composable components |
| Individual SQL UPDATE queries | PostgreSQL bulk upsert | Always best practice | 10-100x performance improvement |
| Manual optimistic updates | TanStack Query onMutate | v3+ (2021) | Automatic rollback, less boilerplate |
| setTimeout debouncing | useEffect with cleanup | React best practice | Prevents memory leaks |

**Deprecated/outdated:**
- **react-admin framework**: Heavy, opinionated. Modern approach is composable components (shadcn/ui + TanStack)
- **Redux for server state**: TanStack Query is standard for server state (Redux for client state only)
- **Class components**: Functional components with hooks are standard (React 16.8+, 2019)
- **Client-side only data tables**: Next.js 15 pattern is Server Component initial load + Client Component interactivity

## Open Questions

Things that couldn't be fully resolved:

1. **Territory boundary polygon data source**
   - What we know: React Leaflet can render polygons with color coding
   - What's unclear: Where to get UK postcode sector boundary coordinates (GeoJSON)
   - Recommendation: Use OS Data Hub (Ordnance Survey) Open Data for UK postcode boundaries, or approximate with circle radius based on postcode centroid + max_travel_minutes

2. **Real-time updates for admin dashboard**
   - What we know: TanStack Query polling (60s interval like Phase 5 reports) is working pattern
   - What's unclear: Whether admin needs real-time (<1s) updates or polling is sufficient
   - Recommendation: Start with 60s polling (consistent with Phase 5), upgrade to Supabase Realtime if admins request real-time

3. **Admin role-based access control (RBAC)**
   - What we know: Supabase RLS exists (Phase 1.5), sidebar navigation can be conditionally rendered
   - What's unclear: Whether Phase 5.5 includes RBAC implementation or assumes all users are admins
   - Recommendation: Phase 5.5 scope is admin features only. Defer RBAC to future phase. Check user role in layout, redirect non-admins to /dashboard

4. **Undo mechanism implementation**
   - What we know: Best practice is 5-10 second undo window via toast notification
   - What's unclear: Whether undo requires database soft-delete or can be immediate rollback
   - Recommendation: Use optimistic updates for instant undo (no server call). Only commit to database after undo window expires (10s delay on mutation)

5. **Medic availability calendar UI pattern**
   - What we know: Need to display weekly availability for medics
   - What's unclear: Whether to build custom calendar or use library
   - Recommendation: Use @dnd-kit (already installed) for drag-and-drop availability blocks, or simple table with day columns if calendar complexity not needed

## Sources

### Primary (HIGH confidence)
- [TanStack Table v8 Row Selection Guide](https://tanstack.com/table/v8/docs/guide/row-selection) - Row selection API
- [TanStack Query Optimistic Updates Guide](https://tanstack.com/query/latest/docs/framework/react/guides/optimistic-updates) - onMutate pattern
- [shadcn/ui Data Table Documentation](https://ui.shadcn.com/docs/components/radix/data-table) - Row selection implementation
- [Supabase Batch INSERT Best Practices](https://supaexplorer.com/best-practices/supabase-postgres/data-batch-inserts/) - PostgreSQL bulk operations
- Existing codebase (Phase 4 + Phase 5) - Established patterns for dashboard layout, data tables, TanStack Query

### Secondary (MEDIUM confidence)
- [Modern Full Stack Application Architecture Using Next.js 15+](https://softwaremill.com/modern-full-stack-application-architecture-using-next-js-15/) - Next.js 15 architecture patterns
- [Next.js Server Actions Performance Issues and Solutions](https://pasquale-favella.github.io/blog/27) - Batch operations performance
- [Cash Flow Tracking Dashboard for CFO](https://www.highradius.com/resources/Blog/cash-flow-tracking-dashboard/) - Revenue dashboard patterns
- [Bulk action UX: 8 design guidelines with examples](https://www.eleken.co/blog-posts/bulk-actions-ux) - Confirmation and undo patterns
- [React Admin Dashboard: Best Templates & Frameworks (2026 Guide)](https://refine.dev/blog/how-to-create-react-admin-dashboard/) - Admin dashboard architecture

### Tertiary (LOW confidence - requires validation)
- [Recharts vs Chart.js comparison (2026)](https://www.syncfusion.com/blogs/post/top-5-react-chart-libraries) - Library comparison (needs testing with SiteMedic data volumes)
- [React Leaflet heatmap layer](https://github.com/OpenGov/react-leaflet-heatmap-layer) - Community package (not yet verified with territory use case)

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - All libraries already installed and used in Phase 4/5
- Architecture patterns: HIGH - Verified with official documentation and existing codebase
- Bulk operations: HIGH - PostgreSQL best practices well-documented
- Performance (<5 min target): MEDIUM - Batch upsert performance validated by sources, but needs load testing with actual 20-timesheet scenario
- Territory maps: MEDIUM - React Leaflet verified, but UK postcode boundary data source needs validation
- Pitfalls: HIGH - Based on common React/Next.js/PostgreSQL pitfalls and verified patterns

**Research date:** 2026-02-16
**Valid until:** 2026-04-16 (60 days - stable Next.js/React ecosystem, Recharts/Leaflet mature libraries)
