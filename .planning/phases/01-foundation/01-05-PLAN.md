---
phase: 01-foundation
plan: 05
type: execute
wave: 3
depends_on: ["01-03", "01-04"]
files_modified:
  - src/services/SyncQueue.ts
  - src/services/NetworkMonitor.ts
  - src/components/SyncStatusIndicator.tsx
  - src/components/OfflineBanner.tsx
  - src/contexts/SyncContext.tsx
  - App.tsx
autonomous: false

must_haves:
  truths:
    - "Sync queue persists pending operations in WatermelonDB (survives force-quit)"
    - "Sync queue uses exponential backoff for retries (5min -> 15min -> 1hr -> 4hr max)"
    - "RIDDOR-reportable items get priority 0 (synced first)"
    - "Network monitor detects online/offline transitions in real time"
    - "Coming back online triggers sync queue processing automatically"
    - "Sync status indicator shows color-coded state (green=synced, yellow=syncing, red=offline, orange=pending)"
    - "Pending item count badge displays on sync indicator"
    - "Offline banner appears when device loses connectivity"
  artifacts:
    - path: "src/services/SyncQueue.ts"
      provides: "Persistent sync queue with exponential backoff and priority"
      exports: ["SyncQueue", "syncQueue"]
    - path: "src/services/NetworkMonitor.ts"
      provides: "Real-time connectivity detection and sync triggering"
      exports: ["NetworkMonitor", "networkMonitor"]
    - path: "src/components/SyncStatusIndicator.tsx"
      provides: "Visual sync status with color and pending count badge"
      exports: ["SyncStatusIndicator"]
    - path: "src/components/OfflineBanner.tsx"
      provides: "Banner shown when device is offline"
      exports: ["OfflineBanner"]
    - path: "src/contexts/SyncContext.tsx"
      provides: "React Context for sync state across components"
      exports: ["SyncProvider", "useSync"]
  key_links:
    - from: "src/services/SyncQueue.ts"
      to: "src/database/models/SyncQueueItem.ts"
      via: "Persists queue items in WatermelonDB sync_queue table"
      pattern: "collections\\.get\\('sync_queue'\\)"
    - from: "src/services/NetworkMonitor.ts"
      to: "src/services/SyncQueue.ts"
      via: "Triggers processPendingItems when connectivity restored"
      pattern: "syncQueue\\.processPendingItems"
    - from: "src/components/SyncStatusIndicator.tsx"
      to: "src/contexts/SyncContext.tsx"
      via: "Reads sync state from context"
      pattern: "useSync"
    - from: "src/services/NetworkMonitor.ts"
      to: "@react-native-community/netinfo"
      via: "NetInfo.addEventListener for real-time connectivity"
      pattern: "NetInfo\\.addEventListener"
---

<objective>
Build the sync infrastructure (persistent queue with exponential backoff) and network monitoring with user-visible sync status indicators.

Purpose: The sync queue is the bridge between offline-first local data and the Supabase backend. It must survive app force-quits (Pitfall 6 from research), prioritize RIDDOR-reportable incidents, and retry with backoff to avoid battery drain. The sync status UI gives medics confidence that their clinical records will eventually reach the server -- critical for trust in an offline-first medical app.
Output: Working sync queue, network monitor, and visual status indicators integrated into the app.
</objective>

<execution_context>
@/Users/sabineresoagli/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sabineresoagli/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-03-SUMMARY.md
@.planning/phases/01-foundation/01-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement persistent SyncQueue and NetworkMonitor services</name>
  <files>
    src/services/SyncQueue.ts
    src/services/NetworkMonitor.ts
  </files>
  <action>
    **src/services/SyncQueue.ts:**
    Create SyncQueue class (following Research Pattern 5):

    Properties:
    - `private isProcessing: boolean = false`
    - `private database` reference (from getDatabase())

    `enqueue(operation, tableName, recordId, payload, priority = 1)` method:
    1. Write to WatermelonDB sync_queue table via `database.write()`:
       - Set operation, tableName, recordId, payload (JSON.stringify), priority
       - Set retryCount = 0, nextRetryAt = Date.now(), createdAt = Date.now()
    2. After enqueue, check connectivity via NetInfo.fetch()
    3. If online, call `this.processPendingItems()`

    `processPendingItems()` method:
    1. Guard: if `this.isProcessing` return (prevent concurrent processing)
    2. Set `this.isProcessing = true`
    3. Query sync_queue: `Q.where('next_retry_at', Q.lte(Date.now()))`, sorted by priority ASC (RIDDOR first = 0), then created_at ASC
    4. For each item:
       a. Try `this.syncItem(item)`
       b. On success: `item.destroyPermanently()` (remove from queue)
       c. On failure: `this.scheduleRetry(item)`
    5. Finally: set `this.isProcessing = false`
    6. Return count of items processed and failed

    `getPendingCount()` method:
    1. Query sync_queue count
    2. Return number of pending items

    `getPendingItems()` method:
    1. Query all sync_queue items sorted by priority, created_at
    2. Return array for UI display

    Private `scheduleRetry(item)`:
    1. Increment retryCount
    2. Calculate backoff: `Math.min(5 * Math.pow(2, retryCount), 240)` minutes (caps at 4 hours)
    3. Set nextRetryAt = Date.now() + backoffMinutes * 60 * 1000
    4. Update item in database

    Private `syncItem(item)`:
    1. Parse payload from JSON
    2. Switch on operation:
       - 'create': `supabase.from(tableName).insert(payload)`
       - 'update': `supabase.from(tableName).update(payload).eq('id', payload.id)`
       - 'delete': `supabase.from(tableName).delete().eq('id', payload.id)`
    3. Check for Supabase error and throw if present
    4. On success for 'create': update the local WatermelonDB record's `server_id` with the returned UUID

    Export singleton: `export const syncQueue = new SyncQueue()`

    IMPORTANT:
    - Queue is persisted in WatermelonDB SQLite -- survives force-quit (Pitfall 6 mitigation)
    - Priority 0 = RIDDOR-reportable (immediate sync), Priority 1 = normal
    - Exponential backoff prevents battery drain during extended offline periods

    **src/services/NetworkMonitor.ts:**
    Create NetworkMonitor class (following Research network-aware pattern):

    Properties:
    - `private unsubscribe: (() => void) | null = null`
    - `private listeners: Set<(isOnline: boolean) => void> = new Set()`
    - `public isOnline: boolean = true`
    - `public connectionType: string = 'unknown'`

    `startMonitoring()` method:
    1. Configure NetInfo reachability:
       ```
       NetInfo.configure({
         reachabilityUrl: process.env.EXPO_PUBLIC_SUPABASE_URL + '/rest/v1/',
         reachabilityTest: async (response) => response.status === 200,
         reachabilityShortTimeout: 5 * 1000,
         reachabilityLongTimeout: 60 * 1000,
       })
       ```
    2. Subscribe: `this.unsubscribe = NetInfo.addEventListener(state => { ... })`
    3. On state change:
       - Update `this.isOnline` and `this.connectionType`
       - If transitioning to online: call `this.onConnected()`
       - If transitioning to offline: call `this.onDisconnected()`
       - Notify all listeners

    `stopMonitoring()`: Unsubscribe from NetInfo

    `addListener(callback)`: Add to listeners set, return unsubscribe function

    Private `onConnected()`:
    1. Log "Network connected -- triggering sync"
    2. Call `syncQueue.processPendingItems()`

    Private `onDisconnected()`:
    1. Log "Network disconnected -- entering offline mode"

    `getConnectionInfo()`: Returns `{ isOnline, connectionType, isWifi: connectionType === 'wifi' }`

    Export singleton: `export const networkMonitor = new NetworkMonitor()`

    IMPORTANT:
    - WiFi detection matters for Phase 3 (photos sync WiFi-only), so track connectionType now
    - Reachability test pings Supabase URL to confirm actual internet access (not just connected to WiFi)
  </action>
  <verify>
    Run `npx tsc --noEmit` to verify compilation. Verify SyncQueue writes to WatermelonDB sync_queue table (not in-memory). Verify exponential backoff caps at 240 minutes. Verify NetworkMonitor triggers sync on connectivity restoration. Verify RIDDOR priority (0) sorts before normal priority (1).
  </verify>
  <done>
    SyncQueue persists operations in WatermelonDB with exponential backoff (5min to 4hr cap) and RIDDOR priority. NetworkMonitor detects connectivity changes in real time and triggers sync when coming back online. Both services exported as singletons.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create sync status UI components and SyncContext</name>
  <files>
    src/contexts/SyncContext.tsx
    src/components/SyncStatusIndicator.tsx
    src/components/OfflineBanner.tsx
    App.tsx
  </files>
  <action>
    **src/contexts/SyncContext.tsx:**
    Create React Context for sync state:

    Define `SyncState` type:
    ```typescript
    type SyncStatus = 'synced' | 'syncing' | 'pending' | 'offline' | 'error'

    interface SyncState {
      status: SyncStatus
      pendingCount: number
      isOnline: boolean
      connectionType: string
      lastSyncAt: Date | null
      lastError: string | null
    }
    ```

    Define `SyncContextType`:
    ```typescript
    interface SyncContextType {
      state: SyncState
      triggerSync: () => Promise<void>
      enqueueSyncItem: (operation: string, tableName: string, recordId: string, payload: any, priority?: number) => Promise<void>
    }
    ```

    Create `SyncProvider` component:
    1. Initialize state with default values (status: 'synced', pendingCount: 0, etc.)
    2. On mount:
       - Start networkMonitor
       - Add listener to networkMonitor for online/offline changes
       - Poll pending count every 10 seconds (or use WatermelonDB observable)
    3. Update status logic:
       - If !isOnline -> 'offline'
       - If isProcessing -> 'syncing'
       - If pendingCount > 0 -> 'pending'
       - If lastError -> 'error'
       - Otherwise -> 'synced'
    4. `triggerSync`: call syncQueue.processPendingItems(), update state
    5. `enqueueSyncItem`: call syncQueue.enqueue(), update pendingCount
    6. Cleanup: stop networkMonitor on unmount

    Export `SyncProvider` and `useSync` hook.

    **src/components/SyncStatusIndicator.tsx:**
    Create visual indicator component using `useSync()`:

    Color mapping:
    - synced: green (#22C55E)
    - syncing: blue (#3B82F6) with pulse animation
    - pending: orange (#F59E0B)
    - offline: red (#EF4444)
    - error: red (#EF4444) with exclamation icon

    Render:
    - Circular dot (12px) with status color
    - Label text: "Synced", "Syncing...", "X pending", "Offline", "Sync error"
    - If pendingCount > 0: show count badge (small red circle with number)
    - OnPress: if pending or error, trigger manual sync retry

    Use React Native `Animated` for pulse animation on 'syncing' status.

    Style with StyleSheet (not Tailwind -- React Native):
    - 48x48pt minimum touch target (gloves-on usability requirement)
    - High contrast colors for bright sunlight readability

    **src/components/OfflineBanner.tsx:**
    Create banner component using `useSync()`:
    - Only renders when `state.isOnline === false`
    - Yellow/amber background (#FEF3C7)
    - Text: "You're offline. Changes are saved locally and will sync when connected."
    - Fixed position at top of screen (below status bar)
    - Dismiss button (but re-shows if still offline after 30 seconds)

    **App.tsx:**
    Update the existing App.tsx to integrate providers:
    ```
    <AuthProvider>
      <SyncProvider>
        <OfflineBanner />
        <View style={styles.container}>
          <Text>SiteMedic</Text>
          <SyncStatusIndicator />
        </View>
      </SyncProvider>
    </AuthProvider>
    ```

    Also call `initDatabase()` on app launch (before rendering providers).

    IMPORTANT:
    - Initialize database BEFORE AuthProvider/SyncProvider mount
    - Use a loading screen while database initializes
    - SyncProvider must be inside AuthProvider (sync needs auth token)
  </action>
  <verify>
    Run `npx tsc --noEmit` to verify compilation. Run `npx expo start --ios` and verify:
    1. App launches with SiteMedic text and sync indicator (green dot = "Synced")
    2. Toggle airplane mode on simulator: offline banner appears, sync indicator turns red
    3. Toggle airplane mode off: offline banner disappears, sync indicator returns to green
    Verify SyncStatusIndicator has 48x48pt minimum touch target.
  </verify>
  <done>
    SyncContext provides sync state to all components. SyncStatusIndicator shows color-coded status with pending count badge. OfflineBanner appears when offline. App.tsx integrates all providers (Auth + Sync) with database initialization on launch.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Complete Phase 1 foundation: Expo app with Supabase backend schema, WatermelonDB local database, authentication with offline persistence and biometrics, sync queue with network monitoring, and visual sync status indicators.
  </what-built>
  <how-to-verify>
    1. Open iOS Simulator and launch the app
    2. Verify app shows "SiteMedic" text with a green sync status indicator
    3. Toggle airplane mode ON in simulator (Device -> Toggle Airplane Mode or use Network Link Conditioner)
    4. Verify: Yellow "You're offline" banner appears, sync indicator turns red with "Offline" label
    5. Toggle airplane mode OFF
    6. Verify: Offline banner disappears, sync indicator returns to green
    7. Check terminal/console for any error messages during these transitions
    8. Verify the SQL migration files exist in supabase/migrations/ (6 files)
    9. Verify .env is NOT committed to git (run `git status`)
  </how-to-verify>
  <resume-signal>Type "approved" or describe any issues seen during verification</resume-signal>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- App launches on iOS simulator without crashes
- SyncQueue stores items in WatermelonDB (not in-memory)
- NetworkMonitor detects online/offline transitions
- SyncStatusIndicator shows 5 states with correct colors
- OfflineBanner appears/disappears based on connectivity
- Pending count badge shows number of unsynced items
- App.tsx integrates AuthProvider, SyncProvider, database init
- All providers initialize without errors
</verification>

<success_criteria>
- Sync queue persists across force-quit (ARCH-04)
- Background sync ready with WiFi detection for Phase 3 photo constraint (ARCH-05)
- Multi-modal sync status indicators work: color, labels, pending count badge (ARCH-06)
- Network connectivity detection triggers sync status updates (ARCH-07)
- Visual offline indicator visible to medic (UX requirement for construction sites)
- RIDDOR-reportable items get sync priority (compliance requirement)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-05-SUMMARY.md`
</output>
