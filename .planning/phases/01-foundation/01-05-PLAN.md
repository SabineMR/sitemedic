---
phase: 01-foundation
plan: 05
type: execute
wave: 3
depends_on: ["01-03", "01-04"]
files_modified:
  - src/services/SyncQueue.ts
  - src/services/NetworkMonitor.ts
  - src/services/AuditLogger.ts
  - src/components/SyncStatusIndicator.tsx
  - src/components/OfflineBanner.tsx
  - src/contexts/SyncContext.tsx
  - App.tsx
autonomous: false

must_haves:
  truths:
    - "Sync queue persists pending operations in WatermelonDB (survives force-quit)"
    - "Sync queue uses exponential backoff for retries (5min -> 15min -> 1hr -> 4hr max)"
    - "RIDDOR-reportable items get priority 0 (synced first)"
    - "Network monitor detects online/offline transitions in real time"
    - "Coming back online triggers sync queue processing automatically"
    - "Sync status indicator shows color-coded state (green=synced, yellow=syncing, red=offline, orange=pending)"
    - "Pending item count badge displays on sync indicator"
    - "Offline banner appears when device loses connectivity"
    - "Client-side audit logger records READ operations on sensitive tables (workers, treatments) to local audit_log"
    - "Audit log entries are enqueued to sync queue for push to Supabase audit_logs table"
  artifacts:
    - path: "src/services/SyncQueue.ts"
      provides: "Persistent sync queue with exponential backoff and priority"
      exports: ["SyncQueue", "syncQueue"]
    - path: "src/services/NetworkMonitor.ts"
      provides: "Real-time connectivity detection and sync triggering"
      exports: ["NetworkMonitor", "networkMonitor"]
    - path: "src/services/AuditLogger.ts"
      provides: "Client-side audit logging for GDPR-02 READ tracking"
      exports: ["AuditLogger", "auditLogger"]
    - path: "src/components/SyncStatusIndicator.tsx"
      provides: "Visual sync status with color and pending count badge"
      exports: ["SyncStatusIndicator"]
    - path: "src/components/OfflineBanner.tsx"
      provides: "Banner shown when device is offline"
      exports: ["OfflineBanner"]
    - path: "src/contexts/SyncContext.tsx"
      provides: "React Context for sync state across components"
      exports: ["SyncProvider", "useSync"]
  key_links:
    - from: "src/services/SyncQueue.ts"
      to: "src/database/models/SyncQueueItem.ts"
      via: "Persists queue items in WatermelonDB sync_queue table"
      pattern: "collections\\.get\\('sync_queue'\\)"
    - from: "src/services/NetworkMonitor.ts"
      to: "src/services/SyncQueue.ts"
      via: "Triggers processPendingItems when connectivity restored"
      pattern: "syncQueue\\.processPendingItems"
    - from: "src/services/AuditLogger.ts"
      to: "src/database/models/AuditLogEntry.ts"
      via: "Writes audit entries to local WatermelonDB audit_log table"
      pattern: "collections\\.get\\('audit_log'\\)"
    - from: "src/services/AuditLogger.ts"
      to: "src/services/SyncQueue.ts"
      via: "Enqueues unsynced audit entries to sync queue for Supabase push"
      pattern: "syncQueue\\.enqueue"
    - from: "src/components/SyncStatusIndicator.tsx"
      to: "src/contexts/SyncContext.tsx"
      via: "Reads sync state from context"
      pattern: "useSync"
    - from: "src/services/NetworkMonitor.ts"
      to: "@react-native-community/netinfo"
      via: "NetInfo.addEventListener for real-time connectivity"
      pattern: "NetInfo\\.addEventListener"
---

<objective>
Build the sync infrastructure (persistent queue with exponential backoff), client-side audit logging service, network monitoring, and user-visible sync status indicators.

Purpose: The sync queue is the bridge between offline-first local data and the Supabase backend. It must survive app force-quits (Pitfall 6 from research), prioritize RIDDOR-reportable incidents, and retry with backoff to avoid battery drain. The client-side audit logger fills the GDPR-02 gap: server-side PostgreSQL triggers (Plan 01-02) capture write operations, but READ operations on sensitive health data happen locally in WatermelonDB and cannot be captured server-side. The AuditLogger writes to the local audit_log table and enqueues entries for sync to Supabase. The sync status UI gives medics confidence that their clinical records will eventually reach the server -- critical for trust in an offline-first medical app.
Output: Working sync queue, audit logger, network monitor, and visual status indicators integrated into the app.
</objective>

<execution_context>
@/Users/sabineresoagli/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sabineresoagli/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-03-SUMMARY.md
@.planning/phases/01-foundation/01-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement persistent SyncQueue and NetworkMonitor services</name>
  <files>
    src/services/SyncQueue.ts
    src/services/NetworkMonitor.ts
  </files>
  <action>
    **src/services/SyncQueue.ts:**
    Create SyncQueue class (following Research Pattern 5):

    Properties:
    - `private isProcessing: boolean = false`
    - `private database` reference (from getDatabase())

    `enqueue(operation, tableName, recordId, payload, priority = 1)` method:
    1. Write to WatermelonDB sync_queue table via `database.write()`:
       - Set operation, tableName, recordId, payload (JSON.stringify), priority
       - Set retryCount = 0, nextRetryAt = Date.now(), createdAt = Date.now()
    2. After enqueue, check connectivity via NetInfo.fetch()
    3. If online, call `this.processPendingItems()`

    `processPendingItems()` method:
    1. Guard: if `this.isProcessing` return (prevent concurrent processing)
    2. Set `this.isProcessing = true`
    3. Query sync_queue: `Q.where('next_retry_at', Q.lte(Date.now()))`, sorted by priority ASC (RIDDOR first = 0), then created_at ASC
    4. For each item:
       a. Try `this.syncItem(item)`
       b. On success: `item.destroyPermanently()` (remove from queue)
       c. On failure: `this.scheduleRetry(item)`
    5. Finally: set `this.isProcessing = false`
    6. Return count of items processed and failed

    `getPendingCount()` method:
    1. Query sync_queue count
    2. Return number of pending items

    `getPendingItems()` method:
    1. Query all sync_queue items sorted by priority, created_at
    2. Return array for UI display

    Private `scheduleRetry(item)`:
    1. Increment retryCount
    2. Calculate backoff: `Math.min(5 * Math.pow(2, retryCount), 240)` minutes (caps at 4 hours)
    3. Set nextRetryAt = Date.now() + backoffMinutes * 60 * 1000
    4. Update item in database

    Private `syncItem(item)`:
    1. Parse payload from JSON
    2. Switch on operation:
       - 'create': `supabase.from(tableName).insert(payload)`
       - 'update': `supabase.from(tableName).update(payload).eq('id', payload.id)`
       - 'delete': `supabase.from(tableName).delete().eq('id', payload.id)`
    3. Check for Supabase error and throw if present
    4. On success for 'create': update the local WatermelonDB record's `server_id` with the returned UUID

    Export singleton: `export const syncQueue = new SyncQueue()`

    IMPORTANT:
    - Queue is persisted in WatermelonDB SQLite -- survives force-quit (Pitfall 6 mitigation)
    - Priority 0 = RIDDOR-reportable (immediate sync), Priority 1 = normal
    - Exponential backoff prevents battery drain during extended offline periods

    **src/services/NetworkMonitor.ts:**
    Create NetworkMonitor class (following Research network-aware pattern):

    Properties:
    - `private unsubscribe: (() => void) | null = null`
    - `private listeners: Set<(isOnline: boolean) => void> = new Set()`
    - `public isOnline: boolean = true`
    - `public connectionType: string = 'unknown'`

    `startMonitoring()` method:
    1. Configure NetInfo reachability:
       ```
       NetInfo.configure({
         reachabilityUrl: process.env.EXPO_PUBLIC_SUPABASE_URL + '/rest/v1/',
         reachabilityTest: async (response) => response.status === 200,
         reachabilityShortTimeout: 5 * 1000,
         reachabilityLongTimeout: 60 * 1000,
       })
       ```
    2. Subscribe: `this.unsubscribe = NetInfo.addEventListener(state => { ... })`
    3. On state change:
       - Update `this.isOnline` and `this.connectionType`
       - If transitioning to online: call `this.onConnected()`
       - If transitioning to offline: call `this.onDisconnected()`
       - Notify all listeners

    `stopMonitoring()`: Unsubscribe from NetInfo

    `addListener(callback)`: Add to listeners set, return unsubscribe function

    Private `onConnected()`:
    1. Log "Network connected -- triggering sync"
    2. Call `syncQueue.processPendingItems()`

    Private `onDisconnected()`:
    1. Log "Network disconnected -- entering offline mode"

    `getConnectionInfo()`: Returns `{ isOnline, connectionType, isWifi: connectionType === 'wifi' }`

    Export singleton: `export const networkMonitor = new NetworkMonitor()`

    IMPORTANT:
    - WiFi detection matters for Phase 3 (photos sync WiFi-only), so track connectionType now
    - Reachability test pings Supabase URL to confirm actual internet access (not just connected to WiFi)
  </action>
  <verify>
    Run `npx tsc --noEmit` to verify compilation. Verify SyncQueue writes to WatermelonDB sync_queue table (not in-memory). Verify exponential backoff caps at 240 minutes. Verify NetworkMonitor triggers sync on connectivity restoration. Verify RIDDOR priority (0) sorts before normal priority (1).
  </verify>
  <done>
    SyncQueue persists operations in WatermelonDB with exponential backoff (5min to 4hr cap) and RIDDOR priority. NetworkMonitor detects connectivity changes in real time and triggers sync when coming back online. Both services exported as singletons.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement client-side AuditLogger service for GDPR-02 compliance</name>
  <files>
    src/services/AuditLogger.ts
  </files>
  <action>
    **src/services/AuditLogger.ts:**
    Create AuditLogger class that records all data access to the local WatermelonDB `audit_log` table and enqueues unsynced entries for push to Supabase.

    This service fills a critical GDPR-02 gap: server-side PostgreSQL triggers (from Plan 01-02) capture INSERT/UPDATE/DELETE on Supabase tables, but READ operations on sensitive health data happen locally in WatermelonDB and are invisible to the server. The AuditLogger captures these client-side reads.

    Properties:
    - `private database` reference (from getDatabase())
    - `private currentUserId: string | null = null`

    `setCurrentUser(userId: string | null)` method:
    - Sets the current authenticated user ID (called from AuthProvider on login/logout)
    - When userId is null (logged out), subsequent logAccess calls are no-ops

    `logAccess(tableName: string, recordId: string, operation: string, context?: string)` async method:
    1. Guard: if `!this.currentUserId` return (not logged in, skip)
    2. Guard: if tableName not in SENSITIVE_TABLES return (only audit sensitive data)
       - Define `SENSITIVE_TABLES = ['workers', 'treatments', 'near_misses', 'safety_checks']`
    3. Write to WatermelonDB audit_log table via `database.write()`:
       - user_id: this.currentUserId
       - table_name: tableName
       - record_id: recordId
       - operation: operation (typically 'READ' for client-side, but also 'CREATE'/'UPDATE'/'DELETE' for completeness)
       - context: context || '' (e.g., 'worker_profile_view', 'treatment_detail', 'emergency_lookup')
       - synced: false
       - created_at: Date.now()
    4. Do NOT immediately enqueue to sync queue -- audit logs batch-sync (see syncPendingAuditLogs)

    `syncPendingAuditLogs()` async method:
    1. Query audit_log where synced === false, ordered by created_at ASC, limit 50
    2. For each batch of entries:
       a. Map to Supabase-compatible payload: `{ table_name, record_id, operation: entry.operation, user_id, org_id: (from JWT/auth), changed_fields: null, ip_address: null, created_at: new Date(entry.createdAt).toISOString() }`
       b. Enqueue as a single sync queue item: `syncQueue.enqueue('create', 'audit_logs', batchId, batchPayload, 2)` -- priority 2 (lower than normal data, never blocks RIDDOR)
    3. Mark entries as synced: `database.write()` to update synced = true for processed entries
    4. Return count of entries synced

    IMPORTANT:
    - Audit log entries use priority 2 in sync queue (lower than RIDDOR=0 and normal=1) to never block clinical data sync
    - Batch syncing (50 at a time) prevents overwhelming the sync queue with individual audit entries
    - The `context` field helps identify WHY data was accessed (useful for GDPR compliance audits)
    - Audit entries are never deleted from local DB -- they're marked synced. Cleanup happens via data retention in Phase 2+
    - This service is called by data access hooks/functions in Phase 2 when building the actual UI screens (e.g., when Treatment detail screen loads, call `auditLogger.logAccess('treatments', treatmentId, 'READ', 'treatment_detail')`)

    Export singleton: `export const auditLogger = new AuditLogger()`
  </action>
  <verify>
    Run `npx tsc --noEmit` to verify compilation. Verify AuditLogger writes to WatermelonDB audit_log table (not in-memory). Verify SENSITIVE_TABLES array includes workers, treatments, near_misses, safety_checks. Verify syncPendingAuditLogs uses priority 2 (lower than normal sync). Verify logAccess is a no-op when currentUserId is null. Verify batch size is limited to 50 entries.
  </verify>
  <done>
    AuditLogger service records client-side data access to local WatermelonDB audit_log table. READ operations on sensitive health data tables are captured with user_id, table_name, record_id, operation, and context. Unsynced entries batch-sync to Supabase at low priority (2) via the SyncQueue. Service is ready for integration in Phase 2 data access screens.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create sync status UI components and SyncContext</name>
  <files>
    src/contexts/SyncContext.tsx
    src/components/SyncStatusIndicator.tsx
    src/components/OfflineBanner.tsx
    App.tsx
  </files>
  <action>
    **src/contexts/SyncContext.tsx:**
    Create React Context for sync state:

    Define `SyncState` type:
    ```typescript
    type SyncStatus = 'synced' | 'syncing' | 'pending' | 'offline' | 'error'

    interface SyncState {
      status: SyncStatus
      pendingCount: number
      isOnline: boolean
      connectionType: string
      lastSyncAt: Date | null
      lastError: string | null
    }
    ```

    Define `SyncContextType`:
    ```typescript
    interface SyncContextType {
      state: SyncState
      triggerSync: () => Promise<void>
      enqueueSyncItem: (operation: string, tableName: string, recordId: string, payload: any, priority?: number) => Promise<void>
    }
    ```

    Create `SyncProvider` component:
    1. Initialize state with default values (status: 'synced', pendingCount: 0, etc.)
    2. On mount:
       - Start networkMonitor
       - Add listener to networkMonitor for online/offline changes
       - Poll pending count every 10 seconds (or use WatermelonDB observable)
       - Set auditLogger's current user from auth context
    3. Update status logic:
       - If !isOnline -> 'offline'
       - If isProcessing -> 'syncing'
       - If pendingCount > 0 -> 'pending'
       - If lastError -> 'error'
       - Otherwise -> 'synced'
    4. `triggerSync`: call syncQueue.processPendingItems() AND auditLogger.syncPendingAuditLogs(), update state
    5. `enqueueSyncItem`: call syncQueue.enqueue(), update pendingCount
    6. Cleanup: stop networkMonitor on unmount

    Export `SyncProvider` and `useSync` hook.

    **src/components/SyncStatusIndicator.tsx:**
    Create visual indicator component using `useSync()`:

    Color mapping:
    - synced: green (#22C55E)
    - syncing: blue (#3B82F6) with pulse animation
    - pending: orange (#F59E0B)
    - offline: red (#EF4444)
    - error: red (#EF4444) with exclamation icon

    Render:
    - Circular dot (12px) with status color
    - Label text: "Synced", "Syncing...", "X pending", "Offline", "Sync error"
    - If pendingCount > 0: show count badge (small red circle with number)
    - OnPress: if pending or error, trigger manual sync retry

    Use React Native `Animated` for pulse animation on 'syncing' status.

    Style with StyleSheet (not Tailwind -- React Native):
    - 48x48pt minimum touch target (gloves-on usability requirement)
    - High contrast colors for bright sunlight readability

    **src/components/OfflineBanner.tsx:**
    Create banner component using `useSync()`:
    - Only renders when `state.isOnline === false`
    - Yellow/amber background (#FEF3C7)
    - Text: "You're offline. Changes are saved locally and will sync when connected."
    - Fixed position at top of screen (below status bar)
    - Dismiss button (but re-shows if still offline after 30 seconds)

    **App.tsx:**
    Update the existing App.tsx to integrate providers:
    ```
    <AuthProvider>
      <SyncProvider>
        <OfflineBanner />
        <View style={styles.container}>
          <Text>SiteMedic</Text>
          <SyncStatusIndicator />
        </View>
      </SyncProvider>
    </AuthProvider>
    ```

    Also call `initDatabase()` on app launch (before rendering providers).

    IMPORTANT:
    - Initialize database BEFORE AuthProvider/SyncProvider mount
    - Use a loading screen while database initializes
    - SyncProvider must be inside AuthProvider (sync needs auth token)
    - SyncProvider should call `auditLogger.setCurrentUser(userId)` when auth state changes
  </action>
  <verify>
    Run `npx tsc --noEmit` to verify compilation. Run `npx expo start --ios` and verify:
    1. App launches with SiteMedic text and sync indicator (green dot = "Synced")
    2. Toggle airplane mode on simulator: offline banner appears, sync indicator turns red
    3. Toggle airplane mode off: offline banner disappears, sync indicator returns to green
    Verify SyncStatusIndicator has 48x48pt minimum touch target.
  </verify>
  <done>
    SyncContext provides sync state to all components. SyncStatusIndicator shows color-coded status with pending count badge. OfflineBanner appears when offline. App.tsx integrates all providers (Auth + Sync) with database initialization on launch. AuditLogger user context set from auth state.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Complete Phase 1 foundation: Expo app with Supabase backend schema, WatermelonDB local database (6 tables including audit_log), authentication with offline persistence and biometrics, client-side audit logging service, sync queue with network monitoring, and visual sync status indicators.
  </what-built>
  <how-to-verify>
    1. Open iOS Simulator and launch the app
    2. Verify app shows "SiteMedic" text with a green sync status indicator
    3. Toggle airplane mode ON in simulator (Device -> Toggle Airplane Mode or use Network Link Conditioner)
    4. Verify: Yellow "You're offline" banner appears, sync indicator turns red with "Offline" label
    5. Toggle airplane mode OFF
    6. Verify: Offline banner disappears, sync indicator returns to green
    7. Check terminal/console for any error messages during these transitions
    8. Verify the SQL migration files exist in supabase/migrations/ (6 files)
    9. Verify .env is NOT committed to git (run `git status`)
    10. Verify src/services/AuditLogger.ts exists and exports auditLogger singleton
    11. Verify src/database/models/AuditLogEntry.ts exists with audit_log table
  </how-to-verify>
  <resume-signal>Type "approved" or describe any issues seen during verification</resume-signal>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- App launches on iOS simulator without crashes
- SyncQueue stores items in WatermelonDB (not in-memory)
- NetworkMonitor detects online/offline transitions
- AuditLogger writes to local audit_log table with user_id, table_name, record_id, operation, context
- AuditLogger batch-syncs unsynced entries via SyncQueue at priority 2
- SyncStatusIndicator shows 5 states with correct colors
- OfflineBanner appears/disappears based on connectivity
- Pending count badge shows number of unsynced items
- App.tsx integrates AuthProvider, SyncProvider, database init
- All providers initialize without errors
</verification>

<success_criteria>
- Sync queue persists across force-quit (ARCH-04)
- Background sync ready with WiFi detection for Phase 3 photo constraint (ARCH-05)
- Multi-modal sync status indicators work: color, labels, pending count badge (ARCH-06)
- Network connectivity detection triggers sync status updates (ARCH-07)
- Visual offline indicator visible to medic (UX requirement for construction sites)
- RIDDOR-reportable items get sync priority (compliance requirement)
- Client-side audit logging captures READ operations on sensitive tables (GDPR-02)
- Audit log entries sync to Supabase at low priority without blocking clinical data (GDPR-02)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-05-SUMMARY.md`
</output>
