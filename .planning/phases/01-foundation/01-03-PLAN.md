---
phase: 01-foundation
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/database/schema.ts
  - src/database/migrations.ts
  - src/database/models/Treatment.ts
  - src/database/models/Worker.ts
  - src/database/models/NearMiss.ts
  - src/database/models/SafetyCheck.ts
  - src/database/models/SyncQueueItem.ts
  - src/database/models/AuditLogEntry.ts
  - src/database/models/index.ts
  - src/lib/watermelon.ts
  - src/lib/encryption.ts
autonomous: true

must_haves:
  truths:
    - "WatermelonDB database initializes without errors on app launch"
    - "All 6 model classes (Treatment, Worker, NearMiss, SafetyCheck, SyncQueueItem, AuditLogEntry) are registered and queryable"
    - "Encryption key is generated on first launch and stored in iOS Keychain via expo-secure-store"
    - "Encryption key persists across app restarts (retrieved from Keychain, not regenerated)"
    - "Schema version 1 matches Supabase schema structure for sync compatibility"
    - "Local audit_log table captures client-side data access events for GDPR-02 compliance"
  artifacts:
    - path: "src/database/schema.ts"
      provides: "WatermelonDB schema definition matching Supabase tables"
      contains: "appSchema"
    - path: "src/lib/watermelon.ts"
      provides: "Database initialization with model registration"
      exports: ["database", "initDatabase"]
    - path: "src/lib/encryption.ts"
      provides: "Encryption key management via iOS Keychain"
      exports: ["getOrCreateEncryptionKey"]
    - path: "src/database/models/Treatment.ts"
      provides: "Treatment model class with WatermelonDB decorators"
      contains: "extends Model"
    - path: "src/database/models/AuditLogEntry.ts"
      provides: "Client-side audit log model for GDPR-02 READ tracking"
      contains: "extends Model"
  key_links:
    - from: "src/lib/watermelon.ts"
      to: "src/database/schema.ts"
      via: "SQLiteAdapter uses schema"
      pattern: "import.*schema.*from.*database/schema"
    - from: "src/lib/watermelon.ts"
      to: "src/database/models/index.ts"
      via: "Database constructor receives modelClasses array"
      pattern: "modelClasses"
    - from: "src/lib/encryption.ts"
      to: "expo-secure-store"
      via: "getItemAsync/setItemAsync for Keychain storage"
      pattern: "SecureStore\\.(get|set)ItemAsync"
---

<objective>
Set up WatermelonDB as the offline-first local database with typed model classes matching the Supabase schema, plus encryption key management via iOS Keychain and a local audit log table for client-side GDPR compliance.

Purpose: WatermelonDB is the local data layer that enables 100% offline operation. Every clinical record (treatment, worker, near-miss, safety check) is created locally first, then synced to Supabase later. The encryption key infrastructure prepares for Phase 2 SQLCipher integration (deferred per research recommendation, but key management must be ready now). The local audit_log table enables client-side tracking of READ operations on sensitive data (GDPR-02), which the server-side PostgreSQL triggers cannot capture.
Output: Fully initialized local database with 6 model classes, Keychain-backed encryption key ready for future SQLCipher, and local audit log table for client-side access tracking.
</objective>

<execution_context>
@/Users/sabineresoagli/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sabineresoagli/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create WatermelonDB schema and model classes</name>
  <files>
    src/database/schema.ts
    src/database/migrations.ts
    src/database/models/Treatment.ts
    src/database/models/Worker.ts
    src/database/models/NearMiss.ts
    src/database/models/SafetyCheck.ts
    src/database/models/SyncQueueItem.ts
    src/database/models/AuditLogEntry.ts
    src/database/models/index.ts
  </files>
  <action>
    **src/database/schema.ts:**
    Define WatermelonDB schema version 1 using `appSchema` and `tableSchema` from `@nozbe/watermelondb`.

    Tables must mirror the Supabase schema (from Plan 02) for sync compatibility:

    `treatments` table columns:
    - server_id (string, optional) -- Supabase UUID after sync
    - org_id (string, indexed)
    - worker_id (string, indexed)
    - medic_id (string)
    - injury_type (string)
    - body_part (string)
    - severity (string) -- minor/moderate/major/critical
    - treatment_notes (string)
    - outcome (string)
    - is_riddor_reportable (boolean)
    - photo_uris (string) -- JSON array stored as string
    - signature_uri (string, optional)
    - created_at (number) -- epoch milliseconds
    - updated_at (number)
    - last_modified_at (number) -- for sync conflict resolution

    `workers` table columns:
    - server_id (string, optional)
    - org_id (string, indexed)
    - first_name (string)
    - last_name (string)
    - company (string)
    - role (string)
    - phone (string, optional)
    - emergency_contact_name (string, optional)
    - emergency_contact_phone (string, optional)
    - health_notes (string, optional)
    - consent_given (boolean)
    - consent_date (number, optional)
    - created_at (number)
    - updated_at (number)
    - last_modified_at (number)

    `near_misses` table columns:
    - server_id (string, optional)
    - org_id (string, indexed)
    - reported_by (string)
    - category (string)
    - severity (string)
    - description (string)
    - location (string, optional)
    - photo_uris (string)
    - corrective_action (string, optional)
    - created_at (number)
    - updated_at (number)
    - last_modified_at (number)

    `safety_checks` table columns:
    - server_id (string, optional)
    - org_id (string, indexed)
    - medic_id (string)
    - check_date (number) -- epoch for the date
    - items (string) -- JSON stringified array
    - overall_status (string) -- pass/fail/partial
    - photo_uris (string)
    - created_at (number)
    - updated_at (number)
    - last_modified_at (number)

    `sync_queue` table columns:
    - operation (string) -- create/update/delete
    - table_name (string)
    - record_id (string) -- local WatermelonDB ID
    - payload (string) -- JSON stringified
    - priority (number) -- 0 = immediate (RIDDOR), 1 = normal
    - retry_count (number)
    - next_retry_at (number) -- epoch milliseconds
    - created_at (number)

    `audit_log` table columns (NEW -- for client-side GDPR-02 compliance):
    - user_id (string) -- authenticated user's Supabase UUID
    - table_name (string) -- which table was accessed (e.g., 'workers', 'treatments')
    - record_id (string) -- WatermelonDB ID of the accessed record
    - operation (string) -- 'READ', 'CREATE', 'UPDATE', 'DELETE'
    - context (string, optional) -- why the access happened (e.g., 'worker_profile_view', 'treatment_history', 'emergency_lookup')
    - synced (boolean) -- false until synced to Supabase audit_logs table
    - created_at (number) -- epoch milliseconds

    **src/database/migrations.ts:**
    Create empty migrations file with `schemaMigrations({ migrations: [] })` -- version 1 has no migrations yet.

    **Model classes (one file per model):**
    Each model extends `Model` from `@nozbe/watermelondb`. Use decorators: `@field`, `@date`, `@readonly`, `@text`, `@json`.

    Treatment.ts:
    - `static table = 'treatments'`
    - All columns as decorated fields
    - `@json('photo_uris', sanitizePhotoUris)` for JSON array handling (sanitizer returns `[]` if parse fails)
    - `static associations` linking to workers table

    Worker.ts:
    - `static table = 'workers'`
    - `static associations` linking to treatments (has_many)
    - `@lazy treatments` getter using `this.collections.get('treatments').query(Q.where('worker_id', this.id))`

    NearMiss.ts:
    - `static table = 'near_misses'`
    - `@json('photo_uris', sanitizePhotoUris)` for JSON array

    SafetyCheck.ts:
    - `static table = 'safety_checks'`
    - `@json('items', sanitizeItems)` for JSON array of checklist items
    - `@json('photo_uris', sanitizePhotoUris)`

    SyncQueueItem.ts:
    - `static table = 'sync_queue'`
    - All columns as decorated fields

    AuditLogEntry.ts (NEW):
    - `static table = 'audit_log'`
    - `@field('user_id') userId!: string`
    - `@field('table_name') tableName!: string`
    - `@field('record_id') recordId!: string`
    - `@field('operation') operation!: string`
    - `@field('context') context!: string`
    - `@field('synced') synced!: boolean`
    - `@field('created_at') createdAt!: number`

    **src/database/models/index.ts:**
    Re-export all model classes as an array:
    ```typescript
    export const modelClasses = [Treatment, Worker, NearMiss, SafetyCheck, SyncQueueItem, AuditLogEntry]
    ```

    IMPORTANT:
    - WatermelonDB uses its own auto-generated string IDs internally. The `server_id` column stores the Supabase UUID after first sync.
    - All `created_at` and `updated_at` fields use epoch milliseconds (number type), not Date objects.
    - `last_modified_at` is used by sync for conflict resolution (last-write-wins).
    - The `audit_log` table does NOT need a `server_id` column -- audit entries are write-once and synced via the sync queue, not via WatermelonDB's built-in sync. The `synced` boolean tracks whether the entry has been pushed to Supabase.
  </action>
  <verify>
    Run `npx tsc --noEmit` to verify all model files compile. Verify schema has exactly 6 tables (treatments, workers, near_misses, safety_checks, sync_queue, audit_log). Verify each model class has `static table` matching schema table name. Verify `modelClasses` array in index.ts has 6 entries. Verify AuditLogEntry model has user_id, table_name, record_id, operation, context, synced fields.
  </verify>
  <done>
    WatermelonDB schema version 1 defined with 6 tables matching Supabase structure (5 data tables + 1 audit log). Model classes created with proper decorators, associations, and JSON field handling. All models exported via index.ts for database registration. AuditLogEntry model ready for client-side GDPR-02 access logging.
  </done>
</task>

<task type="auto">
  <name>Task 2: Initialize WatermelonDB database and encryption key management</name>
  <files>
    src/lib/watermelon.ts
    src/lib/encryption.ts
  </files>
  <action>
    **src/lib/encryption.ts:**
    Create encryption key management module:

    ```typescript
    import * as SecureStore from 'expo-secure-store'
    import * as Crypto from 'expo-crypto'
    ```

    `getOrCreateEncryptionKey()` async function:
    1. Define `KEY_NAME = 'sitemedic_db_encryption_key'`
    2. Try `SecureStore.getItemAsync(KEY_NAME)` to retrieve existing key
    3. If no key exists:
       - Generate 32 random bytes using `Crypto.getRandomBytes(32)`
       - Convert to 64-character hex string
       - Store via `SecureStore.setItemAsync(KEY_NAME, key, { keychainAccessible: SecureStore.WHEN_UNLOCKED_THIS_DEVICE_ONLY })`
    4. Return the key string
    5. Export the function

    Add clear comment: "// Key stored in iOS Keychain (hardware-backed). Will be used for SQLCipher encryption in Phase 2. Never store in AsyncStorage."

    `deleteEncryptionKey()` async function (for GDPR erasure):
    - `SecureStore.deleteItemAsync(KEY_NAME)`
    - Export this function

    **src/lib/watermelon.ts:**
    Create database initialization module:

    ```typescript
    import { Database } from '@nozbe/watermelondb'
    import SQLiteAdapter from '@nozbe/watermelondb/adapters/sqlite'
    import { schema } from '../database/schema'
    import migrations from '../database/migrations'
    import { modelClasses } from '../database/models'
    import { getOrCreateEncryptionKey } from './encryption'
    ```

    `initDatabase()` async function:
    1. Call `getOrCreateEncryptionKey()` to ensure key exists (ready for Phase 2 SQLCipher)
    2. Create `SQLiteAdapter` with:
       - `schema`
       - `migrations`
       - `jsi: true` (enable JSI for better performance on iOS)
       - Comment: `// encryptionKey will be passed here once SQLCipher integration is ready (Phase 2)`
    3. Create `Database` instance with adapter and `modelClasses` (all 6 models including AuditLogEntry)
    4. Store in module-level variable
    5. Return database instance

    `getDatabase()` function:
    - Returns the initialized database instance
    - Throws error if called before `initDatabase()`

    Export both `initDatabase` and `getDatabase`.

    IMPORTANT: Do NOT pass `encryptionKey` to SQLiteAdapter yet -- WatermelonDB's SQLCipher support is not merged (per research). The key is generated and stored now so it's ready for Phase 2.
  </action>
  <verify>
    Run `npx tsc --noEmit` to verify compilation. Verify `encryption.ts` imports from `expo-secure-store` and `expo-crypto`. Verify `watermelon.ts` imports schema, migrations, and modelClasses. Verify `getOrCreateEncryptionKey` is called in `initDatabase`. Verify no `encryptionKey` is passed to SQLiteAdapter (only comment about Phase 2). Verify modelClasses includes AuditLogEntry (6 models total).
  </verify>
  <done>
    WatermelonDB database initializes with all 6 model classes registered (including AuditLogEntry). Encryption key generated on first launch and stored in iOS Keychain via expo-secure-store. Key infrastructure ready for SQLCipher in Phase 2. Database instance accessible via getDatabase() after initialization.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- Schema defines exactly 6 tables: treatments, workers, near_misses, safety_checks, sync_queue, audit_log
- Each model class extends Model with correct `static table` name
- Encryption key uses expo-secure-store (NOT AsyncStorage)
- WatermelonDB adapter does NOT pass encryptionKey (deferred to Phase 2)
- All JSON fields (photo_uris, items) have sanitizer functions
- All timestamp fields use number type (epoch milliseconds)
- AuditLogEntry model has synced boolean for tracking sync status
</verification>

<success_criteria>
- WatermelonDB initializes without errors when app launches
- 6 model classes queryable (Treatment, Worker, NearMiss, SafetyCheck, SyncQueueItem, AuditLogEntry)
- Encryption key persists in iOS Keychain across app restarts
- Schema structure matches Supabase tables for future sync compatibility
- No sensitive data stored in AsyncStorage or plaintext
- Local audit_log table ready for client-side access logging (GDPR-02)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
