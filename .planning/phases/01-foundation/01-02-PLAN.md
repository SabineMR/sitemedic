---
phase: 01-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/00001_organizations.sql
  - supabase/migrations/00002_profiles_and_roles.sql
  - supabase/migrations/00003_health_data_tables.sql
  - supabase/migrations/00004_rls_policies.sql
  - supabase/migrations/00005_audit_logging.sql
  - supabase/migrations/00006_gdpr_infrastructure.sql
  - supabase/seed.sql
autonomous: true
user_setup:
  - service: supabase
    why: "Backend database and authentication"
    env_vars:
      - name: EXPO_PUBLIC_SUPABASE_URL
        source: "Supabase Dashboard -> Settings -> API -> Project URL"
      - name: EXPO_PUBLIC_SUPABASE_ANON_KEY
        source: "Supabase Dashboard -> Settings -> API -> anon/public key"
    dashboard_config:
      - task: "Create new Supabase project in eu-west-2 (London) region"
        location: "https://supabase.com/dashboard -> New Project -> Region: West Europe (London)"
      - task: "Request DPA (Data Processing Agreement) for GDPR compliance"
        location: "Supabase Dashboard -> Settings -> Legal -> Request DPA (or email support@supabase.io)"

must_haves:
  truths:
    - "Organizations table exists with UUID primary keys"
    - "User profiles link to auth.users with role field (medic, site_manager, admin)"
    - "Health data tables (treatments, workers, near_misses, safety_checks) have org_id for multi-tenancy"
    - "RLS policies enforce org-level isolation on all health data tables"
    - "Audit triggers log INSERT/UPDATE/DELETE on all health data tables (field names only, not values)"
    - "GDPR tables exist for consent records, data retention tracking, and erasure requests"
    - "All primary keys are UUID (not auto-increment) for offline record creation"
  artifacts:
    - path: "supabase/migrations/00004_rls_policies.sql"
      provides: "Row-Level Security policies for multi-tenant isolation"
      contains: "CREATE POLICY"
    - path: "supabase/migrations/00005_audit_logging.sql"
      provides: "Database-level audit logging via PostgreSQL triggers"
      contains: "log_data_access"
    - path: "supabase/migrations/00006_gdpr_infrastructure.sql"
      provides: "GDPR consent, retention, and erasure tables"
      contains: "consent_records"
  key_links:
    - from: "supabase/migrations/00004_rls_policies.sql"
      to: "auth.jwt()"
      via: "RLS USING clause reads org_id from JWT app_metadata"
      pattern: "auth.jwt.*app_metadata.*org_id"
    - from: "supabase/migrations/00005_audit_logging.sql"
      to: "auth.uid()"
      via: "Trigger function logs current authenticated user"
      pattern: "auth\\.uid\\(\\)"
    - from: "supabase/migrations/00002_profiles_and_roles.sql"
      to: "auth.users"
      via: "profiles.id references auth.users(id)"
      pattern: "REFERENCES auth\\.users"
---

<objective>
Create the complete Supabase PostgreSQL schema with Row-Level Security, audit logging, and GDPR infrastructure as SQL migration files ready to apply to a Supabase project.

Purpose: This is the backend data foundation. RLS ensures multi-tenant isolation at the database level (not application level), audit logging meets GDPR Article 30 accountability requirements, and UUID primary keys enable offline record creation without server coordination.
Output: SQL migration files in `supabase/migrations/` that can be applied via Supabase Dashboard SQL Editor or `supabase db push`.
</objective>

<execution_context>
@/Users/sabineresoagli/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sabineresoagli/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create core database schema (organizations, profiles, health data tables)</name>
  <files>
    supabase/migrations/00001_organizations.sql
    supabase/migrations/00002_profiles_and_roles.sql
    supabase/migrations/00003_health_data_tables.sql
    supabase/seed.sql
  </files>
  <action>
    Create `supabase/migrations/` directory.

    **00001_organizations.sql:**
    - Create `organizations` table:
      - `id UUID PRIMARY KEY DEFAULT gen_random_uuid()`
      - `name TEXT NOT NULL`
      - `created_at TIMESTAMPTZ DEFAULT NOW()`
      - `updated_at TIMESTAMPTZ DEFAULT NOW()`

    **00002_profiles_and_roles.sql:**
    - Create custom type: `CREATE TYPE user_role AS ENUM ('medic', 'site_manager', 'admin')`
    - Create `profiles` table:
      - `id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE`
      - `org_id UUID NOT NULL REFERENCES organizations(id)`
      - `role user_role NOT NULL DEFAULT 'medic'`
      - `full_name TEXT NOT NULL`
      - `email TEXT NOT NULL`
      - `phone TEXT`
      - `created_at TIMESTAMPTZ DEFAULT NOW()`
      - `updated_at TIMESTAMPTZ DEFAULT NOW()`
    - Create index: `CREATE INDEX idx_profiles_org_id ON profiles(org_id)`
    - Create trigger function `set_user_org_metadata()` that runs AFTER INSERT on profiles to set `org_id` and `role` in `auth.users.raw_app_meta_data` (so JWT claims include org_id and role)
    - Create trigger function `handle_new_user()` that creates a profile entry when a new auth.users row is inserted (using raw_user_meta_data for org_id, full_name, role)

    **00003_health_data_tables.sql:**
    All tables use UUID primary keys with `gen_random_uuid()`. All include `org_id UUID NOT NULL REFERENCES organizations(id)`.

    Create `workers` table:
    - `id`, `org_id`, `first_name TEXT`, `last_name TEXT`, `company TEXT`, `role TEXT`, `phone TEXT`, `emergency_contact_name TEXT`, `emergency_contact_phone TEXT`, `health_notes TEXT`, `consent_given BOOLEAN DEFAULT FALSE`, `consent_date TIMESTAMPTZ`, `created_at`, `updated_at`, `deleted_at TIMESTAMPTZ` (soft delete for sync)
    - Index on org_id, index on deleted_at

    Create `treatments` table:
    - `id`, `org_id`, `worker_id UUID REFERENCES workers(id)`, `medic_id UUID REFERENCES profiles(id)`, `injury_type TEXT NOT NULL`, `body_part TEXT`, `severity TEXT CHECK (severity IN ('minor', 'moderate', 'major', 'critical'))`, `treatment_notes TEXT`, `outcome TEXT CHECK (outcome IN ('returned_to_work', 'sent_home', 'hospital_referral', 'ambulance_called'))`, `is_riddor_reportable BOOLEAN DEFAULT FALSE`, `riddor_confidence TEXT`, `photo_uris JSONB DEFAULT '[]'`, `signature_uri TEXT`, `created_at`, `updated_at`, `deleted_at TIMESTAMPTZ`
    - Indexes on org_id, worker_id, medic_id, created_at, deleted_at

    Create `near_misses` table:
    - `id`, `org_id`, `reported_by UUID REFERENCES profiles(id)`, `category TEXT NOT NULL`, `severity TEXT CHECK (severity IN ('low', 'medium', 'high', 'critical'))`, `description TEXT NOT NULL`, `location TEXT`, `photo_uris JSONB DEFAULT '[]'`, `corrective_action TEXT`, `created_at`, `updated_at`, `deleted_at TIMESTAMPTZ`
    - Indexes on org_id, reported_by, created_at, deleted_at

    Create `safety_checks` table:
    - `id`, `org_id`, `medic_id UUID REFERENCES profiles(id)`, `check_date DATE NOT NULL`, `items JSONB NOT NULL` (array of {item: string, status: 'pass'|'fail'|'na', notes: string}), `overall_status TEXT CHECK (overall_status IN ('pass', 'fail', 'partial'))`, `photo_uris JSONB DEFAULT '[]'`, `created_at`, `updated_at`, `deleted_at TIMESTAMPTZ`
    - Indexes on org_id, medic_id, check_date, deleted_at

    **supabase/seed.sql:**
    Create a seed file with:
    - One test organization: "Kai's Medic Services"
    - Comment explaining how to create a test user via Supabase Dashboard Auth

    CRITICAL: Every table that syncs between mobile and server MUST have:
    1. UUID primary key (not SERIAL)
    2. `org_id` column for RLS
    3. `created_at` and `updated_at` timestamps
    4. `deleted_at` for soft deletes (sync uses this instead of hard delete)
  </action>
  <verify>
    Review each SQL file for syntax correctness. Verify all primary keys are UUID. Verify all health data tables have `org_id`, `created_at`, `updated_at`, `deleted_at` columns. Verify indexes exist on `org_id` for every table.
  </verify>
  <done>
    Core database schema created with organizations, profiles (with role enum), and 4 health data tables (workers, treatments, near_misses, safety_checks). All tables use UUID primary keys, include org_id for multi-tenancy, and have soft-delete support via deleted_at.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create RLS policies, audit logging triggers, and GDPR infrastructure</name>
  <files>
    supabase/migrations/00004_rls_policies.sql
    supabase/migrations/00005_audit_logging.sql
    supabase/migrations/00006_gdpr_infrastructure.sql
  </files>
  <action>
    **00004_rls_policies.sql:**
    Enable RLS on ALL tables: organizations, profiles, workers, treatments, near_misses, safety_checks.

    Create policies:
    - `profiles`: Users can read/update their own profile. Users can read profiles in their org.
    - `organizations`: Users can read their own organization.
    - `workers`: Full CRUD for authenticated users in same org. Policy uses `(auth.jwt() -> 'app_metadata' ->> 'org_id')::uuid` for org matching.
    - `treatments`: Full CRUD for authenticated users in same org.
    - `near_misses`: Full CRUD for authenticated users in same org.
    - `safety_checks`: Full CRUD for authenticated users in same org.

    IMPORTANT: Create SEPARATE policies for SELECT, INSERT, UPDATE, DELETE (not a single FOR ALL) to allow granular role-based control later. For now, all authenticated org members get full access.

    For INSERT policies, use WITH CHECK to ensure org_id matches JWT claim (prevents writing to wrong org).

    **00005_audit_logging.sql:**
    Create `audit_logs` table:
    - `id UUID PRIMARY KEY DEFAULT gen_random_uuid()`
    - `table_name TEXT NOT NULL`
    - `record_id UUID NOT NULL`
    - `operation TEXT NOT NULL CHECK (operation IN ('INSERT', 'UPDATE', 'DELETE', 'SELECT'))`
    - `user_id UUID` (from auth.uid())
    - `org_id UUID`
    - `changed_fields JSONB` (field NAMES only, NEVER values -- GDPR minimization)
    - `ip_address TEXT` (anonymized: first 3 octets only)
    - `created_at TIMESTAMPTZ DEFAULT NOW()`
    - Indexes on (table_name, record_id), user_id, org_id, created_at

    Enable RLS on audit_logs: only admin role can SELECT.

    Create trigger function `log_data_access()`:
    - For UPDATE: extract changed field names using `jsonb_each(to_jsonb(NEW))` compared to `to_jsonb(OLD)`
    - NEVER log field values (GDPR Article 5(1)(c) data minimization)
    - Log: table_name, record_id, TG_OP, auth.uid(), org_id, changed field names array
    - Anonymize IP: use `regexp_replace(inet_client_addr()::text, '\\.[0-9]+$', '.xxx')` to mask last octet

    Attach trigger to all health data tables: workers, treatments, near_misses, safety_checks.

    **00006_gdpr_infrastructure.sql:**
    Create `consent_records` table:
    - `id UUID PRIMARY KEY DEFAULT gen_random_uuid()`
    - `worker_id UUID NOT NULL REFERENCES workers(id)`
    - `org_id UUID NOT NULL REFERENCES organizations(id)`
    - `consent_type TEXT NOT NULL` (e.g., 'data_processing', 'health_data', 'photo_capture')
    - `granted BOOLEAN NOT NULL`
    - `granted_at TIMESTAMPTZ`
    - `revoked_at TIMESTAMPTZ`
    - `signature_uri TEXT` (digital signature image)
    - `ip_address TEXT`
    - `created_at TIMESTAMPTZ DEFAULT NOW()`
    - Index on worker_id, org_id

    Create `erasure_requests` table:
    - `id UUID PRIMARY KEY DEFAULT gen_random_uuid()`
    - `worker_id UUID NOT NULL REFERENCES workers(id)`
    - `org_id UUID NOT NULL REFERENCES organizations(id)`
    - `requested_by UUID REFERENCES profiles(id)`
    - `status TEXT NOT NULL CHECK (status IN ('pending', 'processing', 'completed', 'rejected'))` DEFAULT 'pending'
    - `reason TEXT`
    - `completed_at TIMESTAMPTZ`
    - `created_at TIMESTAMPTZ DEFAULT NOW()`

    Create `data_retention_log` table:
    - `id UUID PRIMARY KEY DEFAULT gen_random_uuid()`
    - `table_name TEXT NOT NULL`
    - `records_deleted INTEGER NOT NULL`
    - `retention_period INTERVAL NOT NULL`
    - `executed_at TIMESTAMPTZ DEFAULT NOW()`

    Add comment noting pg_cron setup for automated retention (3-year minimum for RIDDOR):
    ```sql
    -- pg_cron schedule (apply via Supabase Dashboard -> Extensions -> pg_cron):
    -- DELETE old audit logs: SELECT cron.schedule('cleanup-audit-logs', '0 2 * * *', $$DELETE FROM audit_logs WHERE created_at < NOW() - INTERVAL '3 years'$$);
    -- NOTE: Do NOT auto-delete health data -- RIDDOR requires 3-year minimum retention. Erasure only via explicit erasure_requests workflow.
    ```

    Enable RLS on consent_records, erasure_requests, data_retention_log with org-based policies.
  </action>
  <verify>
    Review SQL for syntax. Verify RLS is enabled on every table. Verify audit trigger function logs field names only (search for `to_jsonb(NEW)` -- should NOT appear as a stored value, only for comparison). Verify all GDPR tables have RLS policies. Count total policies: should be at least 4 per health data table (SELECT, INSERT, UPDATE, DELETE).
  </verify>
  <done>
    RLS policies enforce org-level isolation on all tables. Audit logging triggers capture all data access on health data tables with GDPR-compliant field-name-only logging. GDPR infrastructure tables exist for consent records, erasure requests, and retention tracking. Admin-only access on audit logs.
  </done>
</task>

</tasks>

<verification>
- All 6 migration files exist in `supabase/migrations/` with valid SQL syntax
- Every health data table has: UUID PK, org_id with index, created_at, updated_at, deleted_at
- RLS enabled on every table (grep for "ENABLE ROW LEVEL SECURITY" -- should appear for each table)
- Audit trigger attached to workers, treatments, near_misses, safety_checks
- Audit log stores field names only, never field values
- GDPR tables (consent_records, erasure_requests, data_retention_log) exist with RLS
- No auto-increment (SERIAL) primary keys anywhere
</verification>

<success_criteria>
- Complete PostgreSQL schema ready to apply to a fresh Supabase project
- Multi-tenant isolation via RLS (database-level, not application-level)
- GDPR Article 30 compliance via audit logging
- GDPR Article 17 support via erasure_requests table
- GDPR Article 7 support via consent_records table
- All tables sync-ready with UUID PKs and soft-delete columns
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
