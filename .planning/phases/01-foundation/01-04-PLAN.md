---
phase: 01-foundation
plan: 04
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/lib/auth-manager.ts
  - src/lib/biometric-auth.ts
  - src/contexts/AuthContext.tsx
  - src/types/auth.ts
autonomous: true

must_haves:
  truths:
    - "User can sign up with email/password and org assignment"
    - "User can sign in with email/password"
    - "User session persists across app restarts (cached in AsyncStorage)"
    - "User is NOT logged out when device goes offline (AuthManager prevents offline logout)"
    - "Biometric auth (Face ID/Touch ID) can be enabled and used for quick access"
    - "Auth state is available throughout the app via React Context"
    - "Role (medic/site_manager/admin) is accessible from user session"
  artifacts:
    - path: "src/lib/auth-manager.ts"
      provides: "Offline-safe authentication wrapper around Supabase Auth"
      exports: ["AuthManager", "authManager"]
    - path: "src/lib/biometric-auth.ts"
      provides: "Face ID / Touch ID authentication utilities"
      exports: ["enableBiometricAuth", "authenticateWithBiometrics", "isBiometricEnabled"]
    - path: "src/contexts/AuthContext.tsx"
      provides: "React Context providing auth state and methods to all components"
      exports: ["AuthProvider", "useAuth"]
    - path: "src/types/auth.ts"
      provides: "TypeScript types for auth state, user profile, roles"
      exports: ["AuthState", "UserProfile", "UserRole"]
  key_links:
    - from: "src/lib/auth-manager.ts"
      to: "src/lib/supabase.ts"
      via: "Uses supabase client for auth operations"
      pattern: "import.*supabase.*from.*lib/supabase"
    - from: "src/lib/auth-manager.ts"
      to: "@react-native-async-storage/async-storage"
      via: "Caches session for offline restoration"
      pattern: "AsyncStorage\\.(get|set)Item"
    - from: "src/lib/auth-manager.ts"
      to: "@react-native-community/netinfo"
      via: "Checks connectivity before allowing logout"
      pattern: "NetInfo"
    - from: "src/contexts/AuthContext.tsx"
      to: "src/lib/auth-manager.ts"
      via: "AuthProvider wraps authManager methods in React context"
      pattern: "import.*authManager"
---

<objective>
Build the complete authentication system with offline session persistence, biometric authentication, and React Context integration.

Purpose: Medics work on construction sites with zero signal. The auth system must NEVER log them out when offline -- this is the #1 pitfall identified in research (Pitfall 2). Biometric auth enables quick 2-second access for medics wearing gloves. The AuthContext makes auth state available throughout the app without prop drilling.
Output: Working auth system that handles signup, signin, offline persistence, biometric unlock, and role-based access.
</objective>

<execution_context>
@/Users/sabineresoagli/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sabineresoagli/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AuthManager with offline session persistence and biometric auth</name>
  <files>
    src/types/auth.ts
    src/lib/auth-manager.ts
    src/lib/biometric-auth.ts
  </files>
  <action>
    **src/types/auth.ts:**
    Define TypeScript types:
    ```typescript
    export type UserRole = 'medic' | 'site_manager' | 'admin'

    export interface UserProfile {
      id: string
      email: string
      fullName: string
      orgId: string
      role: UserRole
    }

    export interface AuthState {
      isAuthenticated: boolean
      isLoading: boolean
      user: UserProfile | null
      session: any | null  // Supabase Session type
      isOnline: boolean
      isOfflineSession: boolean  // True when using cached session while offline
    }

    export interface SignUpData {
      email: string
      password: string
      fullName: string
      orgId: string
      role?: UserRole
    }
    ```

    **src/lib/auth-manager.ts:**
    Create AuthManager class (following Research Pattern 3):

    Constructor/properties:
    - `private isOnline: boolean = true`
    - `private sessionCacheKey = 'sitemedic.auth.session'`
    - `private profileCacheKey = 'sitemedic.auth.profile'`

    `initialize()` method:
    1. Set up NetInfo listener to track connectivity: `NetInfo.addEventListener(state => this.isOnline = state.isConnected ?? false)`
    2. Check initial network state via `NetInfo.fetch()`
    3. If offline, call `restoreCachedSession()`
    4. Set up `supabase.auth.onAuthStateChange` listener:
       - On `SIGNED_OUT`: if `!this.isOnline`, call `restoreCachedSession()` to PREVENT offline logout
       - On `SIGNED_IN` or `TOKEN_REFRESHED`: cache the new session via `cacheSession(session)`

    `signUp(data: SignUpData)` method:
    1. Call `supabase.auth.signUp({ email, password, options: { data: { full_name: data.fullName, org_id: data.orgId, role: data.role || 'medic' } } })`
    2. On success, cache session and profile
    3. Return `{ data, error }`

    `signIn(email: string, password: string)` method:
    1. Call `supabase.auth.signInWithPassword({ email, password })`
    2. On success, cache session in AsyncStorage
    3. Fetch user profile from Supabase (profiles table) and cache it
    4. Return `{ data, error }`

    `signOut()` method:
    1. Clear cached session and profile from AsyncStorage
    2. Call `supabase.auth.signOut()`

    `getSession()` method:
    1. Try `supabase.auth.getSession()`
    2. If fails and offline, restore from cache
    3. Return session or null

    `getUserProfile()` method:
    1. Try to get profile from Supabase `profiles` table using auth.uid()
    2. If offline, return cached profile from AsyncStorage
    3. Return `UserProfile` or null

    Private `cacheSession(session)`:
    - `AsyncStorage.setItem(sessionCacheKey, JSON.stringify(session))`

    Private `cacheProfile(profile: UserProfile)`:
    - `AsyncStorage.setItem(profileCacheKey, JSON.stringify(profile))`

    Private `restoreCachedSession()`:
    1. Read cached session from AsyncStorage
    2. If exists and token not expired (`expires_at > Date.now() / 1000`), call `supabase.auth.setSession(cachedSession)`
    3. Log restoration event

    Export singleton: `export const authManager = new AuthManager()`

    CRITICAL BEHAVIORS:
    - NEVER call signOut when offline (even if Supabase triggers SIGNED_OUT event)
    - Always cache session on successful auth operations
    - JWT expiry check is LOCAL (no server call) when offline
    - Accept that JWT may be stale by up to 1 hour (acceptable per research)

    **src/lib/biometric-auth.ts:**
    Create biometric authentication utilities (following Research biometric pattern):

    `checkBiometricSupport()`:
    1. Check `LocalAuthentication.hasHardwareAsync()`
    2. Check `LocalAuthentication.isEnrolledAsync()`
    3. Get supported types via `LocalAuthentication.supportedAuthenticationTypesAsync()`
    4. Return `{ isSupported, isEnrolled, supportedTypes }`

    `enableBiometricAuth(userId: string)`:
    1. Verify biometric support
    2. Store flag in SecureStore: `SecureStore.setItemAsync('biometric_enabled_${userId}', 'true', { requireAuthentication: true, keychainAccessible: SecureStore.WHEN_UNLOCKED_THIS_DEVICE_ONLY })`

    `authenticateWithBiometrics()`:
    1. Call `LocalAuthentication.authenticateAsync({ promptMessage: 'Authenticate to access SiteMedic', fallbackLabel: 'Use Passcode', disableDeviceFallback: false })`
    2. Return `result.success` boolean

    `isBiometricEnabled(userId: string)`:
    1. Try `SecureStore.getItemAsync('biometric_enabled_${userId}')`
    2. Return `value === 'true'`
    3. Catch errors (biometrics changed invalidates key) -> return false

    `disableBiometricAuth(userId: string)`:
    1. `SecureStore.deleteItemAsync('biometric_enabled_${userId}')`
  </action>
  <verify>
    Run `npx tsc --noEmit` to verify compilation. Verify AuthManager imports NetInfo and AsyncStorage. Verify `restoreCachedSession` is called when SIGNED_OUT event fires while offline. Verify biometric-auth imports from expo-local-authentication and expo-secure-store. Verify no sensitive data is stored in plaintext (all SecureStore, not AsyncStorage for biometric keys).
  </verify>
  <done>
    AuthManager handles signup, signin, signout with offline session persistence. Biometric authentication supports Face ID and Touch ID with passcode fallback. Offline logout prevention works by intercepting SIGNED_OUT events when offline and restoring cached session.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create AuthContext React provider for app-wide auth state</name>
  <files>
    src/contexts/AuthContext.tsx
  </files>
  <action>
    **src/contexts/AuthContext.tsx:**
    Create React Context that wraps AuthManager for component access:

    Define `AuthContextType` interface:
    ```typescript
    interface AuthContextType {
      state: AuthState
      signUp: (data: SignUpData) => Promise<{ error: any | null }>
      signIn: (email: string, password: string) => Promise<{ error: any | null }>
      signOut: () => Promise<void>
      enableBiometrics: () => Promise<void>
      disableBiometrics: () => Promise<void>
      authenticateWithBiometrics: () => Promise<boolean>
      biometricSupport: { isSupported: boolean; isEnrolled: boolean }
    }
    ```

    Create `AuthContext` with `createContext<AuthContextType>`.

    Create `AuthProvider` component:
    1. State: `authState` using `useState<AuthState>` with initial loading state
    2. State: `biometricSupport` using `useState`

    `useEffect` on mount:
    1. Call `authManager.initialize()`
    2. Call `checkBiometricSupport()` and store result
    3. Try to get current session: `authManager.getSession()`
    4. If session exists, get user profile: `authManager.getUserProfile()`
    5. Update authState with session/profile data
    6. Set `isLoading: false`
    7. Set up NetInfo listener to update `isOnline` in state

    Wrap methods (signUp, signIn, signOut) to update authState after each operation.

    `enableBiometrics`:
    1. If user authenticated, call `enableBiometricAuth(state.user.id)`
    2. Handle errors with console.error

    `authenticateWithBiometrics`:
    1. Call biometric-auth `authenticateWithBiometrics()`
    2. If success and session exists, return true
    3. If success but no session, attempt session restoration

    Render: `<AuthContext.Provider value={contextValue}>{children}</AuthContext.Provider>`

    Create `useAuth` hook:
    ```typescript
    export function useAuth() {
      const context = useContext(AuthContext)
      if (!context) throw new Error('useAuth must be used within AuthProvider')
      return context
    }
    ```

    Export `AuthProvider` and `useAuth`.

    IMPORTANT:
    - AuthProvider should be mounted near the root of the app (in App.tsx later)
    - Loading state must be handled (show splash/loading while initializing auth)
    - isOfflineSession flag helps UI show "offline mode" indicator
  </action>
  <verify>
    Run `npx tsc --noEmit` to verify compilation. Verify AuthProvider imports from auth-manager and biometric-auth. Verify useAuth hook throws if used outside provider. Verify AuthState includes isOnline and isOfflineSession flags.
  </verify>
  <done>
    AuthContext provides auth state and methods to all React components. AuthProvider initializes auth on mount, tracks online/offline status, and exposes signup/signin/signout/biometrics. useAuth hook available for any component to access auth state.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- AuthManager prevents logout when offline (SIGNED_OUT event + !isOnline = restoreCachedSession)
- Session cached in AsyncStorage on signin/signup (for offline restoration)
- Biometric auth uses expo-secure-store (not AsyncStorage) for biometric enable flag
- AuthContext exposes: state (with isOnline, isOfflineSession), signUp, signIn, signOut, biometrics
- Role field accessible from user profile (medic/site_manager/admin)
- No encryption keys or sensitive tokens stored in AsyncStorage (only session data per Supabase convention)
</verification>

<success_criteria>
- User can sign up and sign in with email/password (AUTH-01)
- Session persists across app restarts via AsyncStorage cache (AUTH-02)
- Biometric authentication works for Face ID and Touch ID with passcode fallback (AUTH-03)
- Encryption key management uses iOS Keychain (AUTH-04 -- key infra from Plan 03)
- Role-based access via profile role field in JWT claims (AUTH-05)
- Offline logout prevention works (Research Pitfall 2 mitigated)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-04-SUMMARY.md`
</output>
