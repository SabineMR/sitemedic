---
phase: 45-document-upload-profile-storage
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - web/app/api/documents/route.ts
  - web/app/api/documents/upload/route.ts
  - web/app/api/documents/[id]/download/route.ts
  - web/app/api/documents/categories/route.ts
  - web/components/documents/document-upload-dialog.tsx
  - web/components/documents/document-list.tsx
  - web/app/medic/documents/page.tsx
  - web/app/medic/layout.tsx
autonomous: true

must_haves:
  truths:
    - "Medic can upload a PDF or image file from the web dashboard with a selected category and expiry date"
    - "Uploaded file is stored in Supabase medic-documents bucket at {org_id}/{medic_id}/{category_slug}/{filename}"
    - "Upload creates both a documents record and a document_versions record in the database"
    - "When uploading a new version in the same category, the previous version is archived (documents.current_version_id updated, old version_number retained)"
    - "Medic can view all their uploaded documents grouped by category on the /medic/documents page"
    - "Medic can download any uploaded document via a signed URL (private bucket)"
    - "Does not expire toggle hides the date picker and stores null expiry_date"
  artifacts:
    - path: "web/app/api/documents/upload/route.ts"
      provides: "POST endpoint for document upload with versioning logic"
      exports: ["POST"]
    - path: "web/app/api/documents/route.ts"
      provides: "GET endpoint to list documents for a medic"
      exports: ["GET"]
    - path: "web/app/api/documents/[id]/download/route.ts"
      provides: "GET endpoint returning signed URL for private file download"
      exports: ["GET"]
    - path: "web/app/api/documents/categories/route.ts"
      provides: "GET categories list and POST to create custom category"
      exports: ["GET", "POST"]
    - path: "web/app/medic/documents/page.tsx"
      provides: "Medic documents page with upload and list"
      min_lines: 80
    - path: "web/components/documents/document-upload-dialog.tsx"
      provides: "Upload dialog with dropzone, category picker, expiry date"
      min_lines: 100
  key_links:
    - from: "web/components/documents/document-upload-dialog.tsx"
      to: "/api/documents/upload"
      via: "fetch POST with FormData"
      pattern: "fetch.*api/documents/upload"
    - from: "web/app/medic/documents/page.tsx"
      to: "/api/documents"
      via: "fetch GET on mount"
      pattern: "fetch.*api/documents"
    - from: "web/app/api/documents/upload/route.ts"
      to: "supabase.storage.from('medic-documents').upload"
      via: "server-side Supabase storage upload"
      pattern: "storage.*from.*medic-documents.*upload"
    - from: "web/app/api/documents/[id]/download/route.ts"
      to: "supabase.storage.from('medic-documents').createSignedUrl"
      via: "signed URL generation for private bucket"
      pattern: "createSignedUrl"
---

<objective>
Create the web document upload system and API foundation for Phase 45.

Purpose: Medics need to upload compliance documents (insurance, DBS, qualifications, ID) from the web dashboard. This plan creates all API routes (upload, list, download, categories) and the medic-facing documents page with upload dialog, document list, and download capability. The versioning logic (archiving previous versions when uploading a new document in the same category) is implemented server-side in the upload API.

Output: Working document upload flow on the medic web portal at /medic/documents, with 4 API routes, a drag-and-drop upload dialog, and category-grouped document list with download links.
</objective>

<execution_context>
@/Users/sabineresoagli/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sabineresoagli/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/45-document-upload-profile-storage/45-CONTEXT.md
@.planning/phases/45-document-upload-profile-storage/45-RESEARCH.md
@.planning/phases/40-comms-docs-foundation/40-02-SUMMARY.md

Key references (read these for patterns):
@web/types/comms.types.ts — DocumentCategory, Document, DocumentVersion, DocumentWithVersion types
@web/app/api/messages/send/route.ts — API route pattern (createClient, requireOrgId, auth check)
@web/app/api/messages/conversations/route.ts — POST API pattern with validation
@web/app/medic/profile/page.tsx — Medic portal page pattern (dark theme, client component, supabase client)
@web/app/medic/layout.tsx — Medic sidebar nav items (add Documents here)

Schema reference (from migration 143):
- document_categories: id, org_id, name, slug, is_required, is_active, sort_order — UNIQUE(org_id, slug)
- documents: id, org_id, medic_id, category_id, current_version_id, status (pending|approved|rejected|expired|archived)
- document_versions: id, document_id, org_id, storage_path, file_name, file_size_bytes, mime_type, issue_date, expiry_date, certificate_number, notes, version_number, uploaded_by

Storage bucket: medic-documents (PRIVATE, 10MB limit, path: {org_id}/{medic_id}/{category_slug}/{filename})
For private bucket downloads: MUST use createSignedUrl() — getPublicUrl() will NOT work.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create document API routes</name>
  <files>
    web/app/api/documents/route.ts
    web/app/api/documents/upload/route.ts
    web/app/api/documents/[id]/download/route.ts
    web/app/api/documents/categories/route.ts
  </files>
  <action>
Create 4 API route files following the existing pattern from web/app/api/messages/send/route.ts (createClient from @/lib/supabase/server, requireOrgId from @/lib/organizations/org-resolver, auth check, NextResponse.json).

**GET /api/documents/categories/route.ts:**
- GET handler: fetch all document_categories for the user's org where is_active=true, ordered by sort_order
- POST handler: create a custom category (org_admin role only). Accept { name: string }. Auto-generate slug from name (lowercase, hyphens). Compute next sort_order. Return 201 with new category. Check for duplicate slug with 409 response.

**POST /api/documents/upload/route.ts:**
- Accept multipart FormData with fields: file (File), categoryId (string), expiryDate (string|null — null means "does not expire"), certificateNumber (string|null), notes (string|null)
- Use `await request.formData()` to parse
- Validate: file must be PDF, JPEG, or PNG (check mime type); file size <= 10MB; categoryId must exist in document_categories for this org
- Look up medic record for current user (supabase.from('medics').select('id').eq('user_id', user.id).eq('org_id', orgId).single())
- **Versioning logic:**
  1. Query existing documents for this medic + categoryId: `supabase.from('documents').select('id, current_version_id').eq('medic_id', medicId).eq('category_id', categoryId)` — NOTE: CONTEXT says multiple documents per category allowed. So ONLY archive if the user explicitly sends a `replaceDocumentId` field in the FormData. If replaceDocumentId is provided, that specific document gets a new version. Otherwise create a fresh document record.
  2. If replaceDocumentId provided: get current max version_number for that document, increment by 1. The old version stays in document_versions (not deleted). Upload file to storage. Insert new document_versions row. Update documents.current_version_id to new version id.
  3. If no replaceDocumentId: create new documents record (status='pending'), then create document_versions record (version_number=1), then update documents.current_version_id.
- Storage upload path: `${orgId}/${medicId}/${categorySlug}/${Date.now()}-${sanitizedFileName}` (timestamp prefix prevents collisions)
- Upload file to Supabase storage using the server-side admin client: `supabase.storage.from('medic-documents').upload(storagePath, fileBuffer, { contentType: file.type, upsert: false })`
- Return 201 with the created document and version records
- Wrap entire operation in try/catch, return 500 on failure

**GET /api/documents/route.ts:**
- Accept optional query param `medicId` (for admin viewing another medic's documents)
- If no medicId provided, resolve from current user's medic record
- If medicId provided, verify admin role (user.app_metadata.role === 'org_admin' or 'platform_admin')
- Query documents with current version joined: `supabase.from('documents').select('*, document_versions!documents_current_version_id_fkey(*), document_categories!documents_category_id_fkey(name, slug)').eq('medic_id', resolvedMedicId).eq('org_id', orgId).neq('status', 'archived').order('created_at', { ascending: false })`
- If the FK join names don't work, use separate queries: fetch documents, then fetch current versions and categories by ID
- Return array of documents with nested current_version and category info

**GET /api/documents/[id]/download/route.ts:**
- Dynamic route with `params: Promise<{ id: string }>`
- Fetch the document_version for the given document id (use documents.current_version_id to get the active version, or accept optional `versionId` query param for archived versions)
- Get storage_path from the version record
- Generate signed URL: `supabase.storage.from('medic-documents').createSignedUrl(storagePath, 3600)` (1-hour expiry)
- Return JSON with `{ url: signedUrl, fileName: version.file_name }`
- Verify document belongs to user's org via org_id check

All routes must have `export const dynamic = 'force-dynamic';`
  </action>
  <verify>
Run `cd /Users/sabineresoagli/GitHub/sitemedic && npx tsc --noEmit --project web/tsconfig.json 2>&1 | head -40` to check for TypeScript compilation errors in the new files. All 4 route files should compile without type errors.
  </verify>
  <done>
4 API route files exist and compile: GET /api/documents (list), POST /api/documents/upload (upload with versioning), GET /api/documents/[id]/download (signed URL), GET+POST /api/documents/categories (list and create categories). Versioning logic archives previous version when replaceDocumentId is provided.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create medic documents page and upload dialog</name>
  <files>
    web/components/documents/document-upload-dialog.tsx
    web/components/documents/document-list.tsx
    web/app/medic/documents/page.tsx
    web/app/medic/layout.tsx
  </files>
  <action>
**web/components/documents/document-upload-dialog.tsx:**
Create a client component ('use client') for the upload dialog. Use the medic portal dark theme (bg-gray-800/50 border-gray-700/50 rounded-2xl pattern from medic/profile/page.tsx).

Dialog structure (use a modal overlay, NOT shadcn Dialog since medic portal doesn't use shadcn):
- Trigger: "Upload Document" button (green accent matching medic portal)
- State: open/closed, uploading boolean, selected file, preview URL, category, expiryDate, doesNotExpire toggle, certificateNumber, notes, replaceDocumentId (optional)
- **File dropzone:** A div with dashed border that accepts drag-and-drop AND click-to-browse. Accept PDF, JPEG, PNG only. Max 10MB. Show file name + size after selection. Show image thumbnail preview for JPEG/PNG, PDF icon for PDFs. Use native HTML input[type=file] with accept=".pdf,.jpg,.jpeg,.png"
- **Category picker:** Dropdown/select populated from GET /api/documents/categories. Show category name.
- **Expiry date:** Date input. Hidden when "Does not expire" checkbox is checked. When checkbox checked, expiryDate = null.
- **Certificate number:** Optional text input
- **Notes:** Optional textarea
- **Replace existing:** If opened from a document's "Upload New Version" action, pre-set replaceDocumentId and category (category is locked/disabled)
- **Submit:** POST to /api/documents/upload with FormData. Show loading spinner. On success: toast.success('Document uploaded'), close dialog, call onUploadComplete callback to refresh list. On error: toast.error with message.
- **Batch support:** "Add another" button after successful upload that resets the form but keeps the dialog open. Each file uploaded sequentially.

Props: `{ onUploadComplete: () => void, replaceDocumentId?: string, presetCategoryId?: string }`

**web/components/documents/document-list.tsx:**
Create a client component for displaying documents grouped by category.

Props: `{ documents: DocumentWithVersion[], categories: DocumentCategory[], onUploadVersion: (documentId: string, categoryId: string) => void }`

Layout:
- Group documents by category_id, render each category as a section with the category name as heading
- For categories with no documents, show "No documents uploaded" in muted text
- Each document row shows: file_name, file type icon (PDF/image), expiry_date (formatted with date-fns, or "No expiry"), version_number badge, uploaded date
- Action buttons per document: "Download" (calls GET /api/documents/{id}/download, then window.open(url)), "Upload New Version" (calls onUploadVersion with documentId and categoryId)
- **Version history:** Expandable section per document (chevron toggle). When expanded, fetch all document_versions for that document_id from the API (or pass them in). Show version_number, file_name, uploaded date, expiry_date for each archived version. Each archived version has a download link.
- Style: dark theme cards matching medic portal. Use Lucide icons (FileText for PDF, Image for images, Download, Upload, ChevronDown/ChevronUp, Clock for dates).

**web/app/medic/documents/page.tsx:**
Create a client component page ('use client').
- On mount: fetch categories from GET /api/documents/categories AND documents from GET /api/documents (parallel Promise.all)
- State: documents array, categories array, loading boolean, uploadDialogOpen, replaceTarget (documentId + categoryId for version replacement)
- Layout:
  - Header: "My Documents" title with "Upload Document" button (green)
  - Below header: DocumentList component showing all documents
  - DocumentUploadDialog controlled by state
- When upload completes: re-fetch documents list
- Loading state: spinner matching medic portal pattern
- Empty state: "No documents uploaded yet. Upload your compliance documents to get started."

**web/app/medic/layout.tsx:**
Add a new nav item to the navItems array:
```
{ name: 'Documents', href: '/medic/documents', icon: <FileText className="w-5 h-5" /> }
```
Place it after "Payslips" and before "My Profile" in the nav order. Import FileText from lucide-react (it may already be imported — check first, FileText is already in the imports).
  </action>
  <verify>
1. Run `cd /Users/sabineresoagli/GitHub/sitemedic && npx tsc --noEmit --project web/tsconfig.json 2>&1 | head -40` — should compile without errors
2. Run `cd /Users/sabineresoagli/GitHub/sitemedic/web && pnpm dev &` and visit http://localhost:30500/medic/documents — page should load without errors (verify in terminal output, no React errors)
  </verify>
  <done>
Medic portal has a "Documents" nav item in the sidebar. The /medic/documents page loads showing categories and any existing documents. The upload dialog opens with drag-and-drop file zone, category picker, expiry date with "does not expire" toggle, and submits to the upload API. Successful upload refreshes the document list. Each document has download and "Upload New Version" actions.
  </done>
</task>

</tasks>

<verification>
1. Navigate to /medic/documents as a medic user — page loads with category sections
2. Upload a PDF document selecting "Insurance" category and an expiry date — file appears in the list under Insurance
3. Upload an image (JPEG/PNG) with "Does not expire" checked — appears with "No expiry" label
4. Click Download on an uploaded document — browser opens/downloads the file via signed URL
5. Click "Upload New Version" on a document — dialog opens with category pre-set, upload completes, version number increments to 2
6. Expand version history — shows both version 1 and version 2 with download links for each
7. Verify file exists in Supabase Storage at correct path: {org_id}/{medic_id}/{category_slug}/{timestamp}-{filename}
</verification>

<success_criteria>
- Medic can upload PDF and image documents from the web dashboard
- Documents are categorised by type (Insurance, DBS, Qualification, ID, Other)
- Expiry date entry works with "does not expire" toggle
- Versioning works: new version archives previous, version history visible
- Download returns working signed URL for private bucket files
- All files compile without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/45-document-upload-profile-storage/45-01-SUMMARY.md`
</output>
