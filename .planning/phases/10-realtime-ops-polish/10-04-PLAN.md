---
phase: 10-realtime-ops-polish
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - web/components/admin/AlertPanel.tsx
autonomous: true

must_haves:
  truths:
    - "Dismissing an alert shows a text input for notes before confirming"
    - "Resolving an alert shows a text input for notes before confirming"
    - "Dismiss/resolve notes are passed to the store actions and persisted to medic_alerts table"
    - "Admin can select multiple non-critical alerts and bulk dismiss them"
    - "Bulk dismiss is restricted to low/medium severity only — critical and high are never bulk-dismissable"
  artifacts:
    - path: "web/components/admin/AlertPanel.tsx"
      provides: "Note inputs on dismiss/resolve, bulk dismiss UI with severity filter"
      contains: "selectedIds"
  key_links:
    - from: "AlertPanel dismiss confirm"
      to: "useMedicAlertsStore.dismissAlert(id, notes)"
      via: "dismissNote state passed as second arg"
      pattern: "dismissAlert.*note"
    - from: "AlertPanel bulk dismiss"
      to: "Promise.all(ids.map(id => dismissAlert(id, 'Bulk dismissed')))"
      via: "selectedIds filtered to low/medium only"
      pattern: "Promise\\.all.*dismissAlert"
---

<objective>
Wire the existing dismiss/resolve note state in AlertPanel to the store actions end-to-end, and add bulk dismiss for non-critical alerts.

Purpose: Alert dismissals currently have no audit trail. Admins need to record WHY an alert was dismissed or resolved. Bulk dismiss reduces triage fatigue for routine low-severity alerts.
Output: Updated `AlertPanel.tsx` with working note inputs and bulk dismiss UI.
</objective>

<execution_context>
@/Users/sabineresoagli/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sabineresoagli/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-realtime-ops-polish/10-RESEARCH.md

@web/components/admin/AlertPanel.tsx
@web/stores/useMedicAlertsStore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Ensure dismiss/resolve note inputs work end-to-end</name>
  <files>web/components/admin/AlertPanel.tsx</files>
  <action>
  The `AlertPanel.tsx` already has `dismissNote` and `resolveNote` state (line 14-15). Verify and complete the end-to-end wiring:

  1. **Verify the dismiss flow:** When admin clicks "Dismiss" on an alert:
     - A text input should appear for the dismissal note
     - A "Confirm Dismiss" button should call `dismissAlert(alertId, noteText)`
     - The `dismissAlert` in `useMedicAlertsStore` already accepts `notes?: string` and writes to `dismissal_notes` column

  2. **Verify the resolve flow:** Same pattern for resolve:
     - Text input for resolution note
     - "Confirm Resolve" calls `resolveAlert(alertId, noteText)`
     - The `resolveAlert` in store already accepts `notes?: string` and writes to `resolution_notes` column

  3. **If the note input is already visible** in the existing two-step confirm flow, ensure:
     - The note text is actually passed to `dismissAlert(id, note)` and `resolveAlert(id, note)` — not just stored in local state
     - After confirm, the local note state is reset to null
     - The input has a placeholder like "Add a note (optional)..." for dismiss, "Resolution details..." for resolve

  4. **If the note input is NOT yet rendered** in the JSX (only state exists), add:
     ```tsx
     {dismissNote?.alertId === alert.id && (
       <div className="mt-2 space-y-2">
         <textarea
           value={dismissNote.note}
           onChange={(e) => setDismissNote({ alertId: alert.id, note: e.target.value })}
           placeholder="Reason for dismissal (optional)..."
           className="w-full rounded border border-gray-300 p-2 text-sm"
           rows={2}
         />
         <div className="flex gap-2">
           <button
             onClick={() => {
               dismissAlert(alert.id, dismissNote.note || undefined);
               setDismissNote(null);
             }}
             className="rounded bg-gray-600 px-3 py-1 text-sm text-white hover:bg-gray-700"
           >
             Confirm Dismiss
           </button>
           <button
             onClick={() => setDismissNote(null)}
             className="rounded border border-gray-300 px-3 py-1 text-sm text-gray-600 hover:bg-gray-50"
           >
             Cancel
           </button>
         </div>
       </div>
     )}
     ```
     Apply the same pattern for `resolveNote`.

  Read the full AlertPanel.tsx first to understand the existing dismiss/resolve flow before making changes. The goal is minimal changes — wire what exists, add what's missing.
  </action>
  <verify>
  1. Grep for dismissAlert call with notes: `grep -n "dismissAlert.*note\|dismissAlert.*Note" web/components/admin/AlertPanel.tsx` — should show notes being passed
  2. Grep for resolveAlert call with notes: `grep -n "resolveAlert.*note\|resolveAlert.*Note" web/components/admin/AlertPanel.tsx` — should show notes being passed
  3. Grep for textarea: `grep -n "textarea" web/components/admin/AlertPanel.tsx` — should show note input fields
  </verify>
  <done>
  - Dismiss flow: click Dismiss -> note input appears -> Confirm Dismiss calls dismissAlert(id, note)
  - Resolve flow: click Resolve -> note input appears -> Confirm Resolve calls resolveAlert(id, note)
  - Notes are passed to store actions (not just stored locally)
  - Note state resets after confirm
  </done>
</task>

<task type="auto">
  <name>Task 2: Add bulk dismiss for non-critical alerts</name>
  <files>web/components/admin/AlertPanel.tsx</files>
  <action>
  Add bulk dismiss functionality to AlertPanel.tsx:

  1. **Add selection state:**
     ```typescript
     const [selectedIds, setSelectedIds] = useState<Set<string>>(new Set());
     const [bulkDismissing, setBulkDismissing] = useState(false);
     ```

  2. **Add checkbox to each non-critical alert card.** Only show checkboxes for alerts with `alert_severity === 'low'` or `alert_severity === 'medium'`:
     ```tsx
     {(alert.alert_severity === 'low' || alert.alert_severity === 'medium') && (
       <input
         type="checkbox"
         checked={selectedIds.has(alert.id)}
         onChange={(e) => {
           const next = new Set(selectedIds);
           if (e.target.checked) next.add(alert.id);
           else next.delete(alert.id);
           setSelectedIds(next);
         }}
         className="h-4 w-4 rounded border-gray-300"
       />
     )}
     ```

  3. **Add bulk action bar** at the top of the alert list (shown only when selections exist):
     ```tsx
     {selectedIds.size > 0 && (
       <div className="flex items-center justify-between rounded-lg border border-gray-200 bg-gray-50 p-3">
         <span className="text-sm font-medium text-gray-700">
           {selectedIds.size} non-critical alert{selectedIds.size !== 1 ? 's' : ''} selected
         </span>
         <div className="flex gap-2">
           <button
             onClick={handleBulkDismiss}
             disabled={bulkDismissing}
             className="rounded bg-gray-600 px-3 py-1.5 text-sm text-white hover:bg-gray-700 disabled:opacity-50"
           >
             {bulkDismissing ? 'Dismissing...' : `Dismiss ${selectedIds.size} alert${selectedIds.size !== 1 ? 's' : ''}`}
           </button>
           <button
             onClick={() => setSelectedIds(new Set())}
             className="rounded border border-gray-300 px-3 py-1.5 text-sm text-gray-600 hover:bg-gray-50"
           >
             Clear Selection
           </button>
         </div>
       </div>
     )}
     ```

  4. **Add "Select All Non-Critical" convenience button** near the bulk action bar:
     ```typescript
     const nonCriticalAlerts = alerts.filter(
       a => !a.is_dismissed && (a.alert_severity === 'low' || a.alert_severity === 'medium')
     );

     const handleSelectAllNonCritical = () => {
       setSelectedIds(new Set(nonCriticalAlerts.map(a => a.id)));
     };
     ```

  5. **Implement handleBulkDismiss:**
     ```typescript
     const handleBulkDismiss = async () => {
       setBulkDismissing(true);
       try {
         await Promise.all(
           Array.from(selectedIds).map(id => dismissAlert(id, 'Bulk dismissed'))
         );
         setSelectedIds(new Set());
       } finally {
         setBulkDismissing(false);
       }
     };
     ```

  6. **Clear selection when alerts change** (dismissed alerts disappear from list):
     ```typescript
     useEffect(() => {
       // Remove selected IDs that are no longer in the active alerts list
       const activeIds = new Set(alerts.map(a => a.id));
       setSelectedIds(prev => {
         const next = new Set([...prev].filter(id => activeIds.has(id)));
         return next.size === prev.size ? prev : next;
       });
     }, [alerts]);
     ```

  **CRITICAL:** Never include `critical` or `high` severity alerts in bulk operations. The checkbox is only rendered for `low` and `medium`. The "Select All Non-Critical" button filters to these severities.
  </action>
  <verify>
  1. Run `pnpm --filter web build` — no TypeScript errors
  2. Grep for selectedIds: `grep -n "selectedIds" web/components/admin/AlertPanel.tsx` — should show Set state and usage
  3. Grep for bulk dismiss: `grep -n "Bulk dismiss\|handleBulkDismiss\|bulkDismiss" web/components/admin/AlertPanel.tsx` — should show handler and UI
  4. Grep for severity filter: `grep -n "low.*medium\|non-critical\|nonCritical" web/components/admin/AlertPanel.tsx` — should show severity filtering
  </verify>
  <done>
  - Checkboxes appear on low/medium severity alerts only
  - "Select All Non-Critical" button selects all low/medium undismissed alerts
  - Bulk action bar shows count and "Dismiss N alerts" button
  - Bulk dismiss calls Promise.all with 'Bulk dismissed' note for each
  - Critical and high severity alerts are never bulk-dismissable
  - Selection clears after bulk dismiss completes
  </done>
</task>

</tasks>

<verification>
- `pnpm --filter web build` passes
- Dismiss/resolve notes are passed to store actions end-to-end
- Bulk dismiss restricted to low/medium severity
- Bulk action bar shows selection count
</verification>

<success_criteria>
Dismissing an alert prompts for a note and persists it. Bulk dismiss works for non-critical alerts only, with a clear count indicator.
</success_criteria>

<output>
After completion, create `.planning/phases/10-realtime-ops-polish/10-04-SUMMARY.md`
</output>
