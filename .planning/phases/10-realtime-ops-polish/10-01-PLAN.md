---
phase: 10-realtime-ops-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - web/stores/useMedicLocationsStore.ts
autonomous: true

must_haves:
  truths:
    - "Each medic location ping in the store includes medic_name, site_name, shift_start_time, and shift_end_time"
    - "Context is fetched once at subscribe time, not on every ping (no N+1)"
    - "Medics with confirmed or in_progress bookings today appear in the context Map"
  artifacts:
    - path: "web/stores/useMedicLocationsStore.ts"
      provides: "medicContext Map with joined medic+booking data, updated subscribe() and updateLocation()"
      contains: "medicContext"
  key_links:
    - from: "web/stores/useMedicLocationsStore.ts"
      to: "supabase.from('bookings').select(...medics!inner...)"
      via: "joined query at subscribe time"
      pattern: "medics!inner"
    - from: "useMedicLocationsStore subscribe handler"
      to: "medicContext.get(ping.medic_id)"
      via: "context lookup on each realtime ping"
      pattern: "medicContext\\.get"
---

<objective>
Resolve the TODO at useMedicLocationsStore.ts:153 — join medic name, booking site, and shift times to each location ping so map markers can display real context instead of anonymous dots.

Purpose: The command centre map currently shows anonymous coordinate dots. Admins need to see "Kai Jensen — Royal Exchange Site, 07:00-15:00" on each marker. This plan provides the data layer; Plan 10-02 renders it.
Output: Updated `useMedicLocationsStore.ts` with `medicContext` Map populated at subscribe time, merged into each location update.
</objective>

<execution_context>
@/Users/sabineresoagli/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sabineresoagli/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-realtime-ops-polish/10-RESEARCH.md

@web/stores/useMedicLocationsStore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add medicContext Map and initial join query to useMedicLocationsStore</name>
  <files>web/stores/useMedicLocationsStore.ts</files>
  <action>
  Modify `useMedicLocationsStore.ts` to add a `medicContext` Map and populate it at subscribe time:

  1. **Define MedicContextEntry type** (add near the top of the file):
     ```typescript
     interface MedicContextEntry {
       medic_name: string;
       booking_id: string;
       site_name: string;
       shift_start_time: string;  // "07:00:00" from PostgreSQL TIME
       shift_end_time: string;    // "15:00:00"
       medic_phone: string | null;
     }
     ```

  2. **Add to store state**:
     - `medicContext: Map<string, MedicContextEntry>` — initialized as `new Map()`

  3. **In the `subscribe()` action**, BEFORE subscribing to the Realtime channel, add an initial fetch query:
     ```typescript
     const { data: bookings } = await supabase
       .from('bookings')
       .select(`
         id,
         site_name,
         shift_start_time,
         shift_end_time,
         medic_id,
         medics!inner (
           first_name,
           last_name,
           phone
         )
       `)
       .in('status', ['confirmed', 'in_progress'])
       .eq('shift_date', new Date().toISOString().split('T')[0]);
     ```
     Use `.in('status', ['confirmed', 'in_progress'])` — NOT just 'in_progress'. This avoids Pitfall 1 from research: if a medic's booking is still 'confirmed' (shift not yet started), their context would be missing and the `isFullLocation` guard would reject their pings.

  4. **Build the medicContext Map** from the query results:
     ```typescript
     const medicContext = new Map<string, MedicContextEntry>();
     (bookings ?? []).forEach((b: any) => {
       if (b.medic_id && b.medics) {
         medicContext.set(b.medic_id, {
           medic_name: `${b.medics.first_name} ${b.medics.last_name}`,
           booking_id: b.id,
           site_name: b.site_name,
           shift_start_time: b.shift_start_time,
           shift_end_time: b.shift_end_time,
           medic_phone: b.medics.phone,
         });
       }
     });
     set({ medicContext });
     ```

  5. **Update the Realtime ping handler** (at line ~145-154, the TODO location). Replace the current updateLocation call to merge context:
     ```typescript
     const context = get().medicContext.get(ping.medic_id);
     get().updateLocation(ping.medic_id, {
       medic_id: ping.medic_id,
       latitude: ping.latitude,
       longitude: ping.longitude,
       accuracy_meters: ping.accuracy_meters,
       battery_level: ping.battery_level,
       connection_type: ping.connection_type,
       recorded_at: ping.recorded_at,
       medic_name: context?.medic_name ?? 'Unknown Medic',
       booking_id: context?.booking_id ?? ping.booking_id,
       site_name: context?.site_name ?? 'Unknown Site',
       shift_start_time: context?.shift_start_time,
       shift_end_time: context?.shift_end_time,
     });
     ```
     Remove the `// TODO: Fetch medic name and booking details from joined query` comment.

  6. **Ensure the MedicLocation interface** (either in this file or in MedicTrackingMap.tsx) includes the two new optional fields:
     - `shift_start_time?: string`
     - `shift_end_time?: string`
     Check where the MedicLocation type is defined — if in this store file, add the fields here. If in MedicTrackingMap.tsx, that will be handled in Plan 10-02. Add the fields wherever the interface is defined.

  **IMPORTANT — Photo is descoped:** The `medics` table has NO `photo`/`avatar` column (verified in research). Do NOT include photo in the query or the interface. This is deferred to a future phase.

  **DO NOT:**
  - Query medic/booking data inside the Realtime ping handler (N+1 anti-pattern)
  - Use `status = 'in_progress'` only (misses not-yet-started shifts)
  - Add a photo field (column does not exist)
  </action>
  <verify>
  1. Run `pnpm --filter web build` from the project root — no TypeScript errors
  2. Grep for the TODO comment: `grep -n "TODO.*Fetch medic name" web/stores/useMedicLocationsStore.ts` — should return no results
  3. Grep for medicContext: `grep -n "medicContext" web/stores/useMedicLocationsStore.ts` — should show Map declaration, population, and lookup
  4. Grep for the join query: `grep -n "medics!inner" web/stores/useMedicLocationsStore.ts` — should show the Supabase join
  </verify>
  <done>
  - The TODO at line 153 is resolved
  - `medicContext` Map is populated at subscribe time with a single joined query
  - Each Realtime ping merges medic_name, site_name, shift_start_time, shift_end_time from the context Map
  - No N+1 queries — context is fetched once
  - Photo is excluded (no column exists)
  - TypeScript builds without errors
  </done>
</task>

</tasks>

<verification>
- `pnpm --filter web build` passes with no TypeScript errors
- The TODO comment at line 153 no longer exists
- `medicContext` Map is populated from a joined bookings+medics query
- The Realtime ping handler merges context into each location update
</verification>

<success_criteria>
The useMedicLocationsStore now provides enriched location data (medic_name, site_name, shift times) to any consumer, enabling Plan 10-02 to display it on map markers.
</success_criteria>

<output>
After completion, create `.planning/phases/10-realtime-ops-polish/10-01-SUMMARY.md`
</output>
