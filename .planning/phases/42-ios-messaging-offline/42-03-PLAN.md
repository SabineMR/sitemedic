---
phase: 42-ios-messaging-offline
plan: 03
type: execute
wave: 3
depends_on: ["42-02"]
files_modified:
  - src/services/MessageSync.ts
  - src/components/messaging/MessageThread.tsx
  - src/components/messaging/MessageItem.tsx
  - src/components/messaging/MessageInput.tsx
  - src/components/messaging/ConversationList.tsx
  - src/contexts/SyncContext.tsx
autonomous: false

must_haves:
  truths:
    - "When the device is offline, previously synced conversations and messages are still viewable"
    - "When the device is offline, a medic can compose and send a message that appears locally with queued status"
    - "When connectivity returns, queued messages are automatically pushed to Supabase and their status updates to sent"
    - "No duplicate messages are created on the server when a queued message is retried"
    - "When connectivity returns, new messages from other users are pulled from Supabase"
  artifacts:
    - path: "src/services/MessageSync.ts"
      provides: "Enhanced push sync with retry, deduplication, and connectivity-triggered sync"
      min_lines: 100
    - path: "src/components/messaging/MessageItem.tsx"
      provides: "Queued message styling (greyed out + clock icon)"
      min_lines: 30
  key_links:
    - from: "src/services/MessageSync.ts"
      to: "src/services/NetworkMonitor.ts"
      via: "NetworkMonitor listener triggers push+pull on reconnect"
      pattern: "networkMonitor\\.addListener|onConnected"
    - from: "src/components/messaging/MessageInput.ts"
      to: "src/services/MessageSync.ts"
      via: "Send creates local record, triggers pushPendingMessages"
      pattern: "pushPendingMessages"
    - from: "src/services/MessageSync.ts"
      to: "supabase"
      via: "Idempotency key prevents duplicate inserts"
      pattern: "idempotency_key|23505"
---

<objective>
Harden the offline messaging experience: ensure queued messages are styled distinctly, automatically delivered on reconnect with deduplication, and pull sync fires on connectivity changes. Verify the full offline round-trip works end-to-end.

Purpose: This completes the offline promise of Phase 42. Plans 42-01 and 42-02 built the data layer and UI, but without explicit reconnect handling, retry logic, and deduplication, the offline experience could produce duplicate messages or silently fail. This plan closes those gaps.

Output: A reliable offline messaging experience where queued messages are visually distinct, automatically delivered when connectivity returns, and never duplicated on the server.
</objective>

<execution_context>
@/Users/sabineresoagli/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sabineresoagli/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/42-ios-messaging-offline/42-CONTEXT.md
@.planning/phases/42-ios-messaging-offline/42-RESEARCH.md
@.planning/phases/42-ios-messaging-offline/42-01-SUMMARY.md
@.planning/phases/42-ios-messaging-offline/42-02-SUMMARY.md

# Files to enhance from Plans 42-01 and 42-02:
@src/services/MessageSync.ts
@src/services/NetworkMonitor.ts
@src/services/SyncQueue.ts
@src/contexts/SyncContext.tsx
@src/components/messaging/MessageThread.tsx
@src/components/messaging/MessageItem.tsx
@src/components/messaging/MessageInput.tsx
@src/components/messaging/ConversationList.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add connectivity-triggered message sync, retry with deduplication, and offline UI indicators</name>
  <files>
    src/services/MessageSync.ts
    src/contexts/SyncContext.tsx
    src/components/messaging/MessageThread.tsx
    src/components/messaging/MessageItem.tsx
    src/components/messaging/MessageInput.tsx
    src/components/messaging/ConversationList.tsx
  </files>
  <action>
  **Enhance MessageSync.ts -- connectivity-triggered sync:**
  - Add a `startAutoSync(userId: string, orgId: string)` method that registers a NetworkMonitor listener:
    ```typescript
    networkMonitor.addListener((isOnline) => {
      if (isOnline) {
        // Push first (send queued messages), then pull (receive new messages)
        this.pushPendingMessages().then(() => this.pullSync(userId, orgId))
      }
    })
    ```
  - Add a `stopAutoSync()` method that unsubscribes the listener
  - Call `startAutoSync` from SyncContext when user is authenticated (in the useEffect that starts network monitoring)
  - Call `stopAutoSync` in the cleanup function

  **Enhance MessageSync.ts -- pushPendingMessages with deduplication:**
  - When POSTing a queued message to Supabase, include the `idempotency_key` in the message metadata (or as a separate column if the messages table has one -- check: it does NOT have an idempotency_key column, so use the `metadata` JSONB field):
    ```typescript
    supabase.from('messages').insert({
      conversation_id: serverConversationId,
      org_id: message.orgId,
      sender_id: message.senderId,
      message_type: 'text',
      content: message.content,
      status: 'sent',
      metadata: { idempotency_key: message.idempotencyKey }
    })
    ```
  - On duplicate detection: before inserting, do a SELECT to check if a message with the same idempotency_key already exists in metadata:
    ```typescript
    const { data: existing } = await supabase
      .from('messages')
      .select('id')
      .eq('conversation_id', serverConversationId)
      .contains('metadata', { idempotency_key: message.idempotencyKey })
      .maybeSingle()
    ```
  - If `existing` is found, treat as success: update local message server_id and status to 'sent', skip the INSERT
  - If INSERT fails with any error, leave status as 'queued' -- it will retry on next pushPendingMessages call
  - Add retry limiting: if a queued message has been retried 10+ times (track via a `retry_count` field -- but Message model may not have this; instead, compare message.created_at to now and skip messages older than 24 hours as permanently failed, logging a warning)
  - For permanently failed messages (>24 hours old, still queued), update status to 'failed'

  **Enhance MessageSync.ts -- pull sync on reconnect:**
  - `pullSync` already handles incremental sync via `lastSyncedAt`
  - Verify that on reconnect, pullSync correctly fetches messages received while offline
  - After pulling new messages, recompute unread_count for affected conversations:
    ```typescript
    // For each conversation that got new messages:
    // Count messages where sender_id != userId AND created_at > conversation.last_read_at
    // Update conversation.unread_count
    ```

  **Enhance MessageItem.tsx -- queued and failed message styling:**
  - Messages with `status === 'queued'`:
    - Render entire row at `opacity: 0.5`
    - Show a small clock icon (Unicode: \u{1F552} or use a simple "..." text) below the timestamp
    - Or use a more subtle approach: add a small grey "Sending..." label below the timestamp
  - Messages with `status === 'failed'`:
    - Render with `opacity: 0.5` and a red "Failed to send" label
    - Add a "Tap to retry" text that, on press, resets the message status back to 'queued' and calls `messageSync.pushPendingMessages()`
  - Messages with `status === 'sent'` or `status === 'delivered'` or `status === 'read'`:
    - Render normally (full opacity, no extra labels)

  **Enhance MessageInput.tsx -- offline awareness:**
  - Import and use `useSync()` from SyncContext to check `state.isOnline`
  - When offline, still allow sending (this is the whole point of offline messaging)
  - Show a subtle banner at the top of the input area: "You're offline. Messages will be sent when you reconnect." (View with backgroundColor '#FEF3C7' / amber-100, small text, 28px height)
  - The banner appears only when `state.isOnline === false`
  - When back online, the banner disappears automatically (reactive via useSync state)

  **Enhance ConversationList.tsx -- offline indicator:**
  - When offline (via useSync), show a subtle banner at the top of the conversation list: "Offline - showing cached messages" (same amber style as MessageInput offline banner)
  - Pull-to-refresh should still work when online (already implemented in 42-02)
  - When offline, pull-to-refresh should show a brief message "Can't sync while offline" and complete the refresh without error

  **Enhance MessageThread.tsx -- scroll-to-new-message on send:**
  - After a new message is created (observed via WatermelonDB query update), scroll to the bottom of the FlatList
  - Since the FlatList is inverted, "bottom" is actually index 0 -- use `flatListRef.current?.scrollToIndex({ index: 0, animated: true })` or `scrollToOffset({ offset: 0, animated: true })`
  </action>
  <verify>
  - When device goes offline, the offline banner appears in both ConversationList and MessageInput
  - Sending a message while offline creates a local record with status='queued' that renders with reduced opacity
  - When connectivity returns, queued messages are automatically pushed to Supabase
  - After push, the message status updates from 'queued' to 'sent' and renders at full opacity
  - No duplicate messages appear on the server (verify by checking idempotency_key in metadata)
  - After reconnect, new messages from other users appear in the conversation thread
  - Messages older than 24 hours that are still queued get marked as 'failed' with a retry option
  </verify>
  <done>
  Offline messaging is complete: queued messages render at half opacity with "Sending..." indicator, automatically push to Supabase when connectivity returns (with idempotency_key deduplication via metadata field), and update to full opacity on success. Failed messages (>24h old) show "Failed to send - Tap to retry". NetworkMonitor triggers push+pull sync on reconnect. Offline banners appear on ConversationList and MessageInput when device is offline.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
  Full iOS messaging with offline support:
  1. Messages tab in the iOS app bottom bar
  2. Conversation list with unread badges, pull-to-refresh
  3. Message thread with flat Slack-style layout, Return-to-send
  4. Offline: queued messages appear greyed out with clock indicator
  5. Reconnect: queued messages auto-deliver, new messages pulled from server
  6. Start new conversation via "Message Admin" button
  </what-built>
  <how-to-verify>
  Test on iOS simulator or device:

  1. **Conversation list**: Open the Messages tab. If you have conversations from the web dashboard, they should appear after pull-to-refresh. If no conversations exist, you should see the EmptyState with "Message Admin" button.

  2. **Send a message**: Tap a conversation (or create one via "Message Admin"). Type a message. Press Return key -- the message should appear immediately. Try the Send button too.

  3. **Cross-platform sync**: Send a message from iOS. Refresh the web dashboard Messages page. The message should appear. Send a reply from web. Pull-to-refresh on iOS. The reply should appear.

  4. **Offline queue**: Enable Airplane Mode on the device/simulator. Send a message. It should appear greyed out with "Sending..." indicator. Disable Airplane Mode. Within a few seconds, the message should transition to full opacity (sent). Check the web dashboard -- the message should be there.

  5. **Offline viewing**: While on Airplane Mode, previously synced conversations and messages should still be viewable (loaded from WatermelonDB cache).

  6. **Offline banner**: While on Airplane Mode, the conversation list and message input should show "Offline" banners.
  </how-to-verify>
  <resume-signal>Type "approved" if messaging works cross-platform and offline queue delivers correctly, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
1. Queued messages render at half opacity with "Sending..." indicator
2. When connectivity returns, queued messages auto-push and update to full opacity
3. No duplicate messages on the server (idempotency_key in metadata prevents duplicates)
4. NetworkMonitor triggers push+pull on reconnect
5. Failed messages (>24h) show retry option
6. Offline banners appear when device is offline
7. Pull-to-refresh still works when online
8. Human verification confirms full cross-platform flow works
</verification>

<success_criteria>
- When offline, previously synced conversations and messages are viewable from WatermelonDB cache
- When offline, a medic can send a message that appears locally with queued status (greyed out + indicator)
- When connectivity returns, queued messages are automatically delivered to Supabase with no duplicates
- When connectivity returns, messages received while offline appear in the conversation thread
- Offline banners in ConversationList and MessageInput indicate offline state
- Human verification confirms the full offline round-trip works
</success_criteria>

<output>
After completion, create `.planning/phases/42-ios-messaging-offline/42-03-SUMMARY.md`
</output>
