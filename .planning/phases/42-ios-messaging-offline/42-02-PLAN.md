---
phase: 42-ios-messaging-offline
plan: 02
type: execute
wave: 2
depends_on: ["42-01"]
files_modified:
  - app/(tabs)/_layout.tsx
  - app/(tabs)/messages.tsx
  - app/messages/[conversationId].tsx
  - src/components/messaging/ConversationList.tsx
  - src/components/messaging/ConversationRow.tsx
  - src/components/messaging/MessageThread.tsx
  - src/components/messaging/MessageItem.tsx
  - src/components/messaging/MessageInput.tsx
  - src/components/messaging/MedicPicker.tsx
  - src/components/messaging/EmptyState.tsx
autonomous: true

must_haves:
  truths:
    - "A medic can open the Messages tab in the iOS app and see a list of conversations loaded from WatermelonDB"
    - "A medic can tap a conversation to open the message thread and see all messages in flat Slack-style layout"
    - "A medic can type and send a message using Return key or Send button, and it appears in the thread"
    - "A medic can start a new conversation with their org admin via Message Admin button"
    - "Conversations show unread badges and the list updates after pull-to-refresh"
  artifacts:
    - path: "app/(tabs)/messages.tsx"
      provides: "Messages tab screen with conversation list"
      min_lines: 30
    - path: "app/messages/[conversationId].tsx"
      provides: "Message thread screen"
      min_lines: 30
    - path: "src/components/messaging/ConversationList.tsx"
      provides: "FlatList of conversations with pull-to-refresh"
      min_lines: 50
    - path: "src/components/messaging/MessageThread.tsx"
      provides: "Inverted FlatList of messages with send capability"
      min_lines: 60
    - path: "src/components/messaging/MessageInput.tsx"
      provides: "TextInput with Return-to-send"
      min_lines: 30
  key_links:
    - from: "src/components/messaging/ConversationList.tsx"
      to: "src/database/models/Conversation.ts"
      via: "WatermelonDB observe query"
      pattern: "database\\.collections\\.get.*conversations.*observe"
    - from: "src/components/messaging/MessageThread.tsx"
      to: "src/database/models/Message.ts"
      via: "WatermelonDB observe query filtered by conversation_id"
      pattern: "Q\\.where.*conversation_id"
    - from: "src/components/messaging/MessageInput.tsx"
      to: "src/services/MessageSync.ts"
      via: "Send message creates local record and triggers sync"
      pattern: "messageSync|database\\.write"
    - from: "app/(tabs)/_layout.tsx"
      to: "app/(tabs)/messages.tsx"
      via: "Tabs.Screen registration for Messages tab"
      pattern: "messages"
---

<objective>
Build the iOS messaging UI screens and components: Messages tab in the bottom bar, conversation list with unread badges and pull-to-refresh, message thread with flat Slack-style layout, message input with Return-to-send, and a MedicPicker for starting new conversations. All data reads from WatermelonDB (populated by Plan 42-01's sync).

Purpose: This delivers the visible messaging experience to iOS app users, matching the web dashboard's messaging features (Phase 41) in a React Native interface. Without this plan, the WatermelonDB data layer from Plan 42-01 has no user-facing surface.

Output: A fully functional Messages tab in the iOS app where medics can view conversations, read messages, send messages, and start new conversations with their org admin.
</objective>

<execution_context>
@/Users/sabineresoagli/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sabineresoagli/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/42-ios-messaging-offline/42-CONTEXT.md
@.planning/phases/42-ios-messaging-offline/42-RESEARCH.md
@.planning/phases/42-ios-messaging-offline/42-01-SUMMARY.md

# Existing iOS app patterns to follow:
@app/(tabs)/_layout.tsx
@src/contexts/SyncContext.tsx
@src/contexts/AuthContext.tsx

# WatermelonDB models from Plan 42-01:
@src/database/models/Conversation.ts
@src/database/models/Message.ts
@src/services/MessageSync.ts

# Web messaging components for feature parity reference:
@web/app/(dashboard)/messages/components/ConversationRow.tsx
@web/app/(dashboard)/messages/components/MessageItem.tsx
@web/app/(dashboard)/messages/components/MessageInput.tsx
@web/app/(dashboard)/messages/components/MedicPicker.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Messages tab and create conversation list screen with pull-to-refresh</name>
  <files>
    app/(tabs)/_layout.tsx
    app/(tabs)/messages.tsx
    src/components/messaging/ConversationList.tsx
    src/components/messaging/ConversationRow.tsx
    src/components/messaging/EmptyState.tsx
    src/components/messaging/MedicPicker.tsx
  </files>
  <action>
  **Add Messages tab to `app/(tabs)/_layout.tsx`:**
  - Add a new `Tabs.Screen` for `messages` between the Safety tab and Events tab
  - Set `href: undefined` (visible to ALL roles -- both medics and admins use messaging)
  - Icon: use the message/chat emoji or a Text icon similar to existing tabs. Use a speech bubble emoji like "ðŸ’¬"
  - Title/label: "Messages"
  - The tab should show an unread badge count. To do this, observe the conversations collection from WatermelonDB and sum unread_count > 0 conversations. Use `withObservables` or a `useEffect` with `database.collections.get('conversations').query(Q.where('unread_count', Q.gt(0))).observeCount()`. Pass the count to the `tabBarBadge` option. If count is 0, set tabBarBadge to undefined (hides badge).

  **Create Messages tab screen `app/(tabs)/messages.tsx`:**
  - This is the entry point for the Messages tab
  - Renders the `ConversationList` component
  - Header: title "Messages", right side has a "+" button (TouchableOpacity) that opens MedicPicker for starting new conversations
  - Triggers a message pull sync on mount via `messageSync.pullSync(userId, orgId)` -- get userId from useAuth() and orgId from useOrg()

  **Create `src/components/messaging/ConversationList.tsx`:**
  - React Native FlatList of conversations
  - Data source: WatermelonDB observe query on conversations collection, sorted by `last_message_at` descending (most recent first)
  - Use WatermelonDB's `withObservables` HOC or a custom hook that subscribes to `database.collections.get('conversations').query(Q.sortBy('last_message_at', Q.desc)).observe()`
  - Pull-to-refresh: `RefreshControl` that calls `messageSync.pullSync(userId, orgId)` then re-observes
  - Each item renders `ConversationRow`
  - On tap, navigate to `messages/[conversationId]` screen using `router.push(`/messages/${conversation.id}`)`
  - When list is empty, show `EmptyState`
  - Search filter: TextInput at top that filters conversations by participant_name (local filter, no API call)

  **Create `src/components/messaging/ConversationRow.tsx`:**
  - Match the web ConversationRow visual design in React Native:
    - Left: Avatar circle with first initial of participant_name, background color derived from name (same hashing approach as web)
    - Center: participant_name (bold if unread_count > 0), last_message_preview truncated to 1 line, relative timestamp (e.g. "2m ago", "Yesterday")
    - Right: unread badge (rounded pill with count, capped at 99+)
  - Use standard RN components: View, Text, TouchableOpacity
  - Colors: same palette as existing app (#2563EB active, #6B7280 secondary, #EF4444 for unread badge background)
  - Height: minimum 72px for gloves-on tap targets

  **Create `src/components/messaging/EmptyState.tsx`:**
  - Centered view with message icon, "No conversations yet" text
  - For medic role: show "Message Admin" button (same as web MedicPicker medic flow)
  - For admin role: show "Start a conversation" button that opens MedicPicker

  **Create `src/components/messaging/MedicPicker.tsx`:**
  - React Native Modal component
  - For medic users: single "Message Admin" button -- when tapped:
    1. Look up user's medic record from Supabase
    2. Call Supabase POST equivalent: create conversation (or find existing) by querying local WatermelonDB for existing direct conversation with that medic_id, or call Supabase directly to create via the existing `/api/messages/conversations` pattern (use Supabase client directly, not the Next.js API route -- the iOS app talks to Supabase directly)
    3. Actually, for conversation creation from iOS, call Supabase directly: INSERT into conversations if not exists (SELECT first for duplicate check, same 23505 pattern)
    4. Navigate to the new/existing conversation
  - For admin users: FlatList of org medics fetched from Supabase medics table, with search filter, tap to create/open conversation
  - Close button (X) in top right
  </action>
  <verify>
  - The Messages tab appears in the bottom bar between Safety and Events tabs
  - `app/(tabs)/messages.tsx` renders a conversation list
  - Pull-to-refresh triggers messageSync.pullSync
  - ConversationRow shows participant name, preview, timestamp, and unread badge
  - MedicPicker opens on "+" button tap
  - EmptyState shows when no conversations exist
  </verify>
  <done>
  Messages tab visible in iOS app for both medic and admin roles. Conversation list reads from WatermelonDB with real-time observation, pull-to-refresh triggers sync, rows show participant name, preview, timestamp, and unread badge. MedicPicker allows starting new conversations. EmptyState shown when no conversations exist.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create message thread screen with flat layout, send flow, and mark-as-read</name>
  <files>
    app/messages/[conversationId].tsx
    src/components/messaging/MessageThread.tsx
    src/components/messaging/MessageItem.tsx
    src/components/messaging/MessageInput.tsx
  </files>
  <action>
  **Create `app/messages/[conversationId].tsx`:**
  - Expo Router dynamic route screen (push navigation from conversation list)
  - Read `conversationId` from route params via `useLocalSearchParams()`
  - Look up the Conversation from WatermelonDB by ID
  - Set header title to conversation's participant_name
  - Render `MessageThread` component passing the conversationId
  - On mount, mark conversation as read:
    1. Update local Conversation record: set `last_read_at` to current timestamp, set `unread_count` to 0
    2. Call Supabase to upsert conversation_read_status (same pattern as web PATCH endpoint): `supabase.from('conversation_read_status').upsert({ user_id, conversation_id: serverConversationId, org_id, last_read_at: new Date().toISOString() }, { onConflict: 'user_id,conversation_id' })`
    3. Use the conversation's `server_id` (not local WatermelonDB ID) for the Supabase call
  - Back button navigation to return to conversation list

  **Create `src/components/messaging/MessageThread.tsx`:**
  - FlatList with `inverted={true}` for chat-like bottom-anchored scrolling
  - Data source: WatermelonDB observe query on messages collection filtered by `conversation_id` matching the local conversation ID, sorted by `created_at` ascending (inverted FlatList reverses display)
  - Use `Q.where('conversation_id', conversationId)` and `Q.sortBy('created_at', Q.asc)`
  - Each item renders `MessageItem`
  - At bottom of screen (visually): `MessageInput` component
  - Pull-to-refresh at top (which is bottom of inverted list): could trigger sync for older messages, but for MVP just trigger `messageSync.pullSync`
  - Auto-scroll to bottom when new messages arrive (FlatList inverted handles this naturally)
  - KeyboardAvoidingView wrapper so the input stays above the keyboard

  **Create `src/components/messaging/MessageItem.tsx`:**
  - Flat Slack-style layout matching web (NOT chat bubbles):
    - Left: Avatar circle with sender initial (same color hashing as ConversationRow)
    - Right of avatar: sender_name in bold (with "(you)" suffix for own messages), content below, relative timestamp in grey below content
  - For messages with `status === 'queued'`: render with 0.5 opacity and a small clock icon (Unicode "&#x1F550;" or just the text "Sending..." in grey italic below the timestamp)
  - For messages with `status === 'sent'`: render normally
  - Detect own messages by comparing message.sender_id to current user's ID from useAuth()
  - Avatar color: derive from sender_name using simple hash to pick from a palette of 6-8 colors (same approach as web)

  **Create `src/components/messaging/MessageInput.tsx`:**
  - Fixed at bottom of screen (inside KeyboardAvoidingView)
  - TextInput with placeholder "Type a message..."
  - Style: borderRadius 20, border 1px #E5E7EB, padding 12px, minHeight 44px (gloves-on), maxHeight 120px
  - `returnKeyType="send"` and `blurOnSubmit={false}`
  - `submitBehavior="submit"` (React Native 0.73+) OR use `onSubmitEditing` to handle Return key send -- this makes Return key send the message (per CONTEXT.md requirement)
  - Send button (arrow icon or "Send" text) on the right side, visible only when input has text, tappable as alternative to Return key
  - On send (Return key or button tap):
    1. Trim content, validate non-empty
    2. Create a new Message record in WatermelonDB with:
       - `conversation_id` = local conversation WatermelonDB ID
       - `org_id` from useOrg()
       - `sender_id` from useAuth() user.id
       - `sender_name` from current user's name
       - `message_type` = 'text'
       - `content` = trimmed text
       - `status` = 'queued' (will be updated to 'sent' after successful push sync)
       - `idempotency_key` = Crypto.randomUUID()
       - `created_at` = Date.now()
       - `updated_at` = Date.now()
    3. Update local Conversation: set `last_message_at` to Date.now(), set `last_message_preview` to content.substring(0, 100)
    4. Clear the input
    5. Trigger `messageSync.pushPendingMessages()` (async, fire-and-forget) to attempt immediate delivery
    6. The WatermelonDB observe query on MessageThread will automatically show the new message (with 'queued' status styling)
  - Disable the input and show a brief ActivityIndicator while the WatermelonDB write is in progress (typically <50ms, just prevents double-tap)
  </action>
  <verify>
  - Tapping a conversation in the list navigates to `messages/[conversationId]` screen
  - Messages display in flat Slack-style layout with sender avatar, name, content, timestamp
  - Return key sends a message (message appears immediately in thread with queued styling)
  - Send button also works for sending
  - Mark-as-read fires on thread open (local unread_count goes to 0 + Supabase upsert)
  - Back button returns to conversation list
  - KeyboardAvoidingView keeps input above keyboard
  </verify>
  <done>
  Message thread screen opens from conversation list with flat Slack-style message layout. Messages display sender avatar, name, content, and relative timestamp. Sending via Return key or Send button creates a local WatermelonDB record (status='queued'), triggers push sync, and appears immediately in the inverted FlatList. Queued messages show with reduced opacity and clock indicator. Thread mount marks conversation as read both locally and on Supabase. KeyboardAvoidingView keeps the input above the iOS keyboard.
  </done>
</task>

</tasks>

<verification>
1. Messages tab appears in the iOS app bottom bar (between Safety and Settings, visible to all roles)
2. Conversation list loads from WatermelonDB and displays conversations with participant name, preview, timestamp, unread badge
3. Pull-to-refresh triggers message sync
4. Tapping a conversation opens the message thread
5. Messages display in flat Slack-style layout (not chat bubbles)
6. Return key sends a message, which appears immediately with 'queued' status
7. MedicPicker allows starting new conversations
8. Mark-as-read fires on thread open
</verification>

<success_criteria>
- A medic can open the Messages tab and see all their conversations from WatermelonDB
- A medic can tap a conversation and see all messages in flat Slack-style layout
- A medic can send a message via Return key or Send button, and it appears immediately
- A medic can start a new conversation with their org admin
- Conversations show accurate unread badges that clear when the thread is opened
- Pull-to-refresh syncs new data from Supabase
</success_criteria>

<output>
After completion, create `.planning/phases/42-ios-messaging-offline/42-02-SUMMARY.md`
</output>
