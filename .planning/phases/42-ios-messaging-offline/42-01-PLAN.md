---
phase: 42-ios-messaging-offline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/database/schema.ts
  - src/database/migrations.ts
  - src/database/models/Conversation.ts
  - src/database/models/Message.ts
  - src/database/models/index.ts
  - src/lib/watermelon.ts
  - src/services/MessageSync.ts
  - src/services/SyncQueue.ts
  - src/contexts/SyncContext.tsx
autonomous: true

must_haves:
  truths:
    - "WatermelonDB schema is at version 5 with conversations and messages tables"
    - "Pull sync fetches conversations and messages from Supabase and upserts them into WatermelonDB"
    - "Push sync enqueues outbound messages through the existing SyncQueue with idempotency keys"
    - "Incremental sync only fetches records newer than last_synced_at (not full re-download)"
  artifacts:
    - path: "src/database/models/Conversation.ts"
      provides: "WatermelonDB Conversation model"
      min_lines: 20
    - path: "src/database/models/Message.ts"
      provides: "WatermelonDB Message model"
      min_lines: 20
    - path: "src/services/MessageSync.ts"
      provides: "Pull and push sync logic for messaging data"
      min_lines: 80
  key_links:
    - from: "src/services/MessageSync.ts"
      to: "src/database/models/Conversation.ts"
      via: "WatermelonDB collection queries and batch writes"
      pattern: "database\\.collections\\.get.*conversations"
    - from: "src/services/MessageSync.ts"
      to: "supabase"
      via: "Supabase REST API calls for pull sync"
      pattern: "supabase\\.from\\(.(conversations|messages)."
    - from: "src/services/SyncQueue.ts"
      to: "messages"
      via: "Message-specific sync handler in syncItem"
      pattern: "messages"
    - from: "src/database/models/index.ts"
      to: "src/database/models/Conversation.ts"
      via: "modelClasses array registration"
      pattern: "Conversation"
---

<objective>
Create WatermelonDB models for Conversation and Message, migrate schema from v4 to v5, and build the MessageSync service that pulls conversations/messages from Supabase into local cache and pushes outbound messages through the existing SyncQueue.

Purpose: This is the data layer foundation for iOS messaging. Without local WatermelonDB models and sync, the UI components in Plan 42-02 would have nothing to read from, and the offline queue in Plan 42-03 would have no local persistence layer.

Output: Two new WatermelonDB models registered in the database, a schema migration from v4 to v5, a MessageSync service with pull/push capabilities, and SyncQueue extended with message-specific handling.
</objective>

<execution_context>
@/Users/sabineresoagli/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sabineresoagli/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/42-ios-messaging-offline/42-CONTEXT.md
@.planning/phases/42-ios-messaging-offline/42-RESEARCH.md

# Existing WatermelonDB patterns to follow:
@src/database/schema.ts
@src/database/migrations.ts
@src/database/models/Treatment.ts
@src/database/models/SyncQueueItem.ts
@src/database/models/index.ts
@src/lib/watermelon.ts
@src/services/SyncQueue.ts
@src/services/NetworkMonitor.ts
@src/contexts/SyncContext.tsx

# Web messaging types (source of truth for field mapping):
@web/types/comms.types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create WatermelonDB Conversation and Message models with schema migration v4 to v5</name>
  <files>
    src/database/models/Conversation.ts
    src/database/models/Message.ts
    src/database/models/index.ts
    src/database/schema.ts
    src/database/migrations.ts
    src/lib/watermelon.ts
  </files>
  <action>
  Create two new WatermelonDB model files following the exact pattern used by Treatment.ts and SyncQueueItem.ts (Model base class, @field/@text decorators, static table name).

  **Conversation model** (`src/database/models/Conversation.ts`):
  - `static table = 'conversations'`
  - Fields mapping to Supabase conversations table:
    - `server_id` (string, optional) -- Supabase UUID, populated after sync
    - `org_id` (string, indexed) -- organisation scope
    - `type` (string) -- 'direct' or 'broadcast'
    - `subject` (string, optional) -- for broadcast conversations
    - `medic_id` (string, optional) -- for direct conversations
    - `created_by` (string) -- user who created the conversation
    - `last_message_at` (number, optional) -- epoch ms of last message
    - `last_message_preview` (string, optional) -- truncated last message content
    - `participant_name` (string, optional) -- denormalized name for display (avoids JOIN at render time)
    - `unread_count` (number) -- locally computed unread count (default 0)
    - `last_read_at` (number, optional) -- epoch ms of current user's last read
    - `created_at` (number)
    - `updated_at` (number)

  **Message model** (`src/database/models/Message.ts`):
  - `static table = 'messages'`
  - Fields:
    - `server_id` (string, optional) -- Supabase UUID
    - `conversation_id` (string, indexed) -- links to local conversation
    - `org_id` (string, indexed)
    - `sender_id` (string) -- Supabase user UUID of sender
    - `sender_name` (string, optional) -- denormalized sender display name
    - `message_type` (string) -- 'text', 'attachment', 'system'
    - `content` (string, optional) -- message text (use @text decorator for this)
    - `status` (string) -- 'queued', 'sent', 'delivered', 'read' (note: 'queued' is added for offline; server schema only has sent/delivered/read)
    - `idempotency_key` (string, optional) -- client-generated UUID for deduplication on push sync
    - `created_at` (number)
    - `updated_at` (number)

  **Schema update** (`src/database/schema.ts`):
  - Bump version from 4 to 5
  - Add `tableSchema({ name: 'conversations', columns: [...] })` matching the Conversation model fields above
  - Add `tableSchema({ name: 'messages', columns: [...] })` matching the Message model fields above
  - Keep all existing table schemas untouched

  **Migration** (`src/database/migrations.ts`):
  - Add migration block `{ toVersion: 5, steps: [...] }` using `createTable` for both new tables
  - Use the exact same column definitions as the schema (this is how WatermelonDB migrations work)

  **Register models** (`src/database/models/index.ts`):
  - Import Conversation and Message
  - Add both to the `modelClasses` array

  **Database init** (`src/lib/watermelon.ts`):
  - No changes needed -- it already uses `modelClasses` from the index
  - Just verify the comment says "8 model classes" (was 6, now 8)
  </action>
  <verify>
  - `src/database/schema.ts` has `version: 5` and two new tableSchema entries
  - `src/database/migrations.ts` has a `toVersion: 5` block with createTable for conversations and messages
  - `src/database/models/index.ts` exports 8 model classes
  - TypeScript compiles without errors: run `npx tsc --noEmit --project tsconfig.json` from the project root (or check that the IDE shows no type errors in the new files)
  </verify>
  <done>
  WatermelonDB schema is at version 5 with conversations and messages tables. Conversation model has server_id, org_id, type, medic_id, last_message_at, last_message_preview, participant_name, unread_count, last_read_at. Message model has server_id, conversation_id, org_id, sender_id, sender_name, message_type, content, status, idempotency_key. Both are registered in modelClasses and the migration from v4 to v5 exists.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create MessageSync service for pull/push sync and extend SyncQueue with message handlers</name>
  <files>
    src/services/MessageSync.ts
    src/services/SyncQueue.ts
    src/contexts/SyncContext.tsx
  </files>
  <action>
  Create `src/services/MessageSync.ts` -- the sync engine for messaging data. This service handles both pull (server to local) and push (local to server) sync. Follow the existing pattern from SyncQueue.ts (singleton export, getDatabase() usage, Supabase client).

  **MessageSync service:**

  ```typescript
  // Core state:
  private lastSyncedAt: number = 0  // epoch ms, persisted in AsyncStorage as 'messaging_last_synced_at'
  private isSyncing: boolean = false  // guard against concurrent sync
  ```

  **Pull sync method -- `pullSync(userId: string, orgId: string)`:**
  1. Guard against concurrent sync (`if (this.isSyncing) return`)
  2. Load `lastSyncedAt` from AsyncStorage (key: `messaging_last_synced_at`)
  3. If `lastSyncedAt === 0` (first sync), fetch all conversations for this org + last 100 messages per conversation
  4. If `lastSyncedAt > 0` (incremental), fetch conversations updated since `lastSyncedAt` and messages created since `lastSyncedAt`
  5. For conversations:
     - Query Supabase: `supabase.from('conversations').select('*').eq('org_id', orgId).gt('updated_at', lastSyncedAtISO).order('updated_at', { ascending: false }).limit(200)`
     - For each conversation, resolve participant_name: if user is medic, participant is "Admin"; if user is admin, look up medic name from medics table
     - Compute unread_count: count messages in conversation where sender_id != userId AND created_at > user's last_read_at (fetch from conversation_read_status)
     - Batch write to WatermelonDB: for each conversation, find by server_id -- if exists, update; if not, create
  6. For messages:
     - Query Supabase: `supabase.from('messages').select('*').eq('org_id', orgId).is('deleted_at', null).gt('created_at', lastSyncedAtISO).order('created_at', { ascending: true }).limit(500)`
     - Resolve sender_name: bulk fetch medics table for unique sender_ids, non-medic senders are "Admin"
     - Batch write to WatermelonDB: for each message, find by server_id -- if exists update, if not create
  7. Save current timestamp to AsyncStorage as new `lastSyncedAt`
  8. Return `{ conversationsSynced: number, messagesSynced: number }`

  **Important pull sync details:**
  - Use `database.write(async () => { database.batch(...) })` for efficient batch writes
  - When creating/updating local records, set `server_id` to the Supabase `id` field
  - When looking up existing records by server_id, use `Q.where('server_id', supabaseId)`
  - For first sync (lastSyncedAt === 0), after fetching conversations, fetch messages for each conversation with `.limit(100)` ordered by created_at desc (most recent first)
  - For incremental sync, fetch all new messages across all conversations in one query (more efficient)

  **Push sync -- extend SyncQueue.ts `syncItem` method:**
  Add a case in the `syncItem` method's `create` switch for when `item.tableName === 'messages'`:
  - Parse the payload to get `conversation_id` (server_id of conversation), `content`, `org_id`, `sender_id`
  - Call Supabase directly: `supabase.from('messages').insert({ conversation_id, org_id, sender_id, message_type: 'text', content, status: 'sent' }).select().single()`
  - On success, also update conversation metadata: `supabase.from('conversations').update({ last_message_at: new Date().toISOString(), last_message_preview: content.substring(0, 100) }).eq('id', conversation_id)`
  - On success, also upsert sender read status: `supabase.from('conversation_read_status').upsert({ user_id: sender_id, conversation_id, org_id, last_read_at: new Date().toISOString() }, { onConflict: 'user_id,conversation_id' })`
  - On success, update local Message record: set `server_id` to returned message.id, set `status` from 'queued' to 'sent'
  - Handle 23505 duplicate (idempotency key collision) as success, same as existing pattern

  **Actually, do NOT modify the generic syncItem in SyncQueue.ts for messages.** Instead, add a new dedicated message sync handler in MessageSync.ts called `pushPendingMessages()`:
  - Query WatermelonDB messages table for records with `status === 'queued'`
  - For each queued message:
    - Look up the conversation's `server_id` from local Conversation model (need server_id to call Supabase API)
    - POST to Supabase to create the message (same fields as above)
    - On success, update local message: set server_id, set status to 'sent'
    - On failure, leave status as 'queued' (will retry on next sync)
  - This keeps message sync self-contained in MessageSync.ts rather than polluting the generic SyncQueue

  **Integrate with SyncContext.tsx:**
  - Import messageSync singleton
  - In `triggerSync` callback, after `syncQueue.processPendingItems()`, call `messageSync.pullSync(userId, orgId)` and `messageSync.pushPendingMessages()`
  - Add a new `messageSyncStatus` field to SyncState: 'idle' | 'syncing' | 'error'
  - Expose `triggerMessageSync` method in the context for the UI to call on pull-to-refresh
  - When NetworkMonitor triggers onConnected, also trigger message push+pull sync

  **Export messageSync as singleton:**
  ```typescript
  export const messageSync = new MessageSync()
  ```

  **Do NOT modify the existing SyncQueue.syncItem method.** Keep message sync entirely in MessageSync.ts. The SyncQueue continues to handle treatments, workers, near_misses, safety_checks as before.
  </action>
  <verify>
  - `src/services/MessageSync.ts` exists with pullSync and pushPendingMessages methods
  - `src/contexts/SyncContext.tsx` calls messageSync in its triggerSync flow
  - The MessageSync pullSync method queries Supabase for conversations and messages, writes them to WatermelonDB
  - The pushPendingMessages method queries local messages with status='queued' and POSTs them to Supabase
  - No changes to the existing SyncQueue.syncItem switch cases (treatments, workers, etc. unaffected)
  </verify>
  <done>
  MessageSync service exists as a singleton with pullSync (fetches from Supabase, upserts into WatermelonDB with incremental sync via lastSyncedAt in AsyncStorage) and pushPendingMessages (sends queued local messages to Supabase, updates status from queued to sent). SyncContext integrates message sync into the triggerSync flow. The existing SyncQueue for clinical data (treatments, workers, near_misses, safety_checks) is untouched.
  </done>
</task>

</tasks>

<verification>
1. Schema version is 5 in `src/database/schema.ts`
2. Migration from v4 to v5 exists in `src/database/migrations.ts` with createTable for conversations and messages
3. `src/database/models/index.ts` exports 8 model classes (6 existing + Conversation + Message)
4. `src/services/MessageSync.ts` has pullSync and pushPendingMessages as public methods
5. `src/contexts/SyncContext.tsx` calls messageSync in triggerSync
6. No changes to existing clinical data sync (treatments, workers, near_misses, safety_checks)
</verification>

<success_criteria>
- WatermelonDB schema is at version 5 with conversations and messages tables
- Conversation model stores server_id, org_id, type, medic_id, last_message_at, participant_name, unread_count
- Message model stores server_id, conversation_id, sender_id, sender_name, content, status (including 'queued')
- MessageSync.pullSync fetches from Supabase and writes to WatermelonDB with incremental sync
- MessageSync.pushPendingMessages sends queued messages to Supabase and updates local status
- SyncContext exposes message sync to the UI layer
</success_criteria>

<output>
After completion, create `.planning/phases/42-ios-messaging-offline/42-01-SUMMARY.md`
</output>
