---
phase: 04.6-customer-onboarding-contract-management
plan: 07
type: execute
wave: 4
depends_on: ["04.6-05", "04.6-06"]
files_modified:
  - web/app/api/contracts/[id]/complete-payment/route.ts
  - web/app/api/contracts/[id]/capture-milestone/route.ts
  - web/components/contracts/payment-milestone-tracker.tsx
  - web/lib/contracts/payment-enforcement.ts
  - web/app/api/bookings/confirm/route.ts
autonomous: true

must_haves:
  truths:
    - "Payment schedule enforces based on agreement (e.g., 50% charge on signature, 50% charge after booking completion)"
    - "Booking cannot be confirmed until agreement is signed (configurable per client)"
    - "Signed agreement PDF stored in Supabase Storage with audit trail"
  artifacts:
    - path: "web/lib/contracts/payment-enforcement.ts"
      provides: "Payment milestone tracking and enforcement logic"
      exports: ["canConfirmBooking", "getNextMilestone", "processMilestonePayment"]
    - path: "web/components/contracts/payment-milestone-tracker.tsx"
      provides: "Visual tracker showing payment milestones with paid/pending status"
      contains: "PaymentMilestoneTracker"
    - path: "web/app/api/contracts/[id]/capture-milestone/route.ts"
      provides: "API endpoint for capturing milestone payments via Stripe"
      exports: ["POST"]
  key_links:
    - from: "web/lib/contracts/payment-enforcement.ts"
      to: "web/lib/contracts/workflow.ts"
      via: "uses canTransition for status validation"
      pattern: "import.*canTransition"
    - from: "web/app/api/contracts/[id]/capture-milestone/route.ts"
      to: "supabase/functions/stripe-connect"
      via: "calls Stripe for payment capture"
      pattern: "stripe-connect"
    - from: "web/app/api/bookings/confirm/route.ts"
      to: "web/lib/contracts/payment-enforcement.ts"
      via: "checks canConfirmBooking before allowing confirmation"
      pattern: "canConfirmBooking"
---

<objective>
Create payment milestone enforcement, Stripe payment capture integration, and booking confirmation gate tied to contract signing status.

Purpose: This is the enforcement layer that ties everything together. When a contract is signed, the upfront payment is captured (if applicable). When the booking is completed, the completion payment triggers. The booking confirmation gate prevents confirming bookings without signed agreements (configurable). Payment milestones are visually tracked in the admin dashboard.

Output: Payment enforcement logic, milestone payment API routes, payment tracker component, booking confirmation gate.
</objective>

<execution_context>
@/Users/sabineresoagli/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sabineresoagli/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@web/lib/contracts/types.ts
@web/lib/contracts/workflow.ts
@web/lib/contracts/payment-schedules.ts
@supabase/functions/stripe-connect/index.ts
@supabase/functions/_shared/stripe.ts
@.planning/phases/01.5-business-foundation/01.5-02-SUMMARY.md
@.planning/phases/04.6-customer-onboarding-contract-management/04.6-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create payment enforcement logic and milestone tracker component</name>
  <files>
    web/lib/contracts/payment-enforcement.ts
    web/components/contracts/payment-milestone-tracker.tsx
  </files>
  <action>
**web/lib/contracts/payment-enforcement.ts:**

```typescript
import { Contract, PaymentTerms, ContractStatus } from './types';

interface PaymentMilestone {
  id: string; // 'upfront' | 'completion' | 'net30'
  label: string;
  amount: number;
  dueEvent: string; // 'on_signing' | 'on_completion' | 'net_30_days'
  dueDate?: string; // calculated ISO date for net30
  status: 'pending' | 'due' | 'paid' | 'overdue';
  paidAt?: string;
}

// Get milestones for a contract based on payment terms
export function getPaymentMilestones(contract: Contract): PaymentMilestone[] {
  const milestones: PaymentMilestone[] = [];

  if (contract.upfront_amount > 0) {
    milestones.push({
      id: 'upfront',
      label: 'Upfront Payment',
      amount: contract.upfront_amount,
      dueEvent: 'on_signing',
      status: contract.upfront_paid_at ? 'paid' : (contract.status === 'signed' ? 'due' : 'pending'),
      paidAt: contract.upfront_paid_at,
    });
  }

  if (contract.completion_amount > 0) {
    milestones.push({
      id: 'completion',
      label: 'Completion Payment',
      amount: contract.completion_amount,
      dueEvent: 'on_completion',
      status: contract.completion_paid_at ? 'paid' :
        (contract.status === 'fulfilled' || contract.status === 'active' ? 'due' : 'pending'),
      paidAt: contract.completion_paid_at,
    });
  }

  if (contract.net30_amount > 0) {
    // Calculate Net 30 due date from completion date or fulfilled date
    const completionDate = contract.fulfilled_at || contract.completed_at;
    const dueDate = completionDate
      ? new Date(new Date(completionDate).getTime() + 30 * 24 * 60 * 60 * 1000).toISOString()
      : undefined;

    milestones.push({
      id: 'net30',
      label: 'Net 30 Payment',
      amount: contract.net30_amount,
      dueEvent: 'net_30_days',
      dueDate,
      status: contract.net30_paid_at ? 'paid' :
        (dueDate && new Date(dueDate) < new Date() ? 'overdue' : 'pending'),
      paidAt: contract.net30_paid_at,
    });
  }

  return milestones;
}

// Get the next milestone that needs payment
export function getNextMilestone(contract: Contract): PaymentMilestone | null {
  const milestones = getPaymentMilestones(contract);
  return milestones.find(m => m.status === 'due' || m.status === 'overdue') || null;
}

// Check if a booking can be confirmed based on contract requirements
export function canConfirmBooking(booking: any, contract: Contract | null): {
  canConfirm: boolean;
  reason?: string;
} {
  // If no contract exists for this booking, check if contracts are required
  if (!contract) {
    // Default: allow confirmation without contract (configurable per client)
    return { canConfirm: true };
  }

  // If contract exists but requires signature before booking
  if (contract.requires_signature_before_booking) {
    if (contract.status === 'signed' || contract.status === 'completed' || contract.status === 'active') {
      return { canConfirm: true };
    }
    return {
      canConfirm: false,
      reason: `Service agreement must be signed before booking can be confirmed. Current status: ${contract.status}`,
    };
  }

  return { canConfirm: true };
}

// Check if all payments for a contract are complete
export function isFullyPaid(contract: Contract): boolean {
  const milestones = getPaymentMilestones(contract);
  return milestones.every(m => m.status === 'paid');
}
```

**web/components/contracts/payment-milestone-tracker.tsx** — 'use client' component:
- Props: `{ contract: Contract; onCaptureMilestone?: (milestoneId: string) => void }`
- Import getPaymentMilestones from payment-enforcement.ts
- Render vertical timeline of milestones:
  - Each milestone:
    - Circle indicator: green check (paid), blue dot (due), gray dot (pending), red dot (overdue)
    - Label and amount (GBP formatted)
    - Due event description (e.g., "Due upon signing", "Due 30 days after completion")
    - If paid: show paid date in green
    - If overdue: show "Overdue" badge in red with days overdue count
    - If due: show "Capture Payment" button (calls onCaptureMilestone)
  - Connecting line between milestones
- Progress summary: "2 of 3 payments completed" with progress bar
- Total paid vs total remaining
  </action>
  <verify>
Run: `ls web/lib/contracts/payment-enforcement.ts` confirms file exists.
Run: `ls web/components/contracts/payment-milestone-tracker.tsx` confirms component exists.
Run: `grep "getPaymentMilestones" web/lib/contracts/payment-enforcement.ts` confirms export.
Run: `grep "canConfirmBooking" web/lib/contracts/payment-enforcement.ts` confirms booking gate.
  </verify>
  <done>
Payment enforcement logic calculates milestones, identifies next due payment, gates booking confirmation on contract signing, and checks full payment status. Milestone tracker component shows visual timeline with payment status.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create milestone payment API and booking confirmation gate</name>
  <files>
    web/app/api/contracts/[id]/capture-milestone/route.ts
    web/app/api/contracts/[id]/complete-payment/route.ts
    web/app/api/bookings/confirm/route.ts
  </files>
  <action>
**web/app/api/contracts/[id]/capture-milestone/route.ts** — POST endpoint:
- Accept: { milestoneId: 'upfront' | 'completion' | 'net30' }
- Fetch contract with client relation
- Validate milestone exists and is 'due' or 'overdue'
- Determine amount from contract (upfront_amount, completion_amount, or net30_amount)
- Payment processing:
  - If contract has stripe_payment_intent_id (authorization hold exists):
    - Call Stripe to capture partial amount: `stripe.paymentIntents.capture(id, { amount_to_capture: amount * 100 })`
    - Use supabase.functions.invoke('stripe-connect', { body: { action: 'capture_payment', ... } })
  - If no authorization hold (Net 30 or post-completion):
    - Create new Payment Intent for the amount
    - Use supabase.functions.invoke('stripe-connect', { body: { action: 'create_payment_intent', ... } })
    - For Net 30: The payment intent should be charged to the client's default payment method on file
- Update contract: set {milestone}_paid_at = now()
- Check if all milestones paid -> if so, update contract status to 'fulfilled' (if service completed)
- Insert contract_event: event_type='payment_captured', event_data={ milestoneId, amount, stripePaymentIntentId }
- Return { success: true, milestone, amountCaptured }

**web/app/api/contracts/[id]/complete-payment/route.ts** — POST endpoint:
- Triggered when booking status changes to 'completed'
- Fetch contract for the booking
- Check if completion_amount > 0 and not yet paid
- If yes: auto-capture completion payment (same Stripe logic as above)
- Check if all milestones now paid
- Update contract status: active -> fulfilled (if applicable)
- Log events

**web/app/api/bookings/confirm/route.ts** — POST endpoint:
- Accept: { bookingId }
- Fetch booking
- Check if contract exists for this booking:
  - Query: `SELECT * FROM contracts WHERE booking_id = bookingId AND status != 'terminated' LIMIT 1`
- Call canConfirmBooking(booking, contract)
- If canConfirm is false: return 400 with { error: reason }
- If canConfirm is true:
  - Update booking status to 'confirmed'
  - If contract exists and upfront_amount > 0 and not yet paid:
    - Auto-trigger upfront payment capture
    - Update contract status to 'completed' (signed + payment captured)
  - Log booking_event
- Return { success: true, booking }

Note about Stripe integration: The existing stripe-connect Edge Function supports 'create_payment_intent' action. For milestone captures, either:
1. Add a 'capture_payment_intent' action to the existing stripe-connect Edge Function
2. Or call Stripe directly from the API route using the Stripe server-side client

Option 2 is simpler for this plan. Import Stripe from the existing web/lib/stripe/server.ts pattern. If web/lib/stripe/server.ts doesn't export a Stripe instance, create one following the existing pattern.
  </action>
  <verify>
Run: `ls web/app/api/contracts/*/` to verify API route directories.
Run: `ls web/app/api/bookings/confirm/` to verify booking gate route.
Run: `grep "canConfirmBooking" web/app/api/bookings/confirm/route.ts` confirms gate check.
Run: `grep "stripe" web/app/api/contracts/*/capture-milestone/route.ts` confirms Stripe integration.
Run: `cd /Users/sabineresoagli/GitHub/sitemedic/web && pnpm build 2>&1 | tail -10` to verify build.
  </verify>
  <done>
Milestone payment API captures Stripe payments for each milestone (upfront on signing, completion on service end, Net 30 on due date). Booking confirmation gate prevents confirming without signed contract. Auto-capture triggers on contract signing and booking completion.
  </done>
</task>

</tasks>

<verification>
1. Payment milestones calculate correctly for all 5 term types
2. Booking confirmation checks contract signing status
3. Upfront payment captured on contract signing (when applicable)
4. Completion payment triggered on booking completion
5. Net 30 milestones track due dates and overdue status
6. All payment events logged in audit trail
7. Build passes with no TypeScript errors
</verification>

<success_criteria>
- 50% charge happens on signature (for split payment contracts)
- 50% charge happens after booking completion (for split payment contracts)
- Full charge happens on signing (for full prepay contracts)
- Net 30 payment tracks due date with overdue detection
- Booking cannot be confirmed without signed agreement (when configured)
- Milestone tracker shows visual progress of payments
</success_criteria>

<output>
After completion, create `.planning/phases/04.6-customer-onboarding-contract-management/04.6-07-SUMMARY.md`
</output>
