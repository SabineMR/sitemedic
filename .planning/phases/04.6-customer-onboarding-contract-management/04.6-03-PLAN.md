---
phase: 04.6-customer-onboarding-contract-management
plan: 03
type: execute
wave: 2
depends_on: ["04.6-01"]
files_modified:
  - web/components/contracts/signature-pad.tsx
  - web/components/contracts/contract-viewer.tsx
  - web/components/contracts/contract-status-badge.tsx
  - web/app/contracts/[id]/sign/page.tsx
  - web/app/contracts/[id]/sign/layout.tsx
  - web/app/api/contracts/[id]/sign/route.ts
  - web/package.json
autonomous: true

must_haves:
  truths:
    - "Client can view agreement in browser with all details visible (client info, pricing, terms, payment schedule)"
    - "Client can sign digitally using signature pad (canvas drawing) or typed name fallback"
    - "Signed agreement stores signature data with audit trail (who signed, when, IP address)"
  artifacts:
    - path: "web/components/contracts/signature-pad.tsx"
      provides: "Reusable signature canvas component with clear/save and typed name fallback"
      contains: "SignatureCanvas"
    - path: "web/app/contracts/[id]/sign/page.tsx"
      provides: "Public client-facing signing page accessible via shareable token"
      contains: "SignaturePad"
    - path: "web/components/contracts/contract-viewer.tsx"
      provides: "Contract detail viewer showing all sections in HTML format"
      contains: "ContractViewer"
  key_links:
    - from: "web/app/contracts/[id]/sign/page.tsx"
      to: "web/components/contracts/signature-pad.tsx"
      via: "imports and renders SignaturePad component"
      pattern: "import.*SignaturePad"
    - from: "web/app/contracts/[id]/sign/page.tsx"
      to: "/api/contracts"
      via: "fetch to submit signature and update contract status"
      pattern: "fetch.*api/contracts"
---

<objective>
Create the client-facing contract signing experience with signature pad component, contract viewer, and public signing page.

Purpose: This is the client's touchpoint. When admin sends a contract, the client receives a link to this page where they can view the agreement details (no PDF download required) and sign digitally. The signing page is publicly accessible via a shareable token (no auth required). The signature pad uses react-signature-canvas for smooth drawing, with a typed name fallback for accessibility.

Output: Signature pad component, contract HTML viewer, public signing page at /contracts/[id]/sign, contract status badge component.
</objective>

<execution_context>
@/Users/sabineresoagli/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sabineresoagli/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@web/lib/contracts/types.ts
@web/lib/contracts/workflow.ts
@web/lib/contracts/payment-schedules.ts
@.planning/phases/04.6-customer-onboarding-contract-management/04.6-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install react-signature-canvas and create signature pad + contract viewer components</name>
  <files>
    web/package.json
    web/components/contracts/signature-pad.tsx
    web/components/contracts/contract-viewer.tsx
    web/components/contracts/contract-status-badge.tsx
  </files>
  <action>
**Install dependency:**
Run from web/ directory: `pnpm add react-signature-canvas && pnpm add --save-dev @types/react-signature-canvas`

**web/components/contracts/signature-pad.tsx** — 'use client' component:
- Import SignatureCanvas from 'react-signature-canvas'
- Props: `{ onSave: (data: { signatureDataUrl: string; signedName: string }) => Promise<void>; disabled?: boolean }`
- State: isSaving, error, signMethod ('draw' | 'type'), typedName
- Ref: sigCanvas = useRef<SignatureCanvas>(null)
- Toggle between "Draw Signature" and "Type Name" tabs using shadcn Tabs component (or simple buttons)
- Draw mode: SignatureCanvas with penColor="#1e293b", backgroundColor="#ffffff", minWidth=1, maxWidth=2.5
  - Canvas props: className="w-full touch-none", width auto-sizing (use ResizeObserver or set via parent container width)
  - Clear button and Save button
- Type mode: Input field for full name, checkbox "I agree this typed name constitutes my digital signature"
  - Save button (only enabled when name entered and checkbox checked)
- Both modes call onSave with { signatureDataUrl (base64 PNG from canvas or generated text image), signedName }
- For typed name: generate a simple dataURL by drawing the name on a hidden canvas in cursive-style (or just pass the name string and let the API handle it)
- Error display below canvas
- Legal text: "By signing above, you confirm that you have read, understood, and agree to all terms and conditions of this service agreement."
- Disable all interactions when disabled prop is true (for already-signed contracts)

**web/components/contracts/contract-viewer.tsx** — 'use client' component:
- Props: `{ contract: ContractWithRelations }` (from types.ts)
- Render contract details in HTML format (not PDF) for browser viewing:
  - Header: "SERVICE AGREEMENT" + contract number + date
  - Parties section: SiteMedic Ltd (Provider) and Client company name, contact
  - Site Details: name, address, postcode, contact
  - Booking Details: date, shift times, hours, special requirements
  - Pricing Table: HTML table with base rate, urgency premium, travel, subtotal, VAT, total
  - Payment Schedule: milestones with amounts and due dates (use calculatePaymentSchedule or show stored values)
  - Template Clauses: numbered list of clause titles and bodies (if template data available)
  - Terms & Conditions section
  - Cancellation Policy section
- Use Tailwind classes for professional styling (prose-like layout, print-friendly)
- Responsive: single column on mobile, comfortable reading width (max-w-3xl) on desktop

**web/components/contracts/contract-status-badge.tsx** — Simple component:
- Props: `{ status: ContractStatus }`
- Import STATUS_LABELS and STATUS_COLORS from workflow.ts
- Render shadcn Badge component with appropriate variant/color
- Map status to colors: draft=secondary, sent=default (blue), viewed=outline (indigo), signed=default (green border), completed=default (emerald), active=default (teal), fulfilled=secondary, amended=destructive (amber), terminated=destructive
  </action>
  <verify>
Run from web/: `pnpm list react-signature-canvas` confirms installation.
Run: `ls web/components/contracts/` shows 3 component files.
Run: `cd /Users/sabineresoagli/GitHub/sitemedic/web && npx tsc --noEmit 2>&1 | tail -5` to check for TypeScript errors.
  </verify>
  <done>
react-signature-canvas installed. SignaturePad supports both canvas drawing and typed name signing. ContractViewer renders all contract sections in HTML. ContractStatusBadge shows color-coded status labels.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create public client signing page with contract view and signature submission</name>
  <files>
    web/app/contracts/[id]/sign/page.tsx
    web/app/contracts/[id]/sign/layout.tsx
    web/app/api/contracts/[id]/sign/route.ts
  </files>
  <action>
**web/app/contracts/[id]/sign/layout.tsx** — Minimal public layout:
- No authentication required (public page accessed via shareable link)
- Simple layout with SiteMedic branding header (logo text, "Service Agreement")
- Clean white background, max-w-4xl centered
- Footer with "SiteMedic Ltd" and year
- No dashboard navigation (this is client-facing, not admin)

**web/app/contracts/[id]/sign/page.tsx** — Server component with client interactivity:
- Route params: { id } which is the shareable_token (NOT the contract UUID for security)
- Server-side data fetch: Query contracts table WHERE shareable_token = id, join with bookings, clients, contract_versions, contract_templates
- If contract not found: Show 404 page ("Contract not found or link has expired")
- If contract already signed: Show read-only ContractViewer with signature displayed and "This agreement has been signed" banner
- If contract terminated: Show "This agreement has been cancelled" message
- If contract is valid (sent or viewed status):
  1. Update status to 'viewed' if currently 'sent': Server component fetches contract via Supabase client (createClient from @/lib/supabase/server), checks if status === 'sent', if so runs `supabase.from('contracts').update({ status: 'viewed', viewed_at: new Date().toISOString() }).eq('id', contract.id)` directly in the server component before rendering. This is a server component so the database update happens on page load without a separate API call.
  2. Log contract_event: Insert `{ contract_id: contract.id, event_type: 'document_viewed', event_data: { viewed_via: 'signing_page', previous_status: 'sent' }, created_at: new Date().toISOString() }` into contract_events table via the same Supabase client.
  3. Render ContractViewer component showing full agreement
  4. Below contract: Render SignaturePad component
  5. On signature save:
     - POST to /api/contracts/[contractId]/sign with { signatureDataUrl, signedName, contractId }
     - API route handles: update contract_versions with signature data, update contract status to 'signed', log contract_event with IP address, trigger PDF regeneration with signature embedded
     - Show success message: "Thank you! Your agreement has been signed successfully. A copy will be sent to your email."
  6. Loading states for data fetch and signature submission

**API route needed (create inline or reference for Plan 05):**
The signing page needs a POST endpoint. Create a lightweight API route at web/app/api/contracts/[id]/sign/route.ts:
- Accept POST with { signatureDataUrl, signedName }
- Lookup contract by id (the contract UUID, passed in the client component after initial server fetch)
- Validate contract is in 'sent' or 'viewed' status
- Update contract_versions (latest version) with: client_signature_data, client_signed_name, signed_at (ISO timestamp), signed_by_email (from contract.client relation), signed_by_ip (from request headers x-forwarded-for or x-real-ip)
- Update contracts table: status = 'signed', signed_at = now()
- Insert contract_event: event_type = 'signature_captured', event_data = { signedName, ipAddress, userAgent }
- Trigger PDF regeneration with signature embedded:
  1. Call generate-contract-pdf Edge Function via `supabase.functions.invoke('generate-contract-pdf', { body: { contractId: contract.id } })` — the Edge Function will fetch the full contract data including the newly-stored signature
  2. Upload the returned PDF buffer to Supabase Storage at `contracts/{contractId}/v{currentVersionNumber + 1}.pdf` using `supabase.storage.from('contracts').upload(path, pdfBuffer, { contentType: 'application/pdf' })`
  3. Create a new contract_version record: `{ contract_id: contractId, version_number: currentVersionNumber + 1, pdf_storage_path: path, generated_at: now(), changes_description: 'Signed by client' }`
  4. Update contract.current_version_id to the new version's ID
- Return { success: true }

Use Supabase server client (createClient from @/lib/supabase/server) with service role for admin operations.
  </action>
  <verify>
Run: `ls "web/app/contracts/[id]/sign/"` to verify page and layout files exist.
Run: `ls web/app/api/contracts/` to verify API route directory exists.
Run: `cd /Users/sabineresoagli/GitHub/sitemedic/web && pnpm build 2>&1 | tail -10` to verify build succeeds.
  </verify>
  <done>
Public signing page renders contract details and signature pad. Client can view agreement and sign with canvas or typed name. Signature submission updates database with audit trail (IP, timestamp, user agent). Already-signed contracts show read-only view.
  </done>
</task>

</tasks>

<verification>
1. react-signature-canvas installed in web/package.json
2. Signing page accessible at /contracts/[token]/sign without authentication
3. SignaturePad renders canvas for drawing and input for typed name
4. ContractViewer displays all contract sections (parties, site, booking, pricing, payment, terms)
5. Signature submission updates contract status and stores audit data
6. Already-signed contracts show read-only view with signature displayed
</verification>

<success_criteria>
- Client receives link, views agreement in browser, signs digitally
- Signature captured as base64 PNG with audit trail (who, when, IP)
- Contract status transitions: sent -> viewed -> signed
- Fallback typed name signing available for accessibility
- Build passes with no TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/04.6-customer-onboarding-contract-management/04.6-03-SUMMARY.md`
</output>
