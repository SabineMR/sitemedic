---
phase: 04.6-customer-onboarding-contract-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/017_contract_management.sql
  - web/lib/contracts/types.ts
  - web/lib/contracts/workflow.ts
  - web/lib/contracts/payment-schedules.ts
autonomous: true

must_haves:
  truths:
    - "Contract lifecycle states follow defined state machine (draft -> sent -> viewed -> signed -> completed -> active -> fulfilled)"
    - "Payment schedule types calculate correct amounts for all 5 term options"
    - "State transitions are validated and invalid transitions are rejected"
  artifacts:
    - path: "supabase/migrations/017_contract_management.sql"
      provides: "Database tables for contracts, versions, events, templates, and storage bucket"
      contains: "CREATE TABLE contracts"
    - path: "web/lib/contracts/types.ts"
      provides: "TypeScript types for contracts, versions, events, payment schedules"
      exports: ["ContractStatus", "ContractData", "PaymentTerms", "PaymentSchedule"]
    - path: "web/lib/contracts/workflow.ts"
      provides: "Contract state machine with transition validation"
      exports: ["canTransition", "VALID_TRANSITIONS"]
    - path: "web/lib/contracts/payment-schedules.ts"
      provides: "Payment schedule calculation for all 5 term types"
      exports: ["calculatePaymentSchedule", "PaymentTerms"]
  key_links:
    - from: "web/lib/contracts/types.ts"
      to: "supabase/migrations/017_contract_management.sql"
      via: "TypeScript types mirror database columns"
      pattern: "ContractStatus.*draft.*sent.*viewed.*signed"
    - from: "web/lib/contracts/workflow.ts"
      to: "web/lib/contracts/types.ts"
      via: "imports ContractStatus type"
      pattern: "import.*ContractStatus.*from.*types"
---

<objective>
Create the database schema, TypeScript types, state machine, and payment schedule logic for the contract management system.

Purpose: This is the foundation for the entire Phase 4.6. All subsequent plans depend on these types, database tables, and business logic. The state machine prevents invalid contract transitions (e.g., can't sign a draft that hasn't been sent), and payment schedules calculate correct amounts for all 5 payment term options.

Output: Database migration (017), TypeScript types, state machine module, payment schedule calculator.
</objective>

<execution_context>
@/Users/sabineresoagli/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sabineresoagli/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@supabase/migrations/002_business_operations.sql
@.planning/phases/04.6-customer-onboarding-contract-management/04.6-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create database migration for contract management tables</name>
  <files>supabase/migrations/017_contract_management.sql</files>
  <action>
Create migration 017_contract_management.sql with 4 tables and 1 storage bucket:

**Table: contract_templates**
- id UUID PK DEFAULT uuid_generate_v4()
- name TEXT NOT NULL (e.g., "Standard Service Agreement")
- description TEXT
- clauses JSONB NOT NULL DEFAULT '[]' (array of {title, body, required, order})
- terms_and_conditions TEXT NOT NULL (legal boilerplate)
- cancellation_policy TEXT NOT NULL
- is_default BOOLEAN DEFAULT FALSE
- version INT DEFAULT 1
- status TEXT NOT NULL DEFAULT 'active' CHECK IN ('active', 'archived')
- created_by UUID REFERENCES auth.users(id)
- created_at TIMESTAMPTZ DEFAULT NOW()
- updated_at TIMESTAMPTZ DEFAULT NOW()

**Table: contracts**
- id UUID PK DEFAULT uuid_generate_v4()
- booking_id UUID NOT NULL REFERENCES bookings(id) ON DELETE RESTRICT
- client_id UUID NOT NULL REFERENCES clients(id) ON DELETE RESTRICT
- template_id UUID REFERENCES contract_templates(id)
- current_version_id UUID (FK added after contract_versions table created)
- status TEXT NOT NULL DEFAULT 'draft' CHECK IN ('draft', 'sent', 'viewed', 'signed', 'completed', 'active', 'fulfilled', 'amended', 'terminated')
- payment_terms TEXT NOT NULL DEFAULT 'full_prepay' CHECK IN ('full_prepay', 'split_50_50', 'split_50_net30', 'full_net30', 'custom')
- custom_terms_description TEXT (only for custom payment terms)
- upfront_amount DECIMAL(10,2) DEFAULT 0
- completion_amount DECIMAL(10,2) DEFAULT 0
- net30_amount DECIMAL(10,2) DEFAULT 0
- upfront_paid_at TIMESTAMPTZ
- completion_paid_at TIMESTAMPTZ
- net30_paid_at TIMESTAMPTZ
- stripe_payment_intent_id TEXT (for authorization holds)
- requires_signature_before_booking BOOLEAN DEFAULT TRUE
- internal_review_completed_at TIMESTAMPTZ
- sent_at TIMESTAMPTZ
- viewed_at TIMESTAMPTZ
- signed_at TIMESTAMPTZ
- completed_at TIMESTAMPTZ
- fulfilled_at TIMESTAMPTZ
- terminated_at TIMESTAMPTZ
- termination_reason TEXT
- shareable_token TEXT UNIQUE (UUID for public signing link)
- created_by UUID REFERENCES auth.users(id)
- created_at TIMESTAMPTZ DEFAULT NOW()
- updated_at TIMESTAMPTZ DEFAULT NOW()

Add indexes on: booking_id, client_id, status, shareable_token, template_id.

**Table: contract_versions**
- id UUID PK DEFAULT uuid_generate_v4()
- contract_id UUID NOT NULL REFERENCES contracts(id) ON DELETE CASCADE
- version INT NOT NULL DEFAULT 1
- storage_path TEXT NOT NULL (e.g., 'contracts/{contractId}/v{version}.pdf')
- generated_at TIMESTAMPTZ DEFAULT NOW()
- generated_by UUID REFERENCES auth.users(id)
- changes TEXT (description of what changed from previous version)
- previous_version_id UUID REFERENCES contract_versions(id)
- client_signature_data TEXT (base64 PNG of signature)
- client_signed_name TEXT (typed name fallback)
- signed_at TIMESTAMPTZ
- signed_by_email TEXT
- signed_by_ip TEXT (IP address for audit)
- UNIQUE(contract_id, version)

Add index on contract_id.

After creating contract_versions, add FK from contracts.current_version_id to contract_versions.id:
```sql
ALTER TABLE contracts ADD CONSTRAINT fk_current_version
  FOREIGN KEY (current_version_id) REFERENCES contract_versions(id);
```

**Table: contract_events**
- id UUID PK DEFAULT uuid_generate_v4()
- contract_id UUID NOT NULL REFERENCES contracts(id) ON DELETE CASCADE
- event_type TEXT NOT NULL (e.g., 'status_change', 'email_sent', 'email_opened', 'email_clicked', 'signature_captured', 'payment_captured', 'version_created')
- event_data JSONB DEFAULT '{}' (flexible payload per event type)
- actor_id UUID REFERENCES auth.users(id) (NULL for system events)
- actor_ip TEXT
- created_at TIMESTAMPTZ DEFAULT NOW()

Add indexes on: contract_id, event_type, created_at.

**Storage bucket:**
```sql
INSERT INTO storage.buckets (id, name, public, file_size_limit, allowed_mime_types)
VALUES ('contracts', 'contracts', false, 10485760, ARRAY['application/pdf']);
```

Add RLS policy for contracts bucket allowing authenticated users to read their own contracts and service_role to manage all.

Add comments on all tables explaining their purpose.
  </action>
  <verify>
Run: `grep -c "CREATE TABLE" supabase/migrations/017_contract_management.sql` should return 4.
Run: `grep "contracts" supabase/migrations/017_contract_management.sql | head -5` to verify table references.
  </verify>
  <done>
4 tables (contract_templates, contracts, contract_versions, contract_events) exist in migration with proper FKs, indexes, constraints, and comments. Storage bucket 'contracts' created with PDF-only mime type.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create TypeScript types, state machine, and payment schedule logic</name>
  <files>
    web/lib/contracts/types.ts
    web/lib/contracts/workflow.ts
    web/lib/contracts/payment-schedules.ts
  </files>
  <action>
**web/lib/contracts/types.ts:**
Define TypeScript types mirroring database schema:
- `ContractStatus` union type: 'draft' | 'sent' | 'viewed' | 'signed' | 'completed' | 'active' | 'fulfilled' | 'amended' | 'terminated'
- `PaymentTerms` union type: 'full_prepay' | 'split_50_50' | 'split_50_net30' | 'full_net30' | 'custom'
- `ContractTemplate` interface matching contract_templates table
- `Contract` interface matching contracts table (with optional relations: booking, client, template, currentVersion)
- `ContractVersion` interface matching contract_versions table
- `ContractEvent` interface matching contract_events table
- `ContractData` interface for PDF generation input (client info, site details, booking details, pricing breakdown, payment schedule)
- `PaymentSchedule` interface: { terms: PaymentTerms; upfrontAmount: number; completionAmount: number; net30Amount: number; description: string }
- Helper type `ContractWithRelations` that includes booking, client, template, versions, and events

**web/lib/contracts/workflow.ts:**
Implement contract state machine from Research Pattern 6:
- `VALID_TRANSITIONS` record mapping each status to array of allowed next statuses:
  - draft -> [sent, terminated]
  - sent -> [viewed, signed, terminated] (signed allowed without viewed - client may sign directly)
  - viewed -> [signed, terminated]
  - signed -> [completed, terminated]
  - completed -> [active, amended, terminated]
  - active -> [fulfilled, terminated]
  - fulfilled -> [] (terminal)
  - amended -> [sent] (re-send after amendments)
  - terminated -> [] (terminal)
- `canTransition(from, to)` function returning boolean
- `STATUS_LABELS` record mapping status to human-readable labels (e.g., 'draft' -> 'Draft', 'sent' -> 'Sent to Client')
- `STATUS_COLORS` record mapping status to Tailwind color classes for badges (draft=gray, sent=blue, viewed=indigo, signed=green, completed=emerald, active=teal, fulfilled=slate, amended=amber, terminated=red)
- Export all.

**web/lib/contracts/payment-schedules.ts:**
- `PAYMENT_TERMS_OPTIONS` array of { value: PaymentTerms, label: string, description: string } for all 5 options
- `calculatePaymentSchedule(total: number, terms: PaymentTerms, customUpfront?: number, customCompletion?: number, customNet30?: number)` function:
  - full_prepay: upfront = total, completion = 0, net30 = 0
  - split_50_50: upfront = total/2, completion = total/2, net30 = 0
  - split_50_net30: upfront = total/2, completion = 0, net30 = total/2
  - full_net30: upfront = 0, completion = 0, net30 = total
  - custom: use provided amounts (with validation that they sum to total)
  - Round all amounts to 2 decimal places
  - Return PaymentSchedule with description string (e.g., "50% (£500.00) due upon signing, 50% (£500.00) due 30 days after service completion")
- `formatPaymentDescription(schedule: PaymentSchedule)` helper function
- `isNet30Eligible(clientPaymentTerms: string)` returns boolean (only net_30 clients can use net30-related terms)
- Export all.
  </action>
  <verify>
Run: `cd /Users/sabineresoagli/GitHub/sitemedic/web && npx tsc --noEmit lib/contracts/types.ts lib/contracts/workflow.ts lib/contracts/payment-schedules.ts 2>&1 | head -20`
Verify no TypeScript errors in the 3 files.
  </verify>
  <done>
Types mirror database schema. State machine validates all 9 contract statuses with correct transitions. Payment schedule calculates correct amounts for all 5 term types with GBP formatting. All exports available for downstream plans.
  </done>
</task>

</tasks>

<verification>
1. Migration file has 4 CREATE TABLE statements with proper FKs and constraints
2. TypeScript types compile without errors
3. State machine covers all 9 statuses with valid transitions
4. Payment schedule calculation returns correct amounts for each term type
5. All files exist at specified paths
</verification>

<success_criteria>
- Database migration ready for deployment with contracts, versions, events, and templates tables
- TypeScript types provide type safety for entire contract system
- State machine prevents invalid status transitions
- Payment schedule calculator handles all 5 term types with correct math
</success_criteria>

<output>
After completion, create `.planning/phases/04.6-customer-onboarding-contract-management/04.6-01-SUMMARY.md`
</output>
