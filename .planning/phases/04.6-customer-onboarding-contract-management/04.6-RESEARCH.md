# Phase 4.6: Customer Onboarding & Contract Management - Research

**Researched:** 2026-02-16
**Domain:** Contract lifecycle management, digital signatures, PDF generation, payment schedules
**Confidence:** HIGH

## Summary

Phase 4.6 builds automated service agreement generation with digital signature collection, flexible payment schedules, and document tracking. The research identified that **native signature capture with react-signature-canvas + @react-pdf/renderer** is the optimal solution over DocuSign/HelloSign API integrations due to cost efficiency, existing stack alignment, and simpler implementation. The project already uses @react-pdf/renderer 4.3.2 for weekly safety reports and react-native-signature-canvas in mobile—extending this pattern to web contracts is straightforward.

Key findings: **Stripe Payment Intents with manual capture** enables split payment workflows (authorize upfront, capture on milestones), **Supabase Storage requires custom versioning** via database metadata tracking, and **Resend webhooks** provide email tracking (sent, opened, viewed) for document delivery status.

The standard approach is template-based PDF generation with data auto-fill, client signature via HTML5 canvas, PDF storage with audit trail in database, and Stripe authorization holds for flexible payment terms.

**Primary recommendation:** Build native signature solution with react-signature-canvas + @react-pdf/renderer, use Stripe manual capture for split payments, implement custom document versioning in database, and leverage Resend webhooks for email tracking.

## Standard Stack

The established libraries/tools for this domain:

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| @react-pdf/renderer | 4.3.2 | PDF generation from React components | Already in use for safety reports, 860K weekly downloads, active maintenance |
| react-signature-canvas | ^4.x | HTML5 canvas signature capture | 100% test coverage, TypeScript support, wraps battle-tested signature_pad library |
| Stripe Payment Intents | v20.3.1 | Payment authorization and capture | Already integrated, supports manual capture for split payments |
| Resend | Latest | Transactional email with webhooks | Already in use for reports, webhook support for tracking |
| Supabase Storage | 2.95.3 | PDF file storage and signed URLs | Already integrated, 7-day signed URLs established pattern |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| signature_pad | ^5.x | Underlying canvas drawing library | Powers react-signature-canvas, handles Bézier curves for smooth signatures |
| jsPDF | 4.1.0 | PDF manipulation (if needed) | Already in project for CSV/PDF exports, use only if @react-pdf/renderer insufficient |
| date-fns | 4.1.0 | Date formatting and calculations | Already in project, use for payment schedule calculations |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Native signature | DocuSign API | DocuSign costs $600-5760/year for developer API, complex integration, external dependency vs free native solution |
| Native signature | HelloSign/Dropbox Sign | Less restrictive rate limits than DocuSign but still paid service, less control over UX |
| Manual versioning | Native storage versioning | Supabase Storage lacks native versioning (as of 2026), must build custom solution anyway |
| Stripe manual capture | Third-party escrow | Stripe already integrated, manual capture is built-in feature, no additional service needed |

**Installation:**
```bash
# Web dependencies (from web/ directory)
pnpm add react-signature-canvas
pnpm add --save-dev @types/react-signature-canvas

# Already installed:
# - @react-pdf/renderer (used in Supabase Edge Functions)
# - stripe (v20.3.1)
# - @stripe/stripe-js and @stripe/react-stripe-js
# - Resend (via Supabase Edge Functions)
```

## Architecture Patterns

### Recommended Project Structure
```
web/
├── app/
│   ├── (dashboard)/
│   │   └── contracts/
│   │       ├── page.tsx              # Contract list/dashboard
│   │       ├── [id]/
│   │       │   ├── page.tsx          # Contract detail view
│   │       │   └── sign/page.tsx     # Client signature page
│   │       └── templates/page.tsx    # Admin template management
│   └── api/
│       └── contracts/
│           ├── create/route.ts       # Generate contract from booking
│           ├── send/route.ts         # Send contract via email
│           └── webhooks/route.ts     # Resend email tracking webhooks
├── components/
│   └── contracts/
│       ├── signature-pad.tsx         # Reusable signature canvas component
│       ├── contract-viewer.tsx       # PDF viewer in browser
│       ├── payment-terms-select.tsx  # Payment schedule selector
│       └── contract-status-badge.tsx # Status indicator
└── lib/
    └── contracts/
        ├── types.ts                  # Contract data types
        ├── templates.ts              # Agreement template definitions
        └── versioning.ts             # Document version tracking logic

supabase/
├── functions/
│   └── generate-contract-pdf/
│       ├── index.tsx                 # Edge Function entry point
│       ├── components/
│       │   ├── ContractDocument.tsx  # Main PDF structure
│       │   ├── ServiceTerms.tsx      # Terms and conditions section
│       │   └── PaymentSchedule.tsx   # Payment breakdown table
│       └── templates/
│           └── service-agreement.ts  # Default template data
└── migrations/
    └── 017_contract_management.sql   # Tables for contracts, versions, signatures
```

### Pattern 1: Template-Based PDF Generation with Auto-Fill
**What:** Create service agreements by merging booking data into PDF templates
**When to use:** All contract generation scenarios - reuse existing @react-pdf/renderer pattern from safety reports
**Example:**
```typescript
// Source: Existing pattern from supabase/functions/generate-weekly-report/index.tsx
import { renderToBuffer } from 'npm:@react-pdf/renderer@4.3.2';

interface ContractData {
  client: { companyName: string; contactName: string; address: string };
  site: { name: string; address: string; postcode: string };
  booking: { date: string; hours: number; shiftStart: string; shiftEnd: string };
  pricing: { baseRate: number; total: number; vat: number; terms: string };
  paymentSchedule: { upfrontAmount: number; completionAmount: number; net30Amount: number };
}

async function generateContractPDF(contractData: ContractData): Promise<Uint8Array> {
  // Auto-fill template with booking data
  const pdfBuffer = await renderToBuffer(
    <ContractDocument data={contractData} />
  );

  return pdfBuffer;
}
```

### Pattern 2: Native Signature Capture with Canvas
**What:** Capture client signatures using HTML5 canvas, export as base64 PNG, embed in PDF
**When to use:** All signature collection scenarios - avoids external API costs
**Example:**
```typescript
// Source: https://github.com/agilgur5/react-signature-canvas
'use client';

import { useRef } from 'react';
import SignatureCanvas from 'react-signature-canvas';

export function SignaturePad({ onSave }: { onSave: (signature: string) => void }) {
  const sigCanvas = useRef<SignatureCanvas>(null);

  const handleSave = () => {
    if (sigCanvas.current && !sigCanvas.current.isEmpty()) {
      // Export as base64 PNG (same pattern as mobile treatment signatures)
      const signatureDataURL = sigCanvas.current.toDataURL('image/png');
      onSave(signatureDataURL);
    }
  };

  return (
    <div className="border-2 border-gray-300 rounded-lg">
      <SignatureCanvas
        ref={sigCanvas}
        canvasProps={{
          width: 500,
          height: 200,
          className: 'signature-canvas'
        }}
        penColor="#1e293b"
        backgroundColor="#ffffff"
      />
      <button onClick={() => sigCanvas.current?.clear()}>Clear</button>
      <button onClick={handleSave}>Save Signature</button>
    </div>
  );
}
```

### Pattern 3: Stripe Manual Capture for Split Payments
**What:** Authorize payment upfront, capture in parts based on payment schedule
**When to use:** Split payment terms (half upfront, half on completion)
**Example:**
```typescript
// Source: https://docs.stripe.com/payments/place-a-hold-on-a-payment-method
import Stripe from 'stripe';

async function createSplitPaymentIntent(total: number, upfrontPercent: number) {
  const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!);

  // Create PaymentIntent with manual capture (holds funds for 7 days)
  const paymentIntent = await stripe.paymentIntents.create({
    amount: total * 100, // Amount in cents
    currency: 'gbp',
    capture_method: 'manual', // Key: don't capture immediately
    metadata: {
      upfrontPercent,
      bookingId: '...',
      paymentSchedule: 'split'
    }
  });

  return paymentIntent;
}

async function captureUpfrontPayment(paymentIntentId: string, upfrontAmount: number) {
  const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!);

  // Capture partial amount (upfront payment)
  await stripe.paymentIntents.capture(paymentIntentId, {
    amount_to_capture: upfrontAmount * 100
  });
}

// Later: capture remaining amount on completion
async function captureCompletionPayment(paymentIntentId: string, remainingAmount: number) {
  const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!);

  await stripe.paymentIntents.capture(paymentIntentId, {
    amount_to_capture: remainingAmount * 100
  });
}
```

### Pattern 4: Document Versioning via Database Metadata
**What:** Track document versions and audit trail in database, not storage layer
**When to use:** All contract updates, amendments, re-generations
**Example:**
```typescript
// Source: https://bootstrapped.app/guide/how-to-implement-file-versioning-in-supabase-storage
interface ContractVersion {
  id: string;
  contractId: string;
  version: number;
  storagePath: string; // e.g., contracts/ABC123/v1.pdf
  generatedAt: string;
  generatedBy: string;
  changes: string; // JSON of what changed
  previousVersionId: string | null;
  signedAt: string | null;
  signedBy: string | null;
  signatureDataUrl: string | null; // base64 PNG
}

async function createNewVersion(
  contractId: string,
  previousVersion: ContractVersion | null
): Promise<ContractVersion> {
  const newVersion = previousVersion ? previousVersion.version + 1 : 1;
  const storagePath = `contracts/${contractId}/v${newVersion}.pdf`;

  // Generate PDF and upload to storage
  const pdfBuffer = await generateContractPDF(contractData);
  await supabase.storage.from('contracts').upload(storagePath, pdfBuffer);

  // Save metadata in database
  const { data } = await supabase.from('contract_versions').insert({
    contractId,
    version: newVersion,
    storagePath,
    previousVersionId: previousVersion?.id || null,
    changes: JSON.stringify({ reason: 'Updated payment terms' })
  }).select().single();

  return data;
}
```

### Pattern 5: Resend Webhooks for Email Tracking
**What:** Track when clients open, view, and interact with contract emails
**When to use:** All contract delivery scenarios - update status in real-time
**Example:**
```typescript
// Source: https://resend.com/docs/webhooks/introduction
// API Route: app/api/contracts/webhooks/route.ts
import { Resend } from 'resend';

export async function POST(req: Request) {
  const payload = await req.json();

  // Resend sends events: email.sent, email.delivered, email.opened, email.clicked, email.bounced
  const { type, data } = payload;

  if (type === 'email.opened') {
    // Update contract status to "viewed"
    await supabase
      .from('contracts')
      .update({
        status: 'viewed',
        viewedAt: new Date().toISOString()
      })
      .eq('id', data.metadata.contractId);
  }

  // Log event in audit trail
  await supabase.from('contract_events').insert({
    contractId: data.metadata.contractId,
    eventType: type,
    eventData: data,
    timestamp: new Date().toISOString()
  });

  return new Response('OK', { status: 200 });
}
```

### Pattern 6: Contract Lifecycle State Machine
**What:** Manage contract status transitions with validation
**When to use:** All status updates - prevents invalid state transitions
**Example:**
```typescript
// Source: https://juro.com/learn/contract-lifecycle-stages
type ContractStatus =
  | 'draft'           // Generated, not sent
  | 'sent'            // Emailed to client
  | 'viewed'          // Client opened email/viewed PDF
  | 'signed'          // Client signature captured
  | 'completed'       // All parties signed, binding
  | 'amended'         // Terms changed, needs re-signing
  | 'terminated';     // Contract cancelled/voided

const VALID_TRANSITIONS: Record<ContractStatus, ContractStatus[]> = {
  draft: ['sent', 'terminated'],
  sent: ['viewed', 'signed', 'terminated'],
  viewed: ['signed', 'terminated'],
  signed: ['completed', 'amended', 'terminated'],
  completed: ['amended', 'terminated'],
  amended: ['sent'], // Re-send after amendments
  terminated: [] // Terminal state
};

function canTransition(from: ContractStatus, to: ContractStatus): boolean {
  return VALID_TRANSITIONS[from].includes(to);
}

async function updateContractStatus(contractId: string, newStatus: ContractStatus) {
  const { data: contract } = await supabase
    .from('contracts')
    .select('status')
    .eq('id', contractId)
    .single();

  if (!canTransition(contract.status, newStatus)) {
    throw new Error(`Invalid transition: ${contract.status} -> ${newStatus}`);
  }

  await supabase
    .from('contracts')
    .update({ status: newStatus })
    .eq('id', contractId);
}
```

### Anti-Patterns to Avoid
- **Storing signatures as files in Storage:** Store as base64 in database for faster retrieval and simpler audit trail (same pattern as mobile treatment signatures)
- **Generating new PDF on every view:** Generate once, cache in Storage, serve via signed URL (7-day expiry per existing pattern)
- **Emailing PDFs as attachments:** Send links to web viewer + download option (better tracking, smaller emails, client can review before downloading)
- **Capturing full payment upfront for split terms:** Use Stripe manual capture to hold funds, capture in parts per schedule
- **Allowing contract edits after signing:** Create new version, invalidate old, require re-signature (immutability for legal validity)

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| PDF form filling | Custom PDF parser | @react-pdf/renderer with templates | Already in use, handles complex layouts, type-safe components vs brittle PDF field mapping |
| Signature drawing | Canvas event handlers | react-signature-canvas | Handles pressure sensitivity, smooth Bézier curves, touch/mouse compatibility, export formats |
| Email tracking | Custom tracking pixels | Resend webhooks | Built-in events (sent, opened, clicked), reliable delivery, already integrated |
| Payment authorization holds | Database payment states | Stripe manual capture | 7-day hold built-in, PCI compliant, handles edge cases (expired holds, partial captures) |
| Document encryption | Custom crypto | Supabase Storage RLS + signed URLs | Server-side encryption at rest, time-limited access, already in use for safety reports |
| Contract templates | String interpolation | React components (@react-pdf/renderer) | Type-safe data binding, reusable sections, easier to maintain complex layouts |
| Version comparison | Text diff algorithms | Database changelog with JSON changes | Simpler to implement, sufficient for contract changes (pricing, dates, terms) |

**Key insight:** PDF generation and signatures are deceptively complex—smooth signature drawing requires Bézier curve interpolation, PDF layouts need careful coordinate mapping, and payment holds have strict PCI compliance requirements. Use battle-tested libraries that handle these edge cases.

## Common Pitfalls

### Pitfall 1: Contract Version Sprawl Without Single Source of Truth
**What goes wrong:** Multiple unsigned drafts, confusion over which version is current, clients signing outdated agreements
**Why it happens:** Lack of version control discipline, allowing edits without creating formal versions
**How to avoid:**
- Single `contracts` table with `currentVersionId` foreign key pointing to latest version in `contract_versions` table
- Immutable versions once sent (create new version for amendments, invalidate old)
- Clear UI showing version history timeline with "Draft", "Sent", "Superseded", "Active" badges
**Warning signs:** Clients asking "which version should I sign?", admin creating duplicate contracts for same booking

### Pitfall 2: Stripe Authorization Expiry (7-Day Limit)
**What goes wrong:** Payment Intent authorization expires after 7 days, cannot capture funds, must re-authorize with client
**Why it happens:** Contracts take >7 days to sign, or completion milestone not triggered within 7 days of signing
**How to avoid:**
- For Net 30 terms: Don't authorize upfront, charge on invoice due date (no hold needed)
- For split payments: Only authorize when contract is signed (not when generated), capture upfront portion immediately
- Set calendar reminder to capture within 5 days of authorization (2-day buffer)
- Handle expired holds gracefully: notify client, request new payment method, create new PaymentIntent
**Warning signs:** Stripe capture errors with "payment_intent_unexpected_state", client complaining about multiple authorization holds

### Pitfall 3: Insufficient Internal Review Time Before Client Signature
**What goes wrong:** Contracts sent to clients with errors (wrong pricing, incorrect dates, typos), require embarrassing retractions and amendments
**Why it happens:** Rushing to send contracts during phone calls, skipping internal review step, auto-generating without human verification
**How to avoid:**
- Two-stage workflow: "Draft" status for internal review, "Sent" after admin approval
- Checklist before send: Pricing matches booking, dates correct, client details accurate, payment terms match client account
- Preview button that shows exactly what client will see (PDF + email)
- For phone sales: Generate draft during call, send after call with 5-minute review window
**Warning signs:** Frequent contract amendments immediately after sending, client confusion about terms

### Pitfall 4: No Fallback for Clients Who Can't Use Digital Signatures
**What goes wrong:** Client unable to sign on mobile/tablet (browser incompatibility, poor internet), booking delayed, revenue lost
**Why it happens:** Assuming all clients have modern browsers and stable internet, no alternative signing method
**How to avoid:**
- Provide multiple signing methods: Canvas signature (primary), typed name + checkbox (fallback), upload scanned signature (last resort)
- Test signature pad on iOS Safari, Android Chrome, desktop browsers (touch vs mouse events)
- Offline-capable signature: Allow signature capture without internet, submit when reconnected
- Phone option: Admin can sign on client's behalf during phone call with verbal consent (logged in audit trail)
**Warning signs:** Support requests about signature not saving, abandoned signing sessions, increased phone support calls

### Pitfall 5: Disorganized Contract Storage and Missed Renewals
**What goes wrong:** Cannot find signed contracts, missed renewal dates lock clients into unwanted terms, disputes over agreed terms
**Why it happens:** Storing PDFs with inconsistent naming, no centralized tracking, no renewal alerts
**How to avoid:**
- Consistent storage path: `contracts/{clientId}/{bookingId}/v{version}.pdf` (organized by client, then booking)
- Database as source of truth: All contract metadata (status, dates, terms, signers) in `contracts` table, storage only for PDF files
- Automated renewal notifications: Query contracts where `status = 'completed'` and `expiryDate - NOW() < 30 days`, send alerts
- Search functionality: Full-text search on client name, site name, booking dates, contract terms
**Warning signs:** Admin asking "where is the contract for X?", clients disputing agreed terms, missed cancellation deadlines

### Pitfall 6: Unclear and Inconsistent Contract Language
**What goes wrong:** Clients sign without understanding obligations, disputes arise, legal costs incurred, contracts unenforceable
**Why it happens:** Copy-pasting legalese from generic templates, no lawyer review, inconsistent terminology across documents
**How to avoid:**
- Have lawyer review base template once, reuse with variable fields only (dates, pricing, names)
- Plain English summaries above legal sections (e.g., "In plain English: You pay 50% upfront, 50% when we complete the work")
- Consistent terminology: "Client" not "Customer/Buyer", "Medic" not "Service Provider/Contractor"
- Highlight key terms: Bold or colored text for payment amounts, dates, cancellation terms
- Version control on template changes: Track when legal language updated, re-review old contracts if needed
**Warning signs:** Clients asking "what does this mean?", disputes over interpretation, contracts deemed unenforceable in disputes

### Pitfall 7: Ignoring Data Validation Before PDF Generation
**What goes wrong:** PDFs generated with missing data (blank fields), incorrect calculations, invalid postcodes, broken layouts
**Why it happens:** Assuming booking data is complete and valid, no validation layer before PDF generation
**How to avoid:**
- Validation schema before generation: Zod/Yup schema matching ContractData type, validate all required fields
- Calculation verification: Assert pricing math correct (base + urgency + VAT = total), fail loudly if mismatch
- Preview before send: Admin sees generated PDF in browser, confirms correctness before sending to client
- Error handling in Edge Function: Graceful failures with descriptive errors ("Missing client.companyName") not generic "PDF generation failed"
**Warning signs:** PDFs with "[Object object]" text, missing amounts, broken page layouts, calculation mismatches

## Code Examples

Verified patterns from official sources:

### Example 1: Contract PDF Component with Auto-Fill
```typescript
// Source: Adapted from existing generate-weekly-report pattern
// File: supabase/functions/generate-contract-pdf/components/ContractDocument.tsx
import { Document, Page, Text, View, StyleSheet } from 'npm:@react-pdf/renderer@4.3.2';

const styles = StyleSheet.create({
  page: { padding: 40, fontFamily: 'Helvetica', fontSize: 11 },
  header: { fontSize: 18, fontWeight: 'bold', marginBottom: 20 },
  section: { marginBottom: 15 },
  table: { display: 'flex', flexDirection: 'column', marginTop: 10 },
  tableRow: { flexDirection: 'row', borderBottomWidth: 1, borderColor: '#e5e7eb' },
  tableCell: { flex: 1, padding: 8 },
  signatureBox: { marginTop: 30, borderWidth: 1, borderColor: '#000', padding: 10, height: 100 }
});

interface ContractDocumentProps {
  client: { companyName: string; contactName: string; address: string };
  site: { name: string; address: string; postcode: string; contactName: string };
  booking: { date: string; shiftStart: string; shiftEnd: string; hours: number };
  pricing: { baseRate: number; subtotal: number; vat: number; total: number };
  paymentSchedule: { terms: string; upfrontAmount: number; completionAmount: number };
  generatedAt: string;
}

export function ContractDocument({ client, site, booking, pricing, paymentSchedule }: ContractDocumentProps) {
  return (
    <Document>
      <Page size="A4" style={styles.page}>
        {/* Header with auto-filled client info */}
        <View style={styles.header}>
          <Text>SERVICE AGREEMENT</Text>
        </View>

        <View style={styles.section}>
          <Text>This agreement is entered into between:</Text>
          <Text style={{ marginTop: 5, fontWeight: 'bold' }}>
            SiteMedic Ltd (Provider)
          </Text>
          <Text style={{ marginTop: 5 }}>and</Text>
          <Text style={{ marginTop: 5, fontWeight: 'bold' }}>
            {client.companyName} (Client)
          </Text>
          <Text style={{ marginTop: 5 }}>
            Represented by: {client.contactName}
          </Text>
        </View>

        {/* Auto-filled site and booking details */}
        <View style={styles.section}>
          <Text style={{ fontWeight: 'bold' }}>Site Details:</Text>
          <Text>Location: {site.name}, {site.address}, {site.postcode}</Text>
          <Text>On-site Contact: {site.contactName}</Text>
          <Text>Service Date: {booking.date}</Text>
          <Text>Shift Hours: {booking.shiftStart} - {booking.shiftEnd} ({booking.hours} hours)</Text>
        </View>

        {/* Auto-filled pricing breakdown */}
        <View style={styles.section}>
          <Text style={{ fontWeight: 'bold', marginBottom: 5 }}>Pricing:</Text>
          <View style={styles.table}>
            <View style={styles.tableRow}>
              <Text style={styles.tableCell}>Description</Text>
              <Text style={styles.tableCell}>Amount</Text>
            </View>
            <View style={styles.tableRow}>
              <Text style={styles.tableCell}>Base Rate ({booking.hours} hours × £{pricing.baseRate}/hr)</Text>
              <Text style={styles.tableCell}>£{pricing.subtotal.toFixed(2)}</Text>
            </View>
            <View style={styles.tableRow}>
              <Text style={styles.tableCell}>VAT (20%)</Text>
              <Text style={styles.tableCell}>£{pricing.vat.toFixed(2)}</Text>
            </View>
            <View style={[styles.tableRow, { fontWeight: 'bold' }]}>
              <Text style={styles.tableCell}>Total</Text>
              <Text style={styles.tableCell}>£{pricing.total.toFixed(2)}</Text>
            </View>
          </View>
        </View>

        {/* Auto-filled payment terms */}
        <View style={styles.section}>
          <Text style={{ fontWeight: 'bold' }}>Payment Terms: {paymentSchedule.terms}</Text>
          {paymentSchedule.upfrontAmount > 0 && (
            <Text>• Upfront Payment: £{paymentSchedule.upfrontAmount.toFixed(2)} (due upon signing)</Text>
          )}
          {paymentSchedule.completionAmount > 0 && (
            <Text>• Completion Payment: £{paymentSchedule.completionAmount.toFixed(2)} (due upon service completion)</Text>
          )}
        </View>

        {/* Signature section (filled in after client signs) */}
        <View style={styles.signatureBox}>
          <Text>Client Signature:</Text>
          <Text style={{ fontSize: 9, color: '#6b7280', marginTop: 5 }}>
            (Digital signature will be added upon signing)
          </Text>
        </View>

        <Text style={{ fontSize: 8, marginTop: 20, color: '#6b7280' }}>
          Generated: {new Date(generatedAt).toLocaleString('en-GB')}
        </Text>
      </Page>
    </Document>
  );
}
```

### Example 2: Signature Pad with Export
```typescript
// Source: https://github.com/agilgur5/react-signature-canvas
// File: web/components/contracts/signature-pad.tsx
'use client';

import { useRef, useState } from 'react';
import SignatureCanvas from 'react-signature-canvas';
import { Button } from '@/components/ui/button';

interface SignaturePadProps {
  onSave: (signatureDataUrl: string) => Promise<void>;
  contractId: string;
}

export function SignaturePad({ onSave, contractId }: SignaturePadProps) {
  const sigCanvas = useRef<SignatureCanvas>(null);
  const [isSaving, setIsSaving] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleClear = () => {
    sigCanvas.current?.clear();
    setError(null);
  };

  const handleSave = async () => {
    if (!sigCanvas.current || sigCanvas.current.isEmpty()) {
      setError('Please provide a signature before saving');
      return;
    }

    setIsSaving(true);
    setError(null);

    try {
      // Export as base64 PNG (matches mobile treatment signature pattern)
      const signatureDataUrl = sigCanvas.current.toDataURL('image/png');
      await onSave(signatureDataUrl);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to save signature');
    } finally {
      setIsSaving(false);
    }
  };

  return (
    <div className="space-y-4">
      <div className="border-2 border-gray-300 rounded-lg bg-white">
        <SignatureCanvas
          ref={sigCanvas}
          canvasProps={{
            width: 500,
            height: 200,
            className: 'w-full h-full touch-none' // Prevent scrolling on mobile
          }}
          penColor="#1e293b"
          backgroundColor="#ffffff"
          minWidth={1}
          maxWidth={2.5}
          velocityFilterWeight={0.7}
        />
      </div>

      {error && (
        <p className="text-sm text-red-600">{error}</p>
      )}

      <div className="flex gap-2">
        <Button
          type="button"
          variant="outline"
          onClick={handleClear}
          disabled={isSaving}
        >
          Clear
        </Button>
        <Button
          type="button"
          onClick={handleSave}
          disabled={isSaving}
          className="flex-1"
        >
          {isSaving ? 'Saving...' : 'Sign and Complete'}
        </Button>
      </div>

      <p className="text-xs text-gray-500 text-center">
        By signing above, you agree to the terms and conditions of this service agreement
      </p>
    </div>
  );
}
```

### Example 3: Payment Schedule Selector
```typescript
// Source: Project requirements + https://specifi.io/payment-terms
// File: web/components/contracts/payment-terms-select.tsx
'use client';

import { useState } from 'react';
import { Label } from '@/components/ui/label';
import { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group';

type PaymentTerms = 'full_prepay' | 'split_50_50' | 'split_50_net30' | 'full_net30' | 'custom';

interface PaymentTermsSelectProps {
  total: number;
  clientPaymentTerms: 'prepay' | 'net_30'; // From clients table
  onSelect: (terms: PaymentTerms, schedule: PaymentSchedule) => void;
}

interface PaymentSchedule {
  terms: PaymentTerms;
  upfrontAmount: number;
  completionAmount: number;
  net30Amount: number;
  description: string;
}

export function PaymentTermsSelect({ total, clientPaymentTerms, onSelect }: PaymentTermsSelectProps) {
  const [selected, setSelected] = useState<PaymentTerms>('full_prepay');

  const options: Record<PaymentTerms, PaymentSchedule> = {
    full_prepay: {
      terms: 'full_prepay',
      upfrontAmount: total,
      completionAmount: 0,
      net30Amount: 0,
      description: 'Full payment required before service'
    },
    split_50_50: {
      terms: 'split_50_50',
      upfrontAmount: total / 2,
      completionAmount: total / 2,
      net30Amount: 0,
      description: '50% upfront, 50% upon completion'
    },
    split_50_net30: {
      terms: 'split_50_net30',
      upfrontAmount: total / 2,
      completionAmount: 0,
      net30Amount: total / 2,
      description: '50% upfront, 50% Net 30 after completion'
    },
    full_net30: {
      terms: 'full_net30',
      upfrontAmount: 0,
      completionAmount: 0,
      net30Amount: total,
      description: 'Full payment Net 30 (invoice due 30 days after service)'
    },
    custom: {
      terms: 'custom',
      upfrontAmount: 0,
      completionAmount: 0,
      net30Amount: 0,
      description: 'Custom payment terms (set manually)'
    }
  };

  // Filter options based on client payment terms eligibility
  const availableOptions = Object.entries(options).filter(([key]) => {
    if (clientPaymentTerms === 'prepay') {
      // Prepay clients can only use full_prepay or split_50_50
      return key === 'full_prepay' || key === 'split_50_50';
    }
    // Net 30 clients can use all options
    return true;
  });

  const handleSelect = (value: PaymentTerms) => {
    setSelected(value);
    onSelect(value, options[value]);
  };

  return (
    <div className="space-y-4">
      <Label className="text-base font-semibold">Payment Terms</Label>
      <RadioGroup value={selected} onValueChange={handleSelect as (value: string) => void}>
        {availableOptions.map(([key, schedule]) => (
          <div key={key} className="flex items-start space-x-3 p-3 border rounded-lg">
            <RadioGroupItem value={key} id={key} className="mt-1" />
            <div className="flex-1">
              <Label htmlFor={key} className="font-medium cursor-pointer">
                {schedule.description}
              </Label>
              <div className="text-sm text-gray-600 mt-1 space-y-1">
                {schedule.upfrontAmount > 0 && (
                  <p>Upfront: £{schedule.upfrontAmount.toFixed(2)}</p>
                )}
                {schedule.completionAmount > 0 && (
                  <p>On Completion: £{schedule.completionAmount.toFixed(2)}</p>
                )}
                {schedule.net30Amount > 0 && (
                  <p>Net 30: £{schedule.net30Amount.toFixed(2)}</p>
                )}
              </div>
            </div>
          </div>
        ))}
      </RadioGroup>

      {clientPaymentTerms === 'prepay' && (
        <p className="text-sm text-amber-600 bg-amber-50 p-3 rounded-lg">
          This client is on prepay terms. Upgrade to Net 30 to enable invoicing options.
        </p>
      )}
    </div>
  );
}
```

### Example 4: Contract Status Workflow
```typescript
// Source: https://juro.com/learn/contract-lifecycle-stages
// File: web/lib/contracts/workflow.ts
export type ContractStatus =
  | 'draft'      // Generated, internal review
  | 'sent'       // Emailed to client
  | 'viewed'     // Client opened email
  | 'signed'     // Client signed
  | 'completed'  // All parties signed, payment authorized
  | 'active'     // Service in progress
  | 'fulfilled'  // Service completed, final payment captured
  | 'terminated'; // Cancelled or voided

const VALID_TRANSITIONS: Record<ContractStatus, ContractStatus[]> = {
  draft: ['sent', 'terminated'],
  sent: ['viewed', 'signed', 'terminated'],
  viewed: ['signed', 'terminated'],
  signed: ['completed', 'terminated'],
  completed: ['active', 'terminated'],
  active: ['fulfilled', 'terminated'],
  fulfilled: [], // Terminal state
  terminated: [] // Terminal state
};

const TRANSITION_REQUIREMENTS: Record<string, (contract: any) => boolean> = {
  'draft->sent': (c) => c.internalReviewCompletedAt !== null,
  'sent->signed': (c) => c.clientSignature !== null,
  'signed->completed': (c) => c.paymentIntentId !== null,
  'completed->active': (c) => c.booking.status === 'confirmed',
  'active->fulfilled': (c) => c.booking.status === 'completed' && c.finalPaymentCapturedAt !== null
};

export function canTransition(
  from: ContractStatus,
  to: ContractStatus,
  contract?: any
): boolean {
  // Check if transition is allowed in state machine
  if (!VALID_TRANSITIONS[from].includes(to)) {
    return false;
  }

  // Check additional requirements if contract data provided
  if (contract) {
    const key = `${from}->${to}`;
    const requirement = TRANSITION_REQUIREMENTS[key];
    if (requirement && !requirement(contract)) {
      return false;
    }
  }

  return true;
}

export async function transitionContractStatus(
  contractId: string,
  newStatus: ContractStatus,
  metadata?: Record<string, any>
) {
  const supabase = createClient();

  // Fetch current contract
  const { data: contract, error } = await supabase
    .from('contracts')
    .select('*, booking:bookings(*)')
    .eq('id', contractId)
    .single();

  if (error) throw error;

  // Validate transition
  if (!canTransition(contract.status, newStatus, contract)) {
    throw new Error(
      `Invalid transition: ${contract.status} -> ${newStatus}. ` +
      `Requirements not met or invalid workflow.`
    );
  }

  // Update status with metadata
  const updates: any = {
    status: newStatus,
    updatedAt: new Date().toISOString(),
    ...metadata
  };

  // Add timestamp fields based on new status
  if (newStatus === 'sent') updates.sentAt = new Date().toISOString();
  if (newStatus === 'viewed') updates.viewedAt = new Date().toISOString();
  if (newStatus === 'signed') updates.signedAt = new Date().toISOString();
  if (newStatus === 'completed') updates.completedAt = new Date().toISOString();
  if (newStatus === 'fulfilled') updates.fulfilledAt = new Date().toISOString();

  await supabase
    .from('contracts')
    .update(updates)
    .eq('id', contractId);

  // Log transition in audit trail
  await supabase.from('contract_events').insert({
    contractId,
    eventType: 'status_change',
    eventData: {
      from: contract.status,
      to: newStatus,
      ...metadata
    },
    timestamp: new Date().toISOString()
  });
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| DocuSign/HelloSign API for all e-signatures | Native signature capture for simple contracts, API for complex multi-party | 2024-2025 | Cost reduction (DocuSign $600+/year), faster UX (no external redirect), full control over design |
| PDF form filling with field mapping | PDF generation from React components | 2023+ (@react-pdf/renderer maturity) | Type-safe templates, easier maintenance, no brittle field name dependencies |
| Email attachments for contracts | Email with links to web viewer | 2022+ (mobile-first world) | Smaller emails, better tracking (view before download), responsive on mobile |
| Full payment capture on authorization | Manual capture with holds | Ongoing (Stripe feature) | Enables split payments, reduces refund complexity, better cash flow for clients |
| Storage-layer versioning | Database metadata versioning | Current (Supabase limitation) | More flexible, easier queries, explicit audit trail, works with any storage backend |

**Deprecated/outdated:**
- **PDF.js for rendering in browser:** Use native browser PDF viewer or embed with `<embed>` tag (faster, better mobile support, no library needed)
- **PDFKit for PDF generation:** @react-pdf/renderer is more React-native, better TypeScript support, component-based API
- **String template interpolation for contracts:** React components provide type safety, reusability, easier testing
- **Storing signed PDFs separately from unsigned:** Store all versions in `contract_versions` table with `signedAt` timestamp, single source of truth

## Open Questions

Things that couldn't be fully resolved:

1. **Legal enforceability of digital signatures in UK construction contracts**
   - What we know: Electronic Signatures Regulations 2002 makes digital signatures legally binding in UK, widely accepted in commercial contracts
   - What's unclear: Whether SiteMedic's specific implementation (HTML5 canvas signature without biometric verification) meets industry standards for construction contracts
   - Recommendation: Get legal sign-off on signature capture method, include "I agree" checkbox + timestamp alongside signature for stronger evidence of intent

2. **Optimal contract template structure for multi-site clients**
   - What we know: Current design assumes one contract per booking, works for single-site bookings
   - What's unclear: Whether multi-site enterprise clients need master service agreements (MSA) + per-booking work orders instead of standalone contracts
   - Recommendation: Start with per-booking contracts (simpler), add MSA + work order pattern in Phase 6+ if large enterprise clients request it

3. **VAT handling for international clients (non-UK sites)**
   - What we know: Current implementation assumes UK VAT (20%) for all bookings
   - What's unclear: What happens if SiteMedic expands to EU/international sites—VAT rate changes, different tax jurisdictions
   - Recommendation: Hard-code UK VAT for Phase 4.6, add tax jurisdiction logic in international expansion phase (out of current scope)

4. **Contract amendment workflow complexity**
   - What we know: Simple approach is invalidate old contract + create new version + require re-signature
   - What's unclear: Whether clients expect amendment notifications, comparison views, or ability to negotiate changes within platform
   - Recommendation: Start with full re-generation for amendments (simpler), add negotiation workflow if clients request it (low priority)

5. **Resend webhook reliability and event ordering**
   - What we know: Resend sends webhooks for email events (sent, opened, clicked), used for status updates
   - What's unclear: Whether webhook delivery is guaranteed, order of events reliable (e.g., could "opened" arrive before "sent"?)
   - Recommendation: Implement idempotent webhook handlers, use database transactions for status updates, add retry logic for failed deliveries

## Sources

### Primary (HIGH confidence)
- @react-pdf/renderer documentation - https://react-pdf.org/ and https://www.npmjs.com/package/@react-pdf/renderer
- react-signature-canvas GitHub - https://github.com/agilgur5/react-signature-canvas (100% test coverage, TypeScript)
- signature_pad library - https://github.com/szimek/signature_pad (underlying canvas drawing)
- Stripe Payment Intents manual capture - https://docs.stripe.com/payments/place-a-hold-on-a-payment-method
- Stripe PaymentIntent capture API - https://docs.stripe.com/api/payment_intents/capture
- Resend webhooks documentation - https://resend.com/docs/webhooks/introduction
- Resend webhook blog post - https://resend.com/blog/webhooks
- Existing codebase: supabase/functions/generate-weekly-report/ (verified @react-pdf/renderer 4.3.2 usage)
- Existing codebase: web/package.json (verified Stripe v20.3.1, react-papaparse, jsPDF)
- Existing codebase: mobile/package.json (verified react-native-signature-canvas 5.0.2)
- Existing codebase: supabase/migrations/002_business_operations.sql (verified payment_terms, bookings schema)

### Secondary (MEDIUM confidence)
- Contract lifecycle management best practices - https://juro.com/learn/contract-lifecycle-stages (2026 guide)
- Payment flexibility trends 2026 - https://www.paycron.com/blog/payment-flexibility-the-growth-engine-for-u-s-businesses-in-2026/
- Milestone payment implementation - https://corecommissions.com/milestone-based-commission-payments-in-construction/
- Supabase Storage versioning discussion - https://github.com/orgs/supabase/discussions/40482 (native versioning not supported)
- File versioning implementation guide - https://bootstrapped.app/guide/how-to-implement-file-versioning-in-supabase-storage
- Contract management mistakes - https://juro.com/learn/contract-management-mistakes (8 common pitfalls)
- DocuSign vs HelloSign comparison 2026 - https://juro.com/learn/hellosign-vs-docusign-comparison
- DocuSign API pricing - https://ecom.docusign.com/plans-and-pricing/developer ($600-5760/year)
- HelloSign API rate limits - https://www.esignglobal.com/blog/docusign-vs-dropbox-sign-api-rate-limits-pricing-tier-review-2026

### Tertiary (LOW confidence - flagged for validation)
- PDF form validation best practices - https://www.w3.org/WAI/WCAG21/Techniques/pdf/PDF22 (W3C accessibility guidelines, not implementation guide)
- Document portal real-time tracking - https://www.signntrack.com/en-real-time-signature-status/ (vendor marketing, not technical docs)
- Audit trail best practices - https://signal.opshub.me/audit-trail-best-practices/ (general advice, not Supabase-specific)

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - @react-pdf/renderer verified in use, react-signature-canvas is battle-tested (100% coverage), Stripe manual capture is documented feature
- Architecture: HIGH - Patterns adapted from existing weekly-report implementation, verified against official docs
- Pitfalls: MEDIUM - Based on industry articles and CLM best practices, not SiteMedic-specific experience

**Research date:** 2026-02-16
**Valid until:** 2026-03-18 (30 days - stable domain, infrequent breaking changes)

**Key assumptions:**
- UK-only operations (VAT, legal requirements)
- Construction industry contracts (simpler than legal/financial contracts)
- Single-party signature required (client only, not multi-party agreements)
- Web-based signing (not mobile app integration)
- Existing Stripe + Supabase + Resend infrastructure in place
