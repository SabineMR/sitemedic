---
phase: 12-analytics-dashboard
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - web/lib/queries/admin/analytics.ts
autonomous: true

must_haves:
  truths:
    - "All analytics UI tabs can fetch data via TanStack Query hooks"
    - "Auto-assignment success rate data is available weekly for the last 12 weeks"
    - "Medic utilisation data is available per medic with percentage"
    - "Late arrival pattern data is available by medic and day-of-week"
    - "Out-of-territory booking frequency and cost data is available"
    - "All queries include org_id filter for multi-tenant isolation"
  artifacts:
    - path: "web/lib/queries/admin/analytics.ts"
      provides: "All analytics query hooks and fetch functions"
      exports:
        - "useAutoAssignmentStats"
        - "useMedicUtilisation"
        - "useLateArrivalPatterns"
        - "useOutOfTerritoryBookings"
        - "fetchAutoAssignmentStats"
        - "fetchMedicUtilisation"
        - "fetchLateArrivalPatterns"
        - "fetchOutOfTerritoryBookings"
  key_links:
    - from: "web/lib/queries/admin/analytics.ts"
      to: "auto_schedule_logs"
      via: "supabase .from() query with .eq('org_id', orgId)"
      pattern: "from\\('auto_schedule_logs'\\).*eq\\('org_id'"
    - from: "web/lib/queries/admin/analytics.ts"
      to: "medic_alerts"
      via: "supabase .from() query filtered by alert_type='late_arrival'"
      pattern: "from\\('medic_alerts'\\)"
    - from: "web/lib/queries/admin/analytics.ts"
      to: "bookings"
      via: "supabase .from() query for utilisation and OOT bookings"
      pattern: "from\\('bookings'\\)"
---

<objective>
Create the analytics data API layer with TanStack Query hooks for all Phase 12 chart data.

Purpose: All three UI plans (12-01, 12-02, 12-03) depend on these query hooks for data fetching. Building the data layer first enables the UI plans to run in parallel afterward.

Output: `web/lib/queries/admin/analytics.ts` with 4 fetch functions and 4 TanStack Query hooks.
</objective>

<execution_context>
@/Users/sabineresoagli/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sabineresoagli/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@web/lib/queries/admin/revenue.ts (follow this exact pattern for imports, hook structure, staleTime/refetchInterval)
@web/lib/queries/admin/territories.ts (reuse TerritoryWithMetrics type, fetchTerritoriesWithMetrics)
@web/lib/queries/admin/medics.ts (reuse MedicWithMetrics type, fetchMedicsWithMetrics)
@web/lib/territory/hiring-triggers.ts (detectHiringTriggers, groupTriggersByRegion)
@web/lib/territory/coverage-gaps.ts (detectCoverageGaps)
@web/lib/territory/metrics.ts (aggregateTerritoryMetrics)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create analytics query hooks file with all 4 data sources</name>
  <files>web/lib/queries/admin/analytics.ts</files>
  <action>
Create `web/lib/queries/admin/analytics.ts` with 4 fetch functions and 4 TanStack Query hooks. Follow the exact pattern from `revenue.ts` for imports and hook structure.

**Imports (follow revenue.ts pattern exactly):**
```typescript
'use client';
import { useQuery } from '@tanstack/react-query';
import { createClient } from '@/lib/supabase/client';
import type { SupabaseClient } from '@supabase/supabase-js';
import { useRequireOrg } from '@/contexts/org-context';
```

**1. Auto-Assignment Stats (for 12-02 chart)**

Type:
```typescript
export interface WeeklyAssignmentStats {
  week_start: string; // ISO date
  week_label: string; // "W7 2026" format
  total_attempts: number;
  successful: number;
  failed: number;
  success_rate: number; // 0-100
  avg_confidence: number; // 0-100
  top_failure_reason: string | null;
}
```

Fetch function `fetchAutoAssignmentStats(supabase, orgId)`:
- Query `auto_schedule_logs` table DIRECTLY with `.eq('org_id', orgId)` — the table has its own `org_id` column (confirmed in migration 027, NOT NULL constraint).
- Do NOT use a two-step approach via bookings. Query auto_schedule_logs directly:
  ```typescript
  const twelveWeeksAgo = new Date();
  twelveWeeksAgo.setDate(twelveWeeksAgo.getDate() - 84); // 12 weeks

  const { data: logs, error } = await supabase
    .from('auto_schedule_logs')
    .select('id, assignment_successful, failure_reason, confidence_score, created_at')
    .eq('org_id', orgId)
    .gte('created_at', twelveWeeksAgo.toISOString());
  ```
- Group by week using `getISOWeek()` helper (copy from revenue.ts)
- For each week: count total, count where `assignment_successful = true`, calculate rate
- Extract `failure_reason` from failed rows, find most common per week
- Extract `confidence_score` average per week
- Sort by week_start ASC
- CRITICAL: Return empty array if no data (not null/undefined). The chart component must handle empty state.

Hook `useAutoAssignmentStats()`:
```typescript
export function useAutoAssignmentStats() {
  const supabase = createClient();
  const orgId = useRequireOrg();
  return useQuery({
    queryKey: ['admin', 'analytics', 'auto-assignment', orgId],
    queryFn: () => fetchAutoAssignmentStats(supabase, orgId),
    staleTime: 60000,
    refetchInterval: 300000, // 5 min
  });
}
```

**2. Medic Utilisation (for 12-03 table)**

Type:
```typescript
export interface MedicUtilisation {
  medic_id: string;
  medic_name: string;
  utilisation_pct: number; // 0-100
  booked_days: number;
  available_days: number; // always 5 (working days)
  total_shifts_completed: number;
  territory_count: number;
  is_available: boolean;
}
```

Fetch function `fetchMedicUtilisation(supabase, orgId)`:
- To avoid circular dependency, duplicate the minimal query:
  1. Fetch medics: `supabase.from('medics').select('id, first_name, last_name, available_for_work, total_shifts_completed').eq('org_id', orgId)`
  2. Fetch bookings this week (Mon-Sun): `supabase.from('bookings').select('medic_id').eq('org_id', orgId).in('status', ['confirmed', 'in_progress']).gte('shift_date', mondayISO).lte('shift_date', sundayISO)`
  3. Fetch territory assignment counts: `supabase.from('territories').select('primary_medic_id, secondary_medic_id').eq('org_id', orgId)`
  4. Run all 3 in parallel with Promise.all
- Calculate utilisation_pct = (bookings_this_week / 5) * 100, capped at 100
- Count territory assignments per medic (primary + secondary)
- Sort by utilisation_pct DESC (highest first)
- Return empty array if no medics

Hook `useMedicUtilisation()`:
```typescript
export function useMedicUtilisation() {
  const supabase = createClient();
  const orgId = useRequireOrg();
  return useQuery({
    queryKey: ['admin', 'analytics', 'medic-utilisation', orgId],
    queryFn: () => fetchMedicUtilisation(supabase, orgId),
    staleTime: 60000,
    refetchInterval: 300000,
  });
}
```

**3. Late Arrival Patterns (for 12-03 heatmap)**

Type:
```typescript
export interface LateArrivalPattern {
  medic_id: string;
  medic_name: string;
  day_of_week: number; // 0=Sunday, 1=Monday, ..., 6=Saturday
  day_name: string; // "Monday", "Tuesday", etc.
  late_count: number;
}

export interface LateArrivalSummary {
  patterns: LateArrivalPattern[];
  total_late_arrivals: number;
  worst_day: string; // Day name with most late arrivals
  worst_medic: string; // Medic name with most late arrivals
}
```

Fetch function `fetchLateArrivalPatterns(supabase, orgId)`:
- Query `medic_alerts` table
- Filter: `.eq('alert_type', 'late_arrival')` and `.eq('org_id', orgId)`
- Select: `medic_id, triggered_at`
- Join medics for names: fetch medic names separately via Promise.all
- Group by medic_id + day_of_week (extract from triggered_at using `new Date(triggered_at).getDay()`)
- Map day numbers to names: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
- Calculate summary: total, worst_day, worst_medic
- Return empty patterns array and "N/A" for worst_day/worst_medic if no data

Hook `useLateArrivalPatterns()`:
```typescript
export function useLateArrivalPatterns() {
  const supabase = createClient();
  const orgId = useRequireOrg();
  return useQuery({
    queryKey: ['admin', 'analytics', 'late-arrivals', orgId],
    queryFn: () => fetchLateArrivalPatterns(supabase, orgId),
    staleTime: 60000,
    refetchInterval: 300000,
  });
}
```

**4. Out-of-Territory Bookings (for 12-03 chart)**

Type — uses the ACTUAL bookings table columns `out_of_territory_cost` and `out_of_territory_type` (NOT `travel_bonus`/`room_board` which do not exist as separate columns):
```typescript
export interface OutOfTerritoryBooking {
  booking_id: string;
  medic_name: string;
  site_postcode: string;
  shift_date: string;
  out_of_territory_cost: number; // from bookings.out_of_territory_cost
  out_of_territory_type: 'travel_bonus' | 'room_board' | null; // from bookings.out_of_territory_type
}

export interface OOTSummary {
  bookings: OutOfTerritoryBooking[];
  total_oot_bookings: number;
  total_extra_cost: number;
  oot_percentage: number; // % of all bookings that were OOT
}
```

Fetch function `fetchOutOfTerritoryBookings(supabase, orgId)`:
- Query `bookings` table
- Filter: `.eq('org_id', orgId)` and `.gt('out_of_territory_cost', 0)` (out_of_territory_cost > 0 indicates out-of-territory)
- Select: `id, medic_id, site_postcode, shift_date, out_of_territory_cost, out_of_territory_type`
- Also fetch total booking count for this org: `supabase.from('bookings').select('id', { count: 'exact', head: true }).eq('org_id', orgId)`
- Join medic names via separate query
- Calculate total_extra_cost = sum of out_of_territory_cost across all OOT bookings
- Calculate oot_percentage = (oot_count / total_count) * 100
- Return empty bookings array and 0s if no data

Hook `useOutOfTerritoryBookings()`:
```typescript
export function useOutOfTerritoryBookings() {
  const supabase = createClient();
  const orgId = useRequireOrg();
  return useQuery({
    queryKey: ['admin', 'analytics', 'oot-bookings', orgId],
    queryFn: () => fetchOutOfTerritoryBookings(supabase, orgId),
    staleTime: 60000,
    refetchInterval: 300000,
  });
}
```

**CRITICAL rules for ALL functions:**
- Every Supabase query MUST include `.eq('org_id', orgId)` — security requirement
- Every fetch function MUST return empty/zero default values, never null/undefined
- Follow the exact import pattern from revenue.ts
- Include JSDoc comments on all exported functions and types
- Use `Promise.all` for parallel queries
- The `getISOWeek` helper can be copied from revenue.ts or implemented inline
  </action>
  <verify>
Run `npx tsc --noEmit --project web/tsconfig.json 2>&1 | grep analytics` to verify no TypeScript errors in the new file. All exported types and hooks should compile cleanly.
  </verify>
  <done>
- `web/lib/queries/admin/analytics.ts` exists with 4 fetch functions and 4 hooks
- All 4 hooks export correctly: useAutoAssignmentStats, useMedicUtilisation, useLateArrivalPatterns, useOutOfTerritoryBookings
- fetchAutoAssignmentStats queries auto_schedule_logs directly with .eq('org_id', orgId) — no two-step via bookings
- fetchOutOfTerritoryBookings uses .gt('out_of_territory_cost', 0) — not .gt('travel_bonus', 0)
- OutOfTerritoryBooking type has out_of_territory_cost and out_of_territory_type — not travel_bonus/room_board
- All queries include org_id filter
- All functions handle empty data gracefully (return empty arrays/0s)
- TypeScript compiles without errors
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit --project web/tsconfig.json` passes (no type errors)
- File exists at `web/lib/queries/admin/analytics.ts`
- All 4 hooks are importable: `import { useAutoAssignmentStats, useMedicUtilisation, useLateArrivalPatterns, useOutOfTerritoryBookings } from '@/lib/queries/admin/analytics'`
- Every Supabase `.from()` call includes `.eq('org_id', orgId)`
- `fetchAutoAssignmentStats` queries `auto_schedule_logs` directly (no intermediate bookings query)
- `fetchOutOfTerritoryBookings` uses `out_of_territory_cost` and `out_of_territory_type` columns
</verification>

<success_criteria>
- 4 TanStack Query hooks created following revenue.ts pattern
- All hooks include org_id in queryKey and all queries filter by org_id
- Empty state handling on every fetch function
- TypeScript compilation succeeds
- auto_schedule_logs queried directly (not via bookings)
- OOT bookings use correct column names (out_of_territory_cost, out_of_territory_type)
</success_criteria>

<output>
After completion, create `.planning/phases/12-analytics-dashboard/12-04-SUMMARY.md`
</output>
