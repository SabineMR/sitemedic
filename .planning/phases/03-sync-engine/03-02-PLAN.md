---
phase: 03-sync-engine
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/PhotoUploadQueue.ts
  - src/utils/imageCompression.ts
  - supabase/migrations/014_storage_buckets.sql
autonomous: true

must_haves:
  truths:
    - "Photos are compressed into 3 progressive stages (thumbnail 50KB, preview 200KB, full 2-5MB)"
    - "Photo upload queue manages upload lifecycle separate from data sync queue"
    - "WiFi-only constraint enforced for full-quality uploads (thumbnails/previews use any connection)"
    - "User can override WiFi-only constraint for urgent situations"
    - "Supabase Storage bucket exists for treatment photos with proper access policy"
  artifacts:
    - path: "src/utils/imageCompression.ts"
      provides: "Progressive image encoding (thumbnail, preview, full)"
      exports: ["generateProgressiveImages", "ProgressiveImages"]
    - path: "src/services/PhotoUploadQueue.ts"
      provides: "Photo-specific upload queue with WiFi constraint and progress tracking"
      exports: ["PhotoUploadQueue", "photoUploadQueue"]
    - path: "supabase/migrations/014_storage_buckets.sql"
      provides: "Supabase Storage bucket for treatment photos"
      contains: "treatment-photos"
  key_links:
    - from: "src/services/PhotoUploadQueue.ts"
      to: "src/utils/imageCompression.ts"
      via: "imports generateProgressiveImages for compression"
      pattern: "generateProgressiveImages"
    - from: "src/services/PhotoUploadQueue.ts"
      to: "src/services/NetworkMonitor.ts"
      via: "checks isWifi before full-quality upload"
      pattern: "networkMonitor\\.getConnectionInfo"
    - from: "src/services/PhotoUploadQueue.ts"
      to: "@supabase/supabase-js"
      via: "uploads to Supabase Storage"
      pattern: "supabase\\.storage"
---

<objective>
Create the progressive photo upload pipeline with WiFi-only constraints and Supabase Storage integration.

Purpose: Photos are the largest data in the sync pipeline (2-5MB each). Without a separate queue, photo uploads would block RIDDOR-critical treatment data from syncing. Progressive encoding (thumbnail first, then preview, then full) means the dashboard gets a visual preview within seconds while full-quality uploads happen when WiFi is available.

Output: Image compression utility generating 3 quality tiers, photo upload queue service with WiFi enforcement, and Supabase Storage bucket migration.
</objective>

<execution_context>
@/Users/sabineresoagli/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sabineresoagli/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-sync-engine/03-RESEARCH.md
@.planning/phases/03-sync-engine/03-CONTEXT.md
@src/services/NetworkMonitor.ts
@src/services/SyncQueue.ts
@src/database/models/SyncQueueItem.ts
@src/database/schema.ts
@src/lib/watermelon.ts
@mobile/services/photo-processor.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create progressive image compression utility</name>
  <files>src/utils/imageCompression.ts</files>
  <action>
Create `src/utils/imageCompression.ts` that generates 3 quality tiers from a single photo URI.

This builds on the existing `mobile/services/photo-processor.ts` (which does single-pass 1200px/70% compression for local storage). The progressive compression here is specifically for UPLOAD stages - creating tiers optimized for network transfer.

```typescript
import * as ImageManipulator from 'expo-image-manipulator';

export interface ProgressiveImages {
  thumbnail: { uri: string; stage: 'thumbnail' };   // ~50KB, fast upload on any connection
  preview: { uri: string; stage: 'preview' };       // ~200KB, good enough for dashboard display
  full: { uri: string; stage: 'full' };             // ~2-5MB, original quality for records
}

/**
 * Generate 3 progressive quality tiers from a photo URI.
 *
 * Stage 1 (thumbnail): 150px width, 50% JPEG - uploads instantly on any connection
 * Stage 2 (preview): 800px width, 70% JPEG - dashboard-quality, uploads on cellular
 * Stage 3 (full): Original size, 90% JPEG - archive quality, WiFi-only upload
 *
 * Per Research Pattern 2: Progressive Photo Upload (Thumbnail-First)
 */
export async function generateProgressiveImages(uri: string): Promise<ProgressiveImages> {
  const [thumbnail, preview, full] = await Promise.all([
    // Stage 1: Thumbnail (~50KB)
    ImageManipulator.manipulateAsync(
      uri,
      [{ resize: { width: 150 } }],
      { compress: 0.5, format: ImageManipulator.SaveFormat.JPEG }
    ),
    // Stage 2: Preview (~200KB)
    ImageManipulator.manipulateAsync(
      uri,
      [{ resize: { width: 800 } }],
      { compress: 0.7, format: ImageManipulator.SaveFormat.JPEG }
    ),
    // Stage 3: Full quality (~2-5MB)
    ImageManipulator.manipulateAsync(
      uri,
      [], // No resize - preserve original resolution
      { compress: 0.9, format: ImageManipulator.SaveFormat.JPEG }
    ),
  ]);

  return {
    thumbnail: { uri: thumbnail.uri, stage: 'thumbnail' },
    preview: { uri: preview.uri, stage: 'preview' },
    full: { uri: full.uri, stage: 'full' },
  };
}
```
  </action>
  <verify>`ls -la src/utils/imageCompression.ts` exists and contains generateProgressiveImages export</verify>
  <done>Progressive image compression utility creates 3 quality tiers (thumbnail 150px/50%, preview 800px/70%, full original/90%) from a single photo URI using expo-image-manipulator</done>
</task>

<task type="auto">
  <name>Task 2: Create photo upload queue and Supabase Storage migration</name>
  <files>
    src/services/PhotoUploadQueue.ts
    supabase/migrations/014_storage_buckets.sql
  </files>
  <action>
Create 2 files:

**1. `supabase/migrations/014_storage_buckets.sql`** - Storage bucket for treatment photos
```sql
-- Create storage bucket for treatment photos
-- Used by Phase 3 sync engine for progressive photo uploads
-- Bucket is private (requires auth) with 50MB file size limit

INSERT INTO storage.buckets (id, name, public, file_size_limit, allowed_mime_types)
VALUES (
  'treatment-photos',
  'treatment-photos',
  false,
  52428800, -- 50MB limit per file
  ARRAY['image/jpeg', 'image/png']::text[]
)
ON CONFLICT (id) DO NOTHING;

-- RLS policy: authenticated users can upload to their org's folder
CREATE POLICY "Users can upload treatment photos"
  ON storage.objects FOR INSERT
  TO authenticated
  WITH CHECK (bucket_id = 'treatment-photos');

-- RLS policy: authenticated users can read treatment photos
CREATE POLICY "Users can view treatment photos"
  ON storage.objects FOR SELECT
  TO authenticated
  USING (bucket_id = 'treatment-photos');

-- RLS policy: authenticated users can update their uploads
CREATE POLICY "Users can update treatment photos"
  ON storage.objects FOR UPDATE
  TO authenticated
  USING (bucket_id = 'treatment-photos');
```

**2. `src/services/PhotoUploadQueue.ts`** - Photo-specific upload queue

This is SEPARATE from SyncQueue (which handles structured data). Photos are large binary files that need:
- Progressive staging (thumbnail first, then preview, then full)
- WiFi-only constraint for full-quality uploads
- Background upload capability via react-native-background-upload
- Concurrent upload limiting (max 2 simultaneous)

The queue stores upload tasks in the existing sync_queue WatermelonDB table but with a special 'upload_photo' operation type, so they persist across app restarts.

```typescript
import * as FileSystem from 'expo-file-system';
import { supabase } from '../lib/supabase';
import { networkMonitor } from './NetworkMonitor';
import { syncQueue } from './SyncQueue';
import { generateProgressiveImages, ProgressiveImages } from '../utils/imageCompression';

export type PhotoStage = 'thumbnail' | 'preview' | 'full';

export interface PhotoUploadTask {
  localUri: string;
  recordId: string;        // Treatment/near-miss/safety-check WatermelonDB ID
  recordType: string;      // 'treatments' | 'near_misses' | 'safety_checks'
  stage: PhotoStage;
  photoIndex: number;      // Position in the photo_uris array (0-3)
}

export interface PhotoUploadProgress {
  total: number;
  completed: number;
  inProgress: number;
  failed: number;
}

export class PhotoUploadQueue {
  private isProcessing = false;
  private maxConcurrent = 2; // Per Research open question 5
  private activeUploads = 0;
  private progress: PhotoUploadProgress = { total: 0, completed: 0, inProgress: 0, failed: 0 };
  private progressListeners: Set<(progress: PhotoUploadProgress) => void> = new Set();

  /**
   * Queue a photo for progressive upload.
   * Immediately generates thumbnail/preview/full versions and queues each stage.
   * Thumbnails and previews queue at normal priority, full at priority 1 with WiFi requirement.
   */
  async enqueuePhoto(
    localUri: string,
    recordId: string,
    recordType: string,
    photoIndex: number
  ): Promise<void> {
    try {
      // Generate progressive images
      const images = await generateProgressiveImages(localUri);

      // Queue thumbnail (uploads on any connection, priority 1 = normal)
      await syncQueue.enqueue(
        'create',
        'photo_uploads',
        `${recordId}-photo-${photoIndex}-thumbnail`,
        {
          localUri: images.thumbnail.uri,
          recordId,
          recordType,
          stage: 'thumbnail',
          photoIndex,
          storagePath: `${recordType}/${recordId}/photo-${photoIndex}-thumbnail.jpg`,
        },
        1 // Normal priority
      );

      // Queue preview (uploads on any connection, priority 1 = normal)
      await syncQueue.enqueue(
        'create',
        'photo_uploads',
        `${recordId}-photo-${photoIndex}-preview`,
        {
          localUri: images.preview.uri,
          recordId,
          recordType,
          stage: 'preview',
          photoIndex,
          storagePath: `${recordType}/${recordId}/photo-${photoIndex}-preview.jpg`,
        },
        1 // Normal priority
      );

      // Queue full quality (WiFi-only by default, priority 1 = normal)
      await syncQueue.enqueue(
        'create',
        'photo_uploads',
        `${recordId}-photo-${photoIndex}-full`,
        {
          localUri: images.full.uri,
          recordId,
          recordType,
          stage: 'full',
          photoIndex,
          storagePath: `${recordType}/${recordId}/photo-${photoIndex}-full.jpg`,
          requiresWiFi: true,
        },
        1 // Normal priority (WiFi constraint handled at upload time)
      );

      console.log(`[PhotoUploadQueue] Queued 3 stages for ${recordType}/${recordId}/photo-${photoIndex}`);
    } catch (error) {
      console.error('[PhotoUploadQueue] Failed to enqueue photo:', error);
    }
  }

  /**
   * Process pending photo uploads from the sync queue.
   * Called by the sync scheduler or background task.
   * Respects WiFi-only constraint for full-quality uploads.
   * Limits concurrent uploads to maxConcurrent (2).
   */
  async processPendingPhotos(): Promise<{ uploaded: number; skipped: number; failed: number }> {
    if (this.isProcessing) {
      return { uploaded: 0, skipped: 0, failed: 0 };
    }

    this.isProcessing = true;
    let uploaded = 0;
    let skipped = 0;
    let failed = 0;

    try {
      const { isOnline, isWifi } = networkMonitor.getConnectionInfo();
      if (!isOnline) {
        return { uploaded: 0, skipped: 0, failed: 0 };
      }

      // Get photo upload items from sync queue
      const pendingItems = await syncQueue.getPendingItems();
      const photoItems = pendingItems.filter(item => item.tableName === 'photo_uploads');

      for (const item of photoItems) {
        if (this.activeUploads >= this.maxConcurrent) break;

        const payload = JSON.parse(item.payload);

        // WiFi-only constraint for full-quality uploads
        if (payload.requiresWiFi && !isWifi) {
          skipped++;
          continue;
        }

        try {
          this.activeUploads++;
          await this.uploadToSupabase(payload.localUri, payload.storagePath);
          uploaded++;

          // Remove from queue on success (item is a SyncQueueItem)
          const { getDatabase } = require('../lib/watermelon');
          const database = getDatabase();
          await database.write(async () => {
            await item.destroyPermanently();
          });
        } catch (error) {
          console.error(`[PhotoUploadQueue] Upload failed for ${payload.storagePath}:`, error);
          failed++;
        } finally {
          this.activeUploads--;
        }
      }

      this.updateProgress({ uploaded, skipped, failed });
    } finally {
      this.isProcessing = false;
    }

    return { uploaded, skipped, failed };
  }

  /**
   * Upload a single file to Supabase Storage.
   * Uses expo-file-system to read file and supabase-js to upload.
   */
  private async uploadToSupabase(localUri: string, storagePath: string): Promise<string> {
    // Read file as base64
    const base64 = await FileSystem.readAsStringAsync(localUri, {
      encoding: FileSystem.EncodingType.Base64,
    });

    // Convert base64 to ArrayBuffer for upload
    const binaryString = atob(base64);
    const bytes = new Uint8Array(binaryString.length);
    for (let i = 0; i < binaryString.length; i++) {
      bytes[i] = binaryString.charCodeAt(i);
    }

    // Upload to Supabase Storage
    const { data, error } = await supabase.storage
      .from('treatment-photos')
      .upload(storagePath, bytes.buffer, {
        contentType: 'image/jpeg',
        upsert: true, // Allow re-upload on retry
      });

    if (error) throw error;

    console.log(`[PhotoUploadQueue] Uploaded ${storagePath}`);
    return data.path;
  }

  /**
   * Get aggregate upload progress for UI display.
   */
  getProgress(): PhotoUploadProgress {
    return { ...this.progress };
  }

  /**
   * Add listener for progress updates.
   */
  addProgressListener(callback: (progress: PhotoUploadProgress) => void): () => void {
    this.progressListeners.add(callback);
    return () => this.progressListeners.delete(callback);
  }

  private updateProgress(result: { uploaded: number; skipped: number; failed: number }): void {
    this.progress = {
      total: this.progress.total,
      completed: this.progress.completed + result.uploaded,
      inProgress: 0,
      failed: this.progress.failed + result.failed,
    };
    this.progressListeners.forEach(cb => cb(this.progress));
  }
}

export const photoUploadQueue = new PhotoUploadQueue();
```

Important implementation notes:
- Photo uploads use the EXISTING sync_queue table with tableName='photo_uploads' to persist across force-quit
- WiFi constraint checked at upload time via networkMonitor.getConnectionInfo().isWifi
- Max 2 concurrent uploads per Research recommendation (open question 5)
- Full-quality uploads skipped (not failed) when not on WiFi - they stay in queue for next WiFi connection
- User override for cellular upload will be added in Plan 03-04 (sync UX controls)
  </action>
  <verify>
TypeScript compilation check: `cd /Users/sabineresoagli/GitHub/sitemedic && npx tsc --noEmit --skipLibCheck 2>&1 | head -20`
Verify files exist: `ls -la src/services/PhotoUploadQueue.ts src/utils/imageCompression.ts supabase/migrations/014_storage_buckets.sql`
  </verify>
  <done>
Photo upload queue creates 3 progressive tiers per photo, enforces WiFi-only for full-quality uploads, limits to 2 concurrent uploads, and persists upload tasks in WatermelonDB sync_queue table. Supabase Storage bucket migration ready for deployment.
  </done>
</task>

</tasks>

<verification>
- `src/utils/imageCompression.ts` generates 3 tiers (thumbnail 150px, preview 800px, full original)
- `src/services/PhotoUploadQueue.ts` enforces WiFi-only for full-quality via `networkMonitor.getConnectionInfo().isWifi`
- Photo upload items use tableName='photo_uploads' in sync_queue table
- `supabase/migrations/014_storage_buckets.sql` creates treatment-photos bucket with auth policies
- Max concurrent uploads capped at 2
</verification>

<success_criteria>
1. Progressive image compression generates thumbnail (~50KB), preview (~200KB), and full (~2-5MB) tiers
2. Photo upload queue persists upload tasks in WatermelonDB sync_queue (survives force-quit)
3. WiFi-only constraint enforced for full-quality uploads, thumbnails/previews upload on any connection
4. Concurrent uploads limited to 2 to avoid overwhelming device/network
5. Supabase Storage bucket migration creates treatment-photos bucket with RLS policies
</success_criteria>

<output>
After completion, create `.planning/phases/03-sync-engine/03-02-SUMMARY.md`
</output>
