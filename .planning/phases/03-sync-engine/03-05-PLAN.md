---
phase: 03-sync-engine
plan: 05
type: execute
wave: 3
depends_on: ["03-03", "03-04"]
files_modified:
  - mobile/app/treatment/new.tsx
  - mobile/app/treatment/[id].tsx
  - mobile/app/near-miss/new.tsx
  - mobile/app/(tabs)/daily-checks.tsx
  - mobile/app/(tabs)/workers.tsx
  - App.tsx
autonomous: false

must_haves:
  truths:
    - "Treatment logged offline syncs to backend when connectivity returns"
    - "Photos upload in background without blocking medic workflow"
    - "Sync status badge shows pending item count at all times"
    - "Failed sync surfaces plain language error with manual retry button"
    - "RIDDOR-reportable incident that fails to sync triggers critical alert"
    - "Near-miss reports sync to backend automatically"
    - "Worker profiles sync to backend automatically"
    - "Daily safety checks sync to backend automatically"
  artifacts:
    - path: "mobile/app/treatment/new.tsx"
      provides: "Treatment form wired to sync queue on save"
      contains: "enqueueSyncItem"
    - path: "mobile/app/near-miss/new.tsx"
      provides: "Near-miss form wired to sync queue on save"
      contains: "enqueueSyncItem"
    - path: "App.tsx"
      provides: "App root with sync UI components mounted"
      contains: "SyncErrorDisplay|RiddorSyncAlert|PhotoUploadProgress"
  key_links:
    - from: "mobile/app/treatment/new.tsx"
      to: "src/contexts/SyncContext.tsx"
      via: "useSync().enqueueSyncItem on treatment save/complete"
      pattern: "enqueueSyncItem.*treatments"
    - from: "mobile/app/treatment/new.tsx"
      to: "src/services/PhotoUploadQueue.ts"
      via: "photoUploadQueue.enqueuePhoto for each treatment photo"
      pattern: "enqueuePhoto"
    - from: "App.tsx"
      to: "src/components/RiddorSyncAlert.tsx"
      via: "RiddorSyncAlert mounted above navigation"
      pattern: "RiddorSyncAlert"
---

<objective>
Wire all Phase 2 data capture forms to enqueue sync operations and mount sync UI components in the app root.

Purpose: This is the critical integration plan. Phase 2 forms save data to local WatermelonDB but never enqueue sync operations. This plan adds the `enqueueSyncItem()` call after every local save, the `photoUploadQueue.enqueuePhoto()` call for every photo, and mounts the sync feedback UI (error display, RIDDOR alert, photo progress) in App.tsx.

Output: All data capture workflows (treatments, workers, near-misses, daily checks) automatically enqueue to sync queue on save. App root displays sync error feedback, RIDDOR alerts, and photo upload progress.
</objective>

<execution_context>
@/Users/sabineresoagli/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sabineresoagli/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-sync-engine/03-CONTEXT.md
@.planning/phases/02-mobile-core/02-04-SUMMARY.md
@.planning/phases/02-mobile-core/02-06-SUMMARY.md
@.planning/phases/02-mobile-core/02-07-SUMMARY.md
@src/contexts/SyncContext.tsx
@src/services/PhotoUploadQueue.ts
@src/components/SyncErrorDisplay.tsx
@src/components/RiddorSyncAlert.tsx
@src/components/PhotoUploadProgress.tsx
@mobile/app/treatment/new.tsx
@mobile/app/near-miss/new.tsx
@mobile/app/(tabs)/daily-checks.tsx
@App.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire treatment, near-miss, worker, and daily check forms to sync queue</name>
  <files>
    mobile/app/treatment/new.tsx
    mobile/app/treatment/[id].tsx
    mobile/app/near-miss/new.tsx
    mobile/app/(tabs)/daily-checks.tsx
    mobile/app/(tabs)/workers.tsx
  </files>
  <action>
For each file, read the existing code first, then add sync enqueue calls at the right points. The pattern is the same for all forms:

1. Import `useSync` from `'../../../src/contexts/SyncContext'` (adjust relative path per file depth)
2. Import `photoUploadQueue` from `'../../../src/services/PhotoUploadQueue'`
3. Get `{ enqueueSyncItem }` from `useSync()` in the component
4. After each WatermelonDB write (create or update), call `enqueueSyncItem()` with the saved data
5. For photos, call `photoUploadQueue.enqueuePhoto()` for each photo URI

**Treatment new.tsx pattern:**
After a treatment is created in WatermelonDB:
```typescript
const { enqueueSyncItem } = useSync();

// After treatment.create(...) or treatment.update(...) in WatermelonDB:
await enqueueSyncItem(
  'create', // or 'update' for auto-save updates
  'treatments',
  treatment.id,
  {
    org_id: treatment.orgId,
    worker_id: treatment.workerId,
    medic_id: treatment.medicId,
    reference_number: treatment.referenceNumber,
    status: treatment.status,
    injury_type: treatment.injuryType,
    body_part: treatment.bodyPart,
    mechanism_of_injury: treatment.mechanismOfInjury,
    severity: treatment.severity,
    treatment_types: treatment.treatmentTypes,
    treatment_notes: treatment.treatmentNotes,
    outcome: treatment.outcome,
    is_riddor_reportable: treatment.isRiddorReportable,
    signature_uri: treatment.signatureUri,
    created_at: new Date(treatment.createdAt).toISOString(),
    updated_at: new Date(treatment.updatedAt).toISOString(),
    last_modified_at: treatment.lastModifiedAt,
  },
  treatment.isRiddorReportable ? 0 : 1 // RIDDOR = priority 0 (immediate)
);

// Queue photos for progressive upload
if (treatment.photoUris && treatment.photoUris.length > 0) {
  for (let i = 0; i < treatment.photoUris.length; i++) {
    await photoUploadQueue.enqueuePhoto(
      treatment.photoUris[i],
      treatment.id,
      'treatments',
      i
    );
  }
}
```

IMPORTANT considerations:
- For AUTO-SAVE (the useAutoSave hook), DO NOT enqueue sync on every 10-second auto-save. Only enqueue sync when the user explicitly saves or completes the treatment. Auto-save is for local persistence only. Syncing a draft every 10 seconds would overwhelm the queue.
- Use operation 'create' for new records, 'update' for modifications to existing records.
- RIDDOR-reportable treatments get priority 0, everything else gets priority 1.

**Treatment [id].tsx pattern:**
When treatment status changes to 'complete':
```typescript
await enqueueSyncItem('update', 'treatments', treatment.id, { ...payload, status: 'complete' }, treatment.isRiddorReportable ? 0 : 1);
```

**Near-miss new.tsx pattern:**
After near-miss is created:
```typescript
await enqueueSyncItem('create', 'near_misses', nearMiss.id, {
  org_id: nearMiss.orgId,
  reported_by: nearMiss.reportedBy,
  category: nearMiss.category,
  severity: nearMiss.severity,
  description: nearMiss.description,
  location: nearMiss.location,
  corrective_action: nearMiss.correctiveAction,
  created_at: new Date(nearMiss.createdAt).toISOString(),
  updated_at: new Date(nearMiss.updatedAt).toISOString(),
  last_modified_at: nearMiss.lastModifiedAt,
}, 1);

// Queue photos
for (let i = 0; i < nearMiss.photoUris.length; i++) {
  await photoUploadQueue.enqueuePhoto(nearMiss.photoUris[i], nearMiss.id, 'near_misses', i);
}
```

**Daily checks pattern:**
After safety check is saved/completed:
```typescript
await enqueueSyncItem('create', 'safety_checks', safetyCheck.id, {
  org_id: safetyCheck.orgId,
  medic_id: safetyCheck.medicId,
  check_date: new Date(safetyCheck.checkDate).toISOString().split('T')[0], // DATE format for server
  items: JSON.parse(safetyCheck.items), // Parse back to JSONB for Supabase
  overall_status: safetyCheck.overallStatus,
  created_at: new Date(safetyCheck.createdAt).toISOString(),
  updated_at: new Date(safetyCheck.updatedAt).toISOString(),
  last_modified_at: safetyCheck.lastModifiedAt,
}, 1);

// Queue photos if any
if (safetyCheck.photoUris) {
  const uris = JSON.parse(safetyCheck.photoUris);
  for (let i = 0; i < uris.length; i++) {
    await photoUploadQueue.enqueuePhoto(uris[i], safetyCheck.id, 'safety_checks', i);
  }
}
```

**Workers pattern:**
After worker profile is created or updated:
```typescript
await enqueueSyncItem(isNew ? 'create' : 'update', 'workers', worker.id, {
  org_id: worker.orgId,
  first_name: worker.firstName,
  last_name: worker.lastName,
  company: worker.company,
  role: worker.role,
  phone: worker.phone,
  emergency_contact_name: worker.emergencyContactName,
  emergency_contact_phone: worker.emergencyContactPhone,
  health_notes: worker.healthNotes,
  consent_given: worker.consentGiven,
  consent_date: worker.consentDate ? new Date(worker.consentDate).toISOString() : null,
  created_at: new Date(worker.createdAt).toISOString(),
  updated_at: new Date(worker.updatedAt).toISOString(),
  last_modified_at: worker.lastModifiedAt,
}, 1);
```

For each file:
1. Find the WatermelonDB write (database.write / collection.create / record.update)
2. Add the enqueueSyncItem call AFTER the successful local write
3. Add photo enqueue calls after the sync item enqueue
4. Do NOT modify the auto-save hook behavior - only manual save/complete triggers sync
  </action>
  <verify>
TypeScript compilation check: `cd /Users/sabineresoagli/GitHub/sitemedic && npx tsc --noEmit --skipLibCheck 2>&1 | head -20`
Grep for sync wiring: `grep -rn "enqueueSyncItem" mobile/app/treatment/ mobile/app/near-miss/ mobile/app/\(tabs\)/`
Grep for photo wiring: `grep -rn "enqueuePhoto" mobile/app/treatment/ mobile/app/near-miss/ mobile/app/\(tabs\)/`
Grep for RIDDOR priority: `grep -rn "isRiddorReportable.*0.*1\|priority.*0" mobile/app/treatment/`
  </verify>
  <done>
All Phase 2 data capture forms (treatments, near-misses, workers, daily checks) enqueue sync operations after local WatermelonDB writes. RIDDOR treatments use priority 0. Photos queued via photoUploadQueue for progressive upload. TypeScript compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Mount sync UI components in App.tsx</name>
  <files>App.tsx</files>
  <action>
Read App.tsx first, then add the new sync feedback components.

Add imports:
```typescript
import { SyncErrorDisplay } from './src/components/SyncErrorDisplay';
import { RiddorSyncAlert } from './src/components/RiddorSyncAlert';
import { PhotoUploadProgress } from './src/components/PhotoUploadProgress';
```

Mount components INSIDE the SyncProvider (they need SyncContext), positioned at the top of the app layout:
- RiddorSyncAlert: renders first (topmost, most critical)
- SyncErrorDisplay: renders below RIDDOR alert
- PhotoUploadProgress: renders below error display
- These should appear above the main navigation/content

Position them inside a View wrapper at the top of the component tree (inside SyncProvider, before the main content/navigation):

```jsx
<SyncProvider>
  {/* Sync feedback layer - renders at top of screen */}
  <RiddorSyncAlert />
  <SyncErrorDisplay />
  <PhotoUploadProgress />

  {/* Existing OfflineBanner */}
  <OfflineBanner />

  {/* Existing SyncStatusIndicator and navigation */}
  {/* ... rest of existing App.tsx content ... */}
</SyncProvider>
```

DO NOT modify the existing SyncProvider, AuthProvider, OfflineBanner, or SyncStatusIndicator integration. Only ADD the 3 new components inside the existing SyncProvider wrapper.

Also import the background task definition file at the TOP of App.tsx (or the entry file) to ensure the global-scope TaskManager.defineTask runs before anything else:

```typescript
// MUST be imported at top level to register background task at global scope
import './mobile/tasks/backgroundSyncTask';
```

This import must be before any React component code. It ensures the background task is registered when the app loads.
  </action>
  <verify>
Grep for component mounts: `grep -n "RiddorSyncAlert\|SyncErrorDisplay\|PhotoUploadProgress\|backgroundSyncTask" App.tsx`
Verify background task import at top: `head -10 App.tsx`
TypeScript compilation check: `cd /Users/sabineresoagli/GitHub/sitemedic && npx tsc --noEmit --skipLibCheck 2>&1 | head -20`
  </verify>
  <done>
App.tsx imports background task at global scope, mounts RiddorSyncAlert, SyncErrorDisplay, and PhotoUploadProgress inside SyncProvider above existing navigation content. TypeScript compiles without errors.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete sync engine wiring: all Phase 2 forms (treatments, near-misses, workers, daily checks) enqueue data to sync queue after local save. Photos enqueue to progressive upload queue. RIDDOR items use priority 0. Background task registered. Sync feedback UI mounted (error display, RIDDOR alert, photo progress).
  </what-built>
  <how-to-verify>
Since background sync requires a physical iOS device (not simulator per Research Pitfall 2), verify via code inspection:

1. Run TypeScript check: `cd /Users/sabineresoagli/GitHub/sitemedic && npx tsc --noEmit --skipLibCheck`
2. Verify all forms have sync wiring: `grep -rn "enqueueSyncItem" mobile/app/`
3. Verify photo upload wiring: `grep -rn "enqueuePhoto" mobile/app/`
4. Verify RIDDOR priority: `grep -rn "isRiddorReportable.*?.*0" mobile/app/treatment/`
5. Verify App.tsx has all components: `grep -n "RiddorSyncAlert\|SyncErrorDisplay\|PhotoUploadProgress\|backgroundSyncTask" App.tsx`
6. Verify background task at global scope: `grep -n "TaskManager.defineTask" mobile/tasks/backgroundSyncTask.ts`

Expected: All checks pass. TypeScript compiles. All forms have sync wiring. All sync UI components mounted.
  </how-to-verify>
  <resume-signal>Type "approved" if all verification checks pass, or describe specific issues found</resume-signal>
</task>

</tasks>

<verification>
- TypeScript compiles without errors: `npx tsc --noEmit --skipLibCheck`
- All 4 form types (treatment, near-miss, worker, daily-check) call enqueueSyncItem after WatermelonDB write
- Treatment and near-miss forms call photoUploadQueue.enqueuePhoto for each photo
- RIDDOR-reportable treatments use priority 0, all other items use priority 1
- App.tsx imports backgroundSyncTask at top level (global scope)
- App.tsx renders RiddorSyncAlert, SyncErrorDisplay, PhotoUploadProgress inside SyncProvider
- Auto-save does NOT trigger sync (only explicit save/complete does)
</verification>

<success_criteria>
1. Treatment logged offline will sync when connectivity returns (enqueueSyncItem called on save)
2. Photos queued for progressive upload (enqueuePhoto called for each photo URI)
3. RIDDOR items use priority 0 for immediate sync
4. Sync feedback UI visible: error display, RIDDOR alert, photo progress
5. Background task registered at global scope for 15-minute background sync
6. TypeScript compiles without errors
7. Human checkpoint approves integration
</success_criteria>

<output>
After completion, create `.planning/phases/03-sync-engine/03-05-SUMMARY.md`
</output>
