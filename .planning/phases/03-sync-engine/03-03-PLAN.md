---
phase: 03-sync-engine
plan: 03
type: execute
wave: 2
depends_on: ["03-01", "03-02"]
files_modified:
  - src/services/SyncQueue.ts
  - src/contexts/SyncContext.tsx
  - src/utils/syncScheduler.ts
  - mobile/tasks/backgroundSyncTask.ts
autonomous: true

must_haves:
  truths:
    - "RIDDOR priority 0 items retry after 30 seconds on failure (not 5 minutes)"
    - "SyncQueue filters out photo_uploads items (handled by PhotoUploadQueue)"
    - "SyncContext integrates with syncScheduler for foreground/background sync"
    - "Background task processes both data sync and photo uploads"
    - "Last-write-wins conflict resolution uses updated_at timestamp comparison"
    - "Sync scheduler starts automatically when SyncProvider mounts"
  artifacts:
    - path: "src/services/SyncQueue.ts"
      provides: "Enhanced sync queue with RIDDOR fast retry, photo filtering, LWW conflict resolution"
      exports: ["SyncQueue", "syncQueue"]
    - path: "src/contexts/SyncContext.tsx"
      provides: "Enhanced context with scheduler integration and photo upload progress"
      exports: ["SyncProvider", "useSync"]
  key_links:
    - from: "src/contexts/SyncContext.tsx"
      to: "src/utils/syncScheduler.ts"
      via: "starts/stops syncScheduler on mount/unmount"
      pattern: "syncScheduler\\.(start|stop)"
    - from: "mobile/tasks/backgroundSyncTask.ts"
      to: "src/services/PhotoUploadQueue.ts"
      via: "calls photoUploadQueue.processPendingPhotos()"
      pattern: "photoUploadQueue\\.processPendingPhotos"
    - from: "src/services/SyncQueue.ts"
      to: "supabase"
      via: "last-write-wins conflict check on update operations"
      pattern: "last_modified_at|updated_at"
---

<objective>
Enhance the existing sync infrastructure with RIDDOR priority fast retry, last-write-wins conflict resolution, photo upload integration, and SyncContext scheduler wiring.

Purpose: The Phase 1 SyncQueue has the right foundation but needs refinements for production sync: RIDDOR items need faster retry (30s not 5min), update operations need last-write-wins to prevent data loss, and the background task needs to process both data and photos. The SyncContext needs to start the new sync scheduler.

Output: Enhanced SyncQueue with RIDDOR fast retry and LWW conflict resolution, enhanced SyncContext with scheduler integration, and background task wired to photo uploads.
</objective>

<execution_context>
@/Users/sabineresoagli/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sabineresoagli/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-sync-engine/03-RESEARCH.md
@.planning/phases/03-sync-engine/03-CONTEXT.md
@.planning/phases/01-foundation/01-05-SUMMARY.md
@src/services/SyncQueue.ts
@src/services/NetworkMonitor.ts
@src/services/PhotoUploadQueue.ts
@src/contexts/SyncContext.tsx
@src/utils/syncScheduler.ts
@mobile/tasks/backgroundSyncTask.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance SyncQueue with RIDDOR fast retry, photo filtering, and LWW conflict resolution</name>
  <files>src/services/SyncQueue.ts</files>
  <action>
Modify `src/services/SyncQueue.ts` with 3 targeted enhancements. Read the file first, then apply these changes:

**Enhancement 1: RIDDOR fast retry (Research Pitfall 7)**
In `scheduleRetry()`, check if item.priority === 0 (RIDDOR). If so, use 30-second initial retry instead of 5 minutes. After first retry, fall back to standard exponential backoff but with shorter intervals:
- RIDDOR retry: 30s -> 1min -> 2min -> 5min -> 15min -> 30min (cap at 30min for RIDDOR, not 4 hours)
- Normal retry: keeps existing 5min -> 10min -> ... -> 240min cap

```typescript
private async scheduleRetry(item: SyncQueueItem): Promise<void> {
  const database = getDatabase()
  const retryCount = item.retryCount + 1

  let backoffMs: number
  if (item.priority === 0) {
    // RIDDOR: faster retry (30s -> 1min -> 2min -> 5min -> 15min -> 30min cap)
    const riddorBackoffSeconds = Math.min(30 * Math.pow(2, retryCount - 1), 30 * 60)
    backoffMs = riddorBackoffSeconds * 1000
  } else {
    // Normal: standard backoff (5min -> 10min -> ... -> 240min cap)
    const backoffMinutes = Math.min(5 * Math.pow(2, retryCount), 240)
    backoffMs = backoffMinutes * 60 * 1000
  }

  const nextRetryAt = Date.now() + backoffMs

  await database.write(async () => {
    await item.update((record) => {
      record.retryCount = retryCount
      record.nextRetryAt = nextRetryAt
    })
  })
}
```

**Enhancement 2: Filter out photo_uploads from data processing**
In `processPendingItems()`, add a filter to exclude items where tableName === 'photo_uploads'. These are handled by PhotoUploadQueue. Add after the query:

```typescript
// Filter out photo uploads (handled by PhotoUploadQueue separately)
const dataItems = pendingItems.filter(item => item.tableName !== 'photo_uploads')
```

Then iterate over `dataItems` instead of `pendingItems`.

**Enhancement 3: Last-write-wins conflict resolution on update**
In `syncItem()`, for the 'update' case, add a conflict check:
- Before updating, fetch the current server record's `updated_at`
- Compare with the local record's `last_modified_at` from the payload
- If server `updated_at` is newer, skip the update (server wins)
- If local `last_modified_at` is newer or equal, proceed with update (local wins)

```typescript
case 'update': {
  // Last-write-wins: check if server record is newer
  const { data: serverRecord, error: fetchError } = await supabase
    .from(item.tableName as any)
    .select('updated_at')
    .eq('id', payload.id as any)
    .single()

  if (fetchError) {
    // If record not found on server, it may have been deleted - skip
    if (fetchError.code === 'PGRST116') {
      console.warn(`[SyncQueue] Record ${payload.id} not found on server, skipping update`)
      return
    }
    throw fetchError
  }

  // Compare timestamps - server updated_at is TIMESTAMPTZ, convert to epoch ms
  if (serverRecord) {
    const serverUpdatedAt = new Date(serverRecord.updated_at).getTime()
    const localModifiedAt = payload.last_modified_at || payload.updated_at || 0

    if (serverUpdatedAt > localModifiedAt) {
      console.log(`[SyncQueue] Server record is newer (${serverUpdatedAt} > ${localModifiedAt}), skipping update (LWW)`)
      return // Server wins - skip this update
    }
  }

  // Local wins - proceed with update
  const { error } = await supabase
    .from(item.tableName as any)
    .update(payload as any)
    .eq('id', payload.id as any)

  if (error) throw error
  break
}
```

Keep all other existing code unchanged. The enqueue() method, getPendingCount(), getPendingItems(), and the create/delete cases in syncItem() remain as-is.
  </action>
  <verify>
Grep for RIDDOR retry: `grep -n "riddorBackoff" src/services/SyncQueue.ts`
Grep for photo filter: `grep -n "photo_uploads" src/services/SyncQueue.ts`
Grep for LWW: `grep -n "Server record is newer\|LWW\|last_modified_at" src/services/SyncQueue.ts`
TypeScript check: `cd /Users/sabineresoagli/GitHub/sitemedic && npx tsc --noEmit --skipLibCheck 2>&1 | head -20`
  </verify>
  <done>
SyncQueue enhanced with: RIDDOR fast retry (30s initial, 30min cap vs 5min initial, 4hr cap for normal), photo_uploads filtered out of data processing, and last-write-wins conflict resolution comparing server updated_at against local last_modified_at.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire SyncContext to sync scheduler and photo uploads, update background task</name>
  <files>
    src/contexts/SyncContext.tsx
    src/utils/syncScheduler.ts
    mobile/tasks/backgroundSyncTask.ts
  </files>
  <action>
Make 3 targeted modifications:

**1. Update `mobile/tasks/backgroundSyncTask.ts`** to include photo upload processing:

Add import for photoUploadQueue and call `photoUploadQueue.processPendingPhotos()` after data sync:

```typescript
import * as TaskManager from 'expo-task-manager';
import { syncQueue } from '../../src/services/SyncQueue';
import { photoUploadQueue } from '../../src/services/PhotoUploadQueue';

const BACKGROUND_SYNC_TASK = 'BACKGROUND_SYNC';

TaskManager.defineTask(BACKGROUND_SYNC_TASK, async () => {
  try {
    console.log('[BackgroundSync] Task started');

    // 1. Sync structured data (treatments, workers, etc.)
    const dataResult = await syncQueue.processPendingItems();
    console.log(`[BackgroundSync] Data: ${dataResult.processed} synced, ${dataResult.failed} failed`);

    // 2. Process photo uploads (respects WiFi-only constraint internally)
    const photoResult = await photoUploadQueue.processPendingPhotos();
    console.log(`[BackgroundSync] Photos: ${photoResult.uploaded} uploaded, ${photoResult.skipped} skipped (WiFi), ${photoResult.failed} failed`);

    const allSuccess = dataResult.failed === 0 && photoResult.failed === 0;
    return allSuccess
      ? TaskManager.BackgroundFetchResult.NewData
      : TaskManager.BackgroundFetchResult.Failed;
  } catch (error) {
    console.error('[BackgroundSync] Task failed:', error);
    return TaskManager.BackgroundFetchResult.Failed;
  }
});

export { BACKGROUND_SYNC_TASK };
```

**2. Update `src/utils/syncScheduler.ts`** to also process photo uploads during foreground sync:

Add import for photoUploadQueue. In the `syncNow()` method, call `photoUploadQueue.processPendingPhotos()` after `syncQueue.processPendingItems()`:

```typescript
async syncNow(): Promise<{ processed: number; failed: number }> {
  const { isOnline } = networkMonitor.getConnectionInfo();
  if (!isOnline) {
    return { processed: 0, failed: 0 };
  }

  // Process data sync
  const dataResult = await syncQueue.processPendingItems();

  // Process photo uploads (non-blocking, runs concurrently next cycle if still processing)
  photoUploadQueue.processPendingPhotos().catch(err =>
    console.error('[SyncScheduler] Photo processing error:', err)
  );

  return dataResult;
}
```

Add the import at the top: `import { photoUploadQueue } from '../services/PhotoUploadQueue';`

**3. Update `src/contexts/SyncContext.tsx`** to integrate with the sync scheduler:

Read the existing file first, then make these changes:

a) Add import for syncScheduler: `import { syncScheduler } from '../utils/syncScheduler';`
b) Add import for photoUploadQueue: `import { photoUploadQueue } from '../services/PhotoUploadQueue';`

c) In the main useEffect that starts networkMonitor, ADD syncScheduler.start():
```typescript
useEffect(() => {
  console.log('[SyncContext] Initializing...')

  // Start network monitoring
  networkMonitor.startMonitoring()

  // Start hybrid sync scheduler (foreground 30s + background 15min)
  syncScheduler.start()

  // ... rest of existing listener code ...

  // REMOVE the old 10-second pollInterval since syncScheduler handles polling now
  // The refreshState() still needs to be called periodically for UI updates
  const uiRefreshInterval = setInterval(() => {
    refreshState()
  }, 5000) // Refresh UI state every 5 seconds (lighter than sync, just reads counts)

  return () => {
    console.log('[SyncContext] Cleaning up...')
    unsubscribe()
    networkMonitor.stopMonitoring()
    syncScheduler.stop()
    clearInterval(uiRefreshInterval)
  }
}, [isProcessing, updateStatus, refreshState])
```

d) In `triggerSync()`, also trigger photo uploads:
After `const syncResult = await syncQueue.processPendingItems()`, add:
```typescript
// Process pending photo uploads
const photoResult = await photoUploadQueue.processPendingPhotos()
console.log('[SyncContext] Photo upload result:', photoResult)
```

e) Add photo upload progress to SyncState interface:
```typescript
export interface SyncState {
  status: SyncStatus
  pendingCount: number
  isOnline: boolean
  connectionType: string
  lastSyncAt: Date | null
  lastError: string | null
  pendingPhotoCount: number  // NEW: photos waiting to upload
}
```

f) Update refreshState to include photo count. After getting pendingCount, also count photo items:
```typescript
const refreshState = useCallback(async () => {
  try {
    const pendingCount = await syncQueue.getPendingCount()
    const pendingItems = await syncQueue.getPendingItems()
    const pendingPhotoCount = pendingItems.filter(i => i.tableName === 'photo_uploads').length
    const connectionInfo = networkMonitor.getConnectionInfo()

    setState((prev) => ({
      ...prev,
      pendingCount: pendingCount - pendingPhotoCount, // Data items only
      pendingPhotoCount,
      isOnline: connectionInfo.isOnline,
      connectionType: connectionInfo.connectionType,
      status: updateStatus(connectionInfo.isOnline, pendingCount, isProcessing, prev.lastError),
    }))
  } catch (error) {
    console.error('[SyncContext] Failed to refresh state:', error)
  }
}, [isProcessing, updateStatus])
```

g) Update initial state to include pendingPhotoCount: 0
  </action>
  <verify>
Grep for scheduler integration: `grep -n "syncScheduler" src/contexts/SyncContext.tsx`
Grep for photo integration: `grep -n "photoUploadQueue" src/contexts/SyncContext.tsx mobile/tasks/backgroundSyncTask.ts src/utils/syncScheduler.ts`
Grep for pendingPhotoCount: `grep -n "pendingPhotoCount" src/contexts/SyncContext.tsx`
TypeScript check: `cd /Users/sabineresoagli/GitHub/sitemedic && npx tsc --noEmit --skipLibCheck 2>&1 | head -20`
  </verify>
  <done>
SyncContext starts sync scheduler on mount (replacing simple 10s polling with hybrid 30s foreground + 15min background), background task processes both data and photos, SyncState includes pendingPhotoCount for UI, and triggerSync processes both data and photo queues.
  </done>
</task>

</tasks>

<verification>
- SyncQueue.scheduleRetry uses 30-second initial delay for RIDDOR (priority 0) items
- SyncQueue.processPendingItems filters out 'photo_uploads' tableName
- SyncQueue.syncItem 'update' case compares server updated_at with local last_modified_at (LWW)
- SyncContext starts syncScheduler on mount and stops on unmount
- Background task calls both syncQueue.processPendingItems() and photoUploadQueue.processPendingPhotos()
- SyncState includes pendingPhotoCount field
- TypeScript compiles without errors
</verification>

<success_criteria>
1. RIDDOR items retry after 30 seconds (not 5 minutes) with 30-minute cap
2. Photo uploads filtered from data sync queue (processed separately)
3. Last-write-wins on update: server record newer = skip, local newer = proceed
4. SyncContext integrates sync scheduler (30s foreground, 15min background)
5. Background task handles both data and photo sync
6. SyncState exposes pendingPhotoCount for UI consumption
</success_criteria>

<output>
After completion, create `.planning/phases/03-sync-engine/03-03-SUMMARY.md`
</output>
