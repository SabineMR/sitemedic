---
phase: 43-real-time-push-notifications
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/contexts/RealtimeContext.tsx
  - src/contexts/SyncContext.tsx
  - src/services/MessageSync.ts
  - src/components/messaging/ConversationList.tsx
  - src/components/messaging/MessageThread.tsx
  - web/lib/queries/comms.ts
  - web/app/(dashboard)/messages/components/ConversationList.tsx
  - web/app/(dashboard)/messages/components/MessageThread.tsx
  - web/app/(dashboard)/layout.tsx
autonomous: true

must_haves:
  truths:
    - "When user A sends a message, user B sees it in their open thread within 1-2 seconds without page refresh"
    - "Conversation list updates live: new messages change preview, timestamp, and unread count without refresh"
    - "A single Supabase Realtime channel per user handles all conversations (not one per conversation)"
    - "Existing 10s/30s polling is completely replaced by Realtime subscriptions"
  artifacts:
    - path: "src/contexts/RealtimeContext.tsx"
      provides: "iOS Realtime provider with single channel per user, message insert + read status listeners"
      min_lines: 80
    - path: "web/lib/queries/comms.ts"
      provides: "Web Realtime subscription hook replacing polling"
      contains: "supabase.channel"
  key_links:
    - from: "src/contexts/RealtimeContext.tsx"
      to: "src/services/MessageSync.ts"
      via: "Realtime message INSERT event triggers WatermelonDB upsert"
      pattern: "db\\.write|messageSync"
    - from: "web/lib/queries/comms.ts"
      to: "supabase.channel"
      via: "Realtime subscription replaces refetchInterval polling"
      pattern: "postgres_changes.*messages"
---

<objective>
Replace polling with Supabase Realtime subscriptions on both web and iOS so messages appear within 1-2 seconds of being sent -- no page refresh or pull-to-refresh needed.

Purpose: This is the core real-time delivery mechanism. Phase 41-42 used 10s/30s polling as a stopgap. Realtime subscriptions reduce server load by ~99% and deliver messages near-instantly.

Output: RealtimeContext provider for iOS, Realtime-powered hooks for web, WatermelonDB integration for iOS Realtime events, and complete removal of polling from messaging components.
</objective>

<execution_context>
@/Users/sabineresoagli/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sabineresoagli/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/43-real-time-push-notifications/43-RESEARCH.md
@.planning/phases/42-ios-messaging-offline/42-01-SUMMARY.md
@.planning/phases/42-ios-messaging-offline/42-02-SUMMARY.md
@.planning/phases/42-ios-messaging-offline/42-03-SUMMARY.md
@.planning/phases/41-web-messaging-core/41-01-SUMMARY.md
@.planning/phases/41-web-messaging-core/41-02-SUMMARY.md

Key existing files to reference:
@web/lib/queries/comms.ts (has useConversations with 30s polling, useMessages with 10s polling)
@web/app/(dashboard)/messages/components/ConversationList.tsx (uses useConversations)
@web/app/(dashboard)/messages/components/MessageThread.tsx (uses useMessages)
@web/app/(dashboard)/layout.tsx (server-side header unread badge)
@src/contexts/SyncContext.tsx (iOS sync context, needs Realtime integration)
@src/services/MessageSync.ts (iOS message sync, Realtime events should feed into WatermelonDB)
@src/components/messaging/ConversationList.tsx (iOS conversation list, reactive WatermelonDB observers)
@src/components/messaging/MessageThread.tsx (iOS message thread with inverted FlatList)
</context>

<tasks>

<task type="auto">
  <name>Task 1: iOS RealtimeContext and WatermelonDB integration</name>
  <files>
    src/contexts/RealtimeContext.tsx
    src/contexts/SyncContext.tsx
    src/services/MessageSync.ts
    src/components/messaging/ConversationList.tsx
    src/components/messaging/MessageThread.tsx
  </files>
  <action>
    Create `src/contexts/RealtimeContext.tsx` -- a React Context provider that manages a single Supabase Realtime channel per user:

    1. **Channel setup:** Subscribe to `supabase.channel(`user-${userId}:org_${orgId}`)` with two postgres_changes listeners:
       - INSERT on `messages` table filtered by `org_id=eq.${orgId}` -- handles new message arrival
       - UPDATE on `conversation_read_status` table filtered by `org_id=eq.${orgId}` -- handles read receipt updates

    2. **WatermelonDB integration:** When a new message INSERT arrives via Realtime:
       - Get the WatermelonDB database instance via `getDatabase()`
       - Inside a single `db.write()` call:
         a. Check if a Message record with this server_id already exists (idempotent -- may have arrived via sync)
         b. If not, create a new Message record with all fields from the payload (server_id, conversation_id, sender_id, sender_name from payload or "Unknown", content, status, created_at)
         c. Find or skip the Conversation record -- update last_message_at, last_message_preview, and increment unread_count (ONLY if message sender_id !== current user id)
       - WatermelonDB observers in ConversationList and MessageThread automatically trigger re-render

    3. **Sender name resolution:** The Realtime payload from postgres_changes includes the raw message row but NOT the sender name (it's not on the messages table). Options:
       - Look up sender_name from existing WatermelonDB Message records for same sender_id (if any prior messages exist from this sender)
       - If no prior messages, fetch from Supabase `medics` table (single query, cached for session)
       - Non-medic senders labeled "Admin" (consistent with Phase 42 convention)

    4. **Connection lifecycle:**
       - Subscribe on mount when userId and orgId are available
       - Clean up with `supabase.removeChannel(channel)` on unmount
       - Log connection status changes (SUBSCRIBED, CLOSED, etc.)
       - Expose `isConnected` boolean via context

    5. **SyncContext integration:** In `src/contexts/SyncContext.tsx`:
       - Import and render `<RealtimeProvider>` wrapping children, OR
       - Add the Realtime channel setup directly within SyncContext (simpler if it avoids another provider layer)
       - When Realtime is connected, the existing `startAutoSync` NetworkMonitor listener should still work for reconnection scenarios (belt and suspenders)

    6. **Remove iOS polling:** The iOS app does NOT use polling (it uses WatermelonDB observers + pull-to-refresh from Phase 42). However, ensure that when Realtime is active, the `triggerMessageSync` pull-to-refresh still works as a manual fallback. Do NOT disable it -- Realtime supplements sync, doesn't replace it entirely.

    7. **Serialize writes:** Queue Realtime-triggered WatermelonDB writes to prevent concurrent `db.write()` conflicts with MessageSync push/pull operations. Use a simple write queue (array of pending write functions processed serially) or await each write before processing the next Realtime event.

    Provider should be placed in the app's root layout so it's available to all messaging screens.
  </action>
  <verify>
    - `npx tsc --noEmit` passes (no TypeScript errors in new/modified files)
    - RealtimeContext.tsx exports `RealtimeProvider` and `useRealtime` hook
    - Grep for `supabase.channel` in RealtimeContext.tsx -- should find exactly one channel creation
    - Grep for `postgres_changes` in RealtimeContext.tsx -- should find listeners for both `messages` INSERT and `conversation_read_status` UPDATE
    - Grep for `db.write` in RealtimeContext.tsx -- confirms WatermelonDB upsert on message arrival
  </verify>
  <done>
    iOS app has a single Supabase Realtime channel per user that receives message INSERT events and upserts them into WatermelonDB, triggering automatic UI updates via observers in ConversationList and MessageThread. No new polling introduced.
  </done>
</task>

<task type="auto">
  <name>Task 2: Web Realtime subscription replacing polling</name>
  <files>
    web/lib/queries/comms.ts
    web/app/(dashboard)/messages/components/ConversationList.tsx
    web/app/(dashboard)/messages/components/MessageThread.tsx
    web/app/(dashboard)/layout.tsx
  </files>
  <action>
    Replace the 30-second and 10-second polling in the web messaging components with Supabase Realtime subscriptions:

    1. **New hook in `web/lib/queries/comms.ts`:** Create `useRealtimeMessages(orgId: string)` hook:
       - Creates a single Supabase Realtime channel: `supabase.channel(`web-user-${userId}:org_${orgId}`)`
       - Listens for INSERT on `messages` table filtered by `org_id=eq.${orgId}`
       - Listens for UPDATE on `conversations` table filtered by `org_id=eq.${orgId}` (for metadata changes like last_message_at)
       - On message INSERT: calls `queryClient.invalidateQueries({ queryKey: ['messages', payload.new.conversation_id] })` to refetch the active thread AND `queryClient.invalidateQueries({ queryKey: ['conversations'] })` to refresh the conversation list
       - Returns `{ isConnected: boolean }` so components can show connection status
       - Cleanup: `supabase.removeChannel(channel)` on unmount

    2. **Modify `useConversations` hook:** Remove the `refetchInterval: 30_000` option. The Realtime subscription handles updates now. Keep the hook for initial data fetch and manual refetch capability.

    3. **Modify `useMessages` hook:** Remove the `refetchInterval: 10_000` option. Realtime handles message arrival. Keep the hook for initial thread load.

    4. **Update ConversationList.tsx:**
       - Call `useRealtimeMessages(orgId)` at the component level to establish the Realtime subscription
       - The subscription invalidates TanStack Query cache, which automatically triggers re-render of the conversation list
       - Remove any polling-related comments

    5. **Update MessageThread.tsx:**
       - The Realtime subscription from ConversationList (or a shared parent) already invalidates message queries
       - Ensure the thread component uses the same query key pattern so invalidation works
       - Add auto-scroll to bottom when new messages arrive via Realtime (check if already at bottom before scrolling)

    6. **Update header unread badge in `web/app/(dashboard)/layout.tsx`:**
       - Currently the header badge is server-side rendered (fetched once on page load). This means it does NOT update in real-time.
       - Add a small client component `<UnreadBadge />` that uses `useConversations` to get the total unread count reactively. When Realtime invalidates conversations query, the badge updates.
       - Replace the server-side badge rendering with this client component.
       - The server-side initial fetch can remain for SSR (shows correct count on page load), but the client component takes over for live updates.

    7. **Important:** The Realtime channel must use the Supabase client from `@supabase/ssr` (the browser client used in client components), NOT the server client. Import from the existing browser Supabase client utility.

    Do NOT use `broadcast: { self: true }` on web -- the sender's own message is already added optimistically via TanStack Query mutation/invalidation.
  </action>
  <verify>
    - `cd /Users/sabineresoagli/GitHub/sitemedic/web && npx tsc --noEmit` passes
    - Grep for `refetchInterval` in `web/lib/queries/comms.ts` -- should find ZERO occurrences (polling removed)
    - Grep for `supabase.channel` in `web/lib/queries/comms.ts` -- should find one channel creation in the new Realtime hook
    - Grep for `postgres_changes` in `web/lib/queries/comms.ts` -- should find INSERT listener on messages table
    - Grep for `invalidateQueries` in `web/lib/queries/comms.ts` -- should find cache invalidation for both conversations and messages
  </verify>
  <done>
    Web messaging uses Supabase Realtime instead of polling. Conversation list and message thread update within 1-2 seconds when new messages arrive. Header unread badge updates in real-time via client component. Zero polling intervals remain in messaging code.
  </done>
</task>

</tasks>

<verification>
1. Both web and iOS use a single Supabase Realtime channel per user (grep confirms one `supabase.channel` call per platform)
2. No polling intervals remain in messaging code (`grep -r "refetchInterval" web/lib/queries/comms.ts` returns empty)
3. TypeScript compilation passes on both web and iOS
4. iOS WatermelonDB observers trigger component updates when Realtime inserts a message (architectural verification -- RealtimeContext creates Message record via db.write)
5. Web TanStack Query cache is invalidated on Realtime events (architectural verification -- invalidateQueries called in Realtime handler)
</verification>

<success_criteria>
- Single Realtime channel per user on both platforms (not one per conversation)
- All polling (30s conversations, 10s messages) completely removed from web
- iOS Realtime events flow through WatermelonDB for offline-safe rendering
- Web header unread badge updates live (not just on page load)
- No TypeScript compilation errors
</success_criteria>

<output>
After completion, create `.planning/phases/43-real-time-push-notifications/43-01-SUMMARY.md`
</output>
