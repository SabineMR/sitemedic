---
phase: 43-real-time-push-notifications
plan: 03
type: execute
wave: 2
depends_on: ["43-02"]
files_modified:
  - supabase/functions/send-message-notification/index.ts
  - supabase/migrations/149_message_notification_trigger.sql
autonomous: true

must_haves:
  truths:
    - "When the iOS app is backgrounded, medic receives a push notification for new messages"
    - "Push notification shows only sender name -- never message content (GDPR compliance)"
    - "Both 1:1 and broadcast messages trigger push notifications"
    - "Notifications are not sent to the message sender (no self-notifications)"
    - "Invalid device tokens (DeviceNotRegistered) are cleaned up from profiles table"
  artifacts:
    - path: "supabase/functions/send-message-notification/index.ts"
      provides: "Edge Function that sends GDPR-safe push via Expo Push API"
      min_lines: 80
    - path: "supabase/migrations/149_message_notification_trigger.sql"
      provides: "PostgreSQL trigger on messages INSERT that invokes Edge Function"
      contains: "CREATE TRIGGER"
  key_links:
    - from: "supabase/migrations/149_message_notification_trigger.sql"
      to: "supabase/functions/send-message-notification/index.ts"
      via: "AFTER INSERT trigger on messages table calls Edge Function via pg_net"
      pattern: "net\\.http_post|pg_net"
    - from: "supabase/functions/send-message-notification/index.ts"
      to: "https://exp.host/--/api/v2/push/send"
      via: "HTTP POST to Expo Push API with GDPR-safe payload"
      pattern: "exp\\.host.*push/send"
---

<objective>
Create the server-side push notification pipeline: a PostgreSQL trigger fires on every message INSERT, which invokes an Edge Function that resolves the recipient's push token and sends a GDPR-safe notification via the Expo Push API.

Purpose: This completes the push notification flow. Plan 43-02 registered device tokens on the client. This plan uses those tokens to deliver notifications when messages are sent, so medics see alerts even when the app is backgrounded or closed.

Output: Edge Function `send-message-notification`, database migration with AFTER INSERT trigger on messages table, and token cleanup for unregistered devices.
</objective>

<execution_context>
@/Users/sabineresoagli/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sabineresoagli/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/43-real-time-push-notifications/43-RESEARCH.md
@.planning/phases/43-real-time-push-notifications/43-CONTEXT.md

Key existing files to reference:
@supabase/functions/notification-service/index.ts (existing Edge Function pattern -- follow same structure for imports, error handling, CORS)
@supabase/migrations/060_emergency_alerts.sql (profiles.push_token column definition)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Edge Function for GDPR-safe push notification delivery</name>
  <files>
    supabase/functions/send-message-notification/index.ts
  </files>
  <action>
    Create `supabase/functions/send-message-notification/index.ts` -- a Deno Edge Function triggered by the database trigger on message inserts:

    1. **Request handling:**
       - Accept POST with JSON body: `{ message_id, conversation_id, sender_id, org_id }`
       - Handle OPTIONS for CORS (same pattern as `notification-service/index.ts`)
       - Validate all required fields are present

    2. **Fetch sender name:**
       - Query `profiles` table for sender: `SELECT first_name, last_name FROM profiles WHERE id = sender_id`
       - If medic, also check `medics` table for name (some profiles may not have first/last name set)
       - Construct sender display name: `${first_name} ${last_name}`.trim() or "Someone" as fallback
       - IMPORTANT: Do NOT fetch `messages.content` -- it must never appear in the notification payload

    3. **Determine recipients:**
       - Fetch conversation type: `SELECT type, medic_id, created_by FROM conversations WHERE id = conversation_id`

       **For `type = 'direct'` (1:1 messages):**
       - If sender_id === medic_id: recipient is created_by (admin sent to medic, medic responded back to admin)
       - Wait -- re-read the schema: In the conversations table, `medic_id` is the medic in the conversation and `created_by` is who created it. For a 1:1 conversation:
         - If sender is the medic (sender_id === medic_id), notify the admin (created_by)
         - If sender is not the medic, notify the medic (medic_id)
       - Fetch recipient's push_token: `SELECT push_token FROM profiles WHERE id = recipientId AND push_token IS NOT NULL`
       - If no token, return `{ skipped: true, reason: 'No push token' }`

       **For `type = 'broadcast'` (broadcast messages):**
       - Fetch all org members with push tokens EXCEPT the sender:
         `SELECT push_token FROM profiles WHERE org_id = org_id AND id != sender_id AND push_token IS NOT NULL`
       - May return many tokens (large org)

    4. **Build GDPR-safe payload:**
       ```typescript
       // GDPR: Sender name only, NEVER message content
       const notificationBody = conversation.type === 'broadcast'
         ? `New broadcast from ${senderName}`
         : `New message from ${senderName}`;

       const payload = {
         to: recipientTokens, // Array of ExpoPushToken strings
         sound: 'default',
         title: 'SiteMedic',
         body: notificationBody,
         data: {
           conversationId: conversation_id,
           messageId: message_id,
           url: `messages/${conversation_id}`, // Deep link
         },
       };
       ```
       - If more than 100 tokens (large broadcast), chunk into batches of 100 for Expo Push API

    5. **Send via Expo Push API:**
       - POST to `https://exp.host/--/api/v2/push/send`
       - Headers: `Content-Type: application/json`, `Accept: application/json`
       - If `EXPO_ACCESS_TOKEN` env var exists, add `Authorization: Bearer ${EXPO_ACCESS_TOKEN}` header (optional but recommended for higher rate limits)
       - Parse response and handle errors

    6. **Token cleanup on DeviceNotRegistered:**
       - Check response `data` array for items where `status === 'error'` and `details.error === 'DeviceNotRegistered'`
       - For each bad token, clear it from profiles: `UPDATE profiles SET push_token = NULL, push_token_updated_at = NULL WHERE push_token = badToken`
       - Log cleaned tokens: `[PushNotification] Cleaned unregistered token for user: ${userId}`

    7. **Error handling:**
       - If Edge Function fails entirely, return 500 with error message (message delivery is not affected -- only push notification fails)
       - Log all errors with `[PushNotification]` prefix for monitoring
       - Never throw -- always return a Response

    8. **Don't notify sender:** Double-check that the sender's push_token is never included in the recipient list. Filter by `id != sender_id` in the query.
  </action>
  <verify>
    - File exists at `supabase/functions/send-message-notification/index.ts`
    - Grep for `exp.host` -- confirms Expo Push API URL
    - Grep for `content` in the payload construction section -- should NOT find `message.content` being passed to the notification body (GDPR check)
    - Grep for `senderName` in the body field -- confirms only sender name is used
    - Grep for `DeviceNotRegistered` -- confirms token cleanup logic
    - Grep for `sender_id` in WHERE clause -- confirms sender is excluded from recipients
  </verify>
  <done>
    Edge Function receives message details, resolves sender name and recipient tokens, sends GDPR-safe push notification ("New message from [name]") via Expo Push API, handles broadcasts (all org members), and cleans up invalid tokens. Message content never appears in any notification payload.
  </done>
</task>

<task type="auto">
  <name>Task 2: Database trigger on messages INSERT to invoke Edge Function</name>
  <files>
    supabase/migrations/149_message_notification_trigger.sql
  </files>
  <action>
    Create migration `supabase/migrations/149_message_notification_trigger.sql`:

    1. **Enable pg_net extension** (if not already enabled):
       ```sql
       CREATE EXTENSION IF NOT EXISTS pg_net WITH SCHEMA extensions;
       ```
       pg_net allows PostgreSQL to make HTTP requests to Edge Functions asynchronously (non-blocking).

    2. **Create trigger function:**
       ```sql
       CREATE OR REPLACE FUNCTION public.notify_new_message()
       RETURNS trigger AS $$
       BEGIN
         -- Fire-and-forget HTTP POST to Edge Function via pg_net
         -- This is async and does NOT block the INSERT transaction
         PERFORM net.http_post(
           url := (SELECT COALESCE(current_setting('app.supabase_url', TRUE), '') || '/functions/v1/send-message-notification'),
           headers := jsonb_build_object(
             'Content-Type', 'application/json',
             'Authorization', 'Bearer ' || (SELECT COALESCE(current_setting('app.service_role_key', TRUE), ''))
           ),
           body := jsonb_build_object(
             'message_id', NEW.id,
             'conversation_id', NEW.conversation_id,
             'sender_id', NEW.sender_id,
             'org_id', NEW.org_id
           )
         );
         RETURN NEW;
       END;
       $$ LANGUAGE plpgsql SECURITY DEFINER;
       ```

       **Important:** Use `current_setting('app.supabase_url', TRUE)` and `current_setting('app.service_role_key', TRUE)` for the URL and auth. These are Supabase's automatic config variables available in PostgreSQL. The `TRUE` parameter means "return NULL if not set" instead of throwing.

       **Alternative approach** if `app.supabase_url` is not available (common in Supabase hosted): Use the direct project URL pattern:
       ```sql
       -- If current_setting doesn't work, hardcode the URL pattern
       -- Replace with: Deno.env.get('SUPABASE_URL') approach
       -- OR use vault: SELECT decrypted_secret FROM vault.decrypted_secrets WHERE name = 'supabase_url'
       ```
       Check which approach works by looking at existing Edge Function invocations in the codebase. If other triggers already call Edge Functions, follow their pattern exactly.

       **Fallback:** If pg_net is not available (older Supabase plans), use `supabase_functions.http_request` which is the built-in Supabase webhook mechanism:
       ```sql
       -- Alternative: Use Supabase's built-in webhook infrastructure
       -- This can be configured in the Supabase Dashboard under Database -> Webhooks
       ```
       Prefer pg_net as it's more explicit and version-controlled.

    3. **Create the trigger:**
       ```sql
       CREATE TRIGGER on_message_insert_notify
       AFTER INSERT ON public.messages
       FOR EACH ROW
       EXECUTE FUNCTION public.notify_new_message();
       ```

    4. **Add a comment for documentation:**
       ```sql
       COMMENT ON TRIGGER on_message_insert_notify ON public.messages IS
         'Phase 43: Fires Edge Function to send push notification on new message. GDPR-safe (sender name only).';
       ```

    5. **Migration number:** 149 follows the convention (148 was the last migration for job_ratings in Phase 34.1). Verify by checking the last migration file number:
       - List files in `supabase/migrations/` to confirm 148 is the latest
       - If a different number is latest, adjust accordingly

    NOTE: Do NOT modify the database schema (no ALTER TABLE, no new columns). The `profiles.push_token` column already exists from migration 060. The `messages` table already has all needed columns from migration 143. This migration ONLY adds a trigger function and trigger.
  </action>
  <verify>
    - File exists at `supabase/migrations/149_message_notification_trigger.sql`
    - Grep for `CREATE TRIGGER` -- confirms trigger creation
    - Grep for `AFTER INSERT ON.*messages` -- confirms trigger fires on message insert
    - Grep for `send-message-notification` -- confirms Edge Function URL reference
    - Grep for `net.http_post\|http_request` -- confirms async HTTP call
    - Grep for `sender_id` in the body -- confirms sender_id is passed to Edge Function
    - Migration does NOT contain `ALTER TABLE` or `ADD COLUMN` (no schema changes)
  </verify>
  <done>
    PostgreSQL AFTER INSERT trigger on messages table fires asynchronously via pg_net, calling the send-message-notification Edge Function with message_id, conversation_id, sender_id, and org_id. The trigger is non-blocking (does not delay message INSERT). No schema changes -- uses existing tables and columns.
  </done>
</task>

</tasks>

<verification>
1. Edge Function handles both direct (1:1) and broadcast message types
2. Push payload contains ONLY sender name -- grep for `content` in payload construction returns nothing
3. Trigger fires on every message INSERT (AFTER INSERT, FOR EACH ROW)
4. Trigger is async via pg_net (does not block the INSERT transaction)
5. DeviceNotRegistered tokens are cleaned from profiles table
6. Sender never receives their own notification (filtered by sender_id)
7. No database schema changes (no ALTER TABLE, no new columns)
</verification>

<success_criteria>
- Every message INSERT triggers the Edge Function via pg_net
- Push notifications delivered via Expo Push API to recipient device tokens
- Notification shows "New message from [Name]" or "New broadcast from [Name]" -- never message content
- Both direct and broadcast messages trigger notifications
- Invalid tokens cleaned up on DeviceNotRegistered error
- Sender excluded from notification recipients
- Migration is additive only (trigger + function, no schema changes)
</success_criteria>

<output>
After completion, create `.planning/phases/43-real-time-push-notifications/43-03-SUMMARY.md`
</output>
