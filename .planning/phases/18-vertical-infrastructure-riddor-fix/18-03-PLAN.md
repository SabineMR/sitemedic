---
phase: 18-vertical-infrastructure-riddor-fix
plan: 03
type: execute
wave: 2
depends_on: ["18-01"]
files_modified:
  - src/contexts/OrgContext.tsx
  - app/_layout.tsx
autonomous: true

must_haves:
  truths:
    - "After login, the mobile app stores the org's industry_verticals in AsyncStorage under key sitemedic.org.vertical_cache without a second Supabase fetch on every form mount"
    - "Any component in the app can call useOrg() and receive primaryVertical and orgId"
    - "OrgProvider is mounted inside AuthProvider and outside SyncProvider in app/_layout.tsx"
    - "If AsyncStorage has a valid cache for the current org, no Supabase network call is made — the cache is used directly"
    - "When the device is offline and a cached vertical exists, useOrg() returns the cached vertical without error"
  artifacts:
    - path: "src/contexts/OrgContext.tsx"
      provides: "OrgProvider component and useOrg hook"
      contains: "sitemedic.org.vertical_cache"
    - path: "app/_layout.tsx"
      provides: "OrgProvider inserted between AuthProvider and SyncProvider"
      contains: "OrgProvider"
  key_links:
    - from: "src/contexts/OrgContext.tsx"
      to: "src/lib/auth-manager.ts"
      via: "useAuth() hook — reads state.user.orgId which comes from authManager.getUserProfile()"
      pattern: "useAuth"
    - from: "src/contexts/OrgContext.tsx"
      to: "org_settings table"
      via: "supabase.from('org_settings').select('industry_verticals').eq('org_id', orgId)"
      pattern: "org_settings"
    - from: "app/_layout.tsx"
      to: "src/contexts/OrgContext.tsx"
      via: "OrgProvider wraps SyncProvider inside AuthProvider"
      pattern: "OrgProvider"
---

<objective>
Create the mobile OrgContext that fetches the org's industry_verticals once at login, caches them in AsyncStorage, and exposes primaryVertical to all components via useOrg() hook.

Purpose: Currently, new.tsx (the treatment form) calls Supabase directly on every mount to get the org vertical (lines 93-113). This is a network call that fails offline and is repeated on every form open. OrgContext centralises this to one fetch per login session, cached for offline use. All subsequent Phase 18 plans (18-04 especially) depend on useOrg() being available.

Output: src/contexts/OrgContext.tsx (new file), app/_layout.tsx (OrgProvider inserted into provider tree).
</objective>

<execution_context>
@/Users/sabineresoagli/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sabineresoagli/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-vertical-infrastructure-riddor-fix/18-RESEARCH.md
@.planning/phases/18-vertical-infrastructure-riddor-fix/18-01-SUMMARY.md
@src/contexts/AuthContext.tsx
@src/lib/auth-manager.ts
@app/_layout.tsx
@web/contexts/org-context.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create src/contexts/OrgContext.tsx with AsyncStorage caching</name>
  <files>src/contexts/OrgContext.tsx</files>
  <action>
    Create `src/contexts/OrgContext.tsx` as a new file. Model it on `web/contexts/org-context.tsx` but adapted for React Native with AsyncStorage.

    Key design decisions (from research):
    - AsyncStorage key: `'sitemedic.org.vertical_cache'` (follows `sitemedic.*` convention from auth-manager.ts)
    - Cache format: `{ orgId: string, verticals: string[] }` — include orgId so cache can be invalidated if org changes
    - Always attempt network fetch on SIGNED_IN; fall back to cache on network error
    - Gate fetch on `state.isAuthenticated && !state.isLoading && state.user?.orgId` — prevents fetch with null orgId (research Pitfall 2)
    - `primaryVertical` = `industryVerticals[0] ?? 'general'` (first element is the primary; confirmed with multi-vertical open question resolution)

    Full implementation:

    ```typescript
    /**
     * OrgContext — Mobile
     * Phase 18: Vertical Infrastructure
     *
     * Fetches org industry_verticals once at login, caches in AsyncStorage.
     * Exposes primaryVertical and orgId to all components via useOrg() hook.
     *
     * Placement: Inside AuthProvider, outside SyncProvider (app/_layout.tsx).
     * Cache key: 'sitemedic.org.vertical_cache' — { orgId, verticals }
     *
     * Pitfall avoided: Gate fetch on isAuthenticated + user.orgId.
     * If orgId is null (session not yet resolved), return loading state.
     * Cache is read first; network fetch updates it on every login.
     */

    import React, {
      createContext,
      useContext,
      useState,
      useEffect,
      ReactNode,
    } from 'react';
    import AsyncStorage from '@react-native-async-storage/async-storage';
    import { supabase } from '../lib/supabase';
    import { useAuth } from './AuthContext';

    const VERTICAL_CACHE_KEY = 'sitemedic.org.vertical_cache';

    interface OrgContextValue {
      orgId: string | null;
      industryVerticals: string[];
      primaryVertical: string;  // industryVerticals[0] ?? 'general'
      loading: boolean;
    }

    const OrgContext = createContext<OrgContextValue | undefined>(undefined);

    interface OrgProviderProps {
      children: ReactNode;
    }

    export function OrgProvider({ children }: OrgProviderProps) {
      const { state } = useAuth();
      const [orgId, setOrgId] = useState<string | null>(null);
      const [industryVerticals, setIndustryVerticals] = useState<string[]>([]);
      const [loading, setLoading] = useState(true);

      useEffect(() => {
        // Do not attempt fetch until auth has resolved and user is authenticated.
        // Pitfall 2: state.isLoading is true on first render; state.user is null.
        if (state.isLoading || !state.isAuthenticated || !state.user?.orgId) {
          if (!state.isLoading && !state.isAuthenticated) {
            // User is logged out — clear context
            setOrgId(null);
            setIndustryVerticals([]);
            setLoading(false);
          }
          return;
        }

        const currentOrgId = state.user.orgId;
        setOrgId(currentOrgId);

        async function loadVertical() {
          try {
            // 1. Check AsyncStorage cache first (offline-first).
            // If cache matches current org, use it immediately.
            const cached = await AsyncStorage.getItem(VERTICAL_CACHE_KEY);
            if (cached) {
              const parsed: { orgId: string; verticals: string[] } = JSON.parse(cached);
              if (parsed.orgId === currentOrgId && Array.isArray(parsed.verticals)) {
                setIndustryVerticals(parsed.verticals);
                setLoading(false);
                // Continue to network fetch — cache will be updated if value changed.
                // This implements Pitfall 4 mitigation: always fetch, always update cache.
              }
            }

            // 2. Always attempt network fetch to keep cache fresh.
            // If offline, the cache read above already set the value; this will fail silently.
            const { data, error } = await supabase
              .from('org_settings')
              .select('industry_verticals')
              .eq('org_id', currentOrgId)
              .single();

            if (!error && data?.industry_verticals && Array.isArray(data.industry_verticals)) {
              const verticals = data.industry_verticals as string[];
              setIndustryVerticals(verticals);

              // Update cache with latest value (handles admin vertical change — Pitfall 4).
              await AsyncStorage.setItem(
                VERTICAL_CACHE_KEY,
                JSON.stringify({ orgId: currentOrgId, verticals })
              );
            }
          } catch {
            // Network error — cached value from step 1 is still in state. Non-fatal.
            console.log('[OrgContext] Network fetch failed — using cached vertical');
          } finally {
            setLoading(false);
          }
        }

        loadVertical();
      }, [state.isLoading, state.isAuthenticated, state.user?.orgId]);

      const primaryVertical = industryVerticals[0] ?? 'general';

      return (
        <OrgContext.Provider value={{ orgId, industryVerticals, primaryVertical, loading }}>
          {children}
        </OrgContext.Provider>
      );
    }

    /**
     * useOrg — access org vertical context.
     * Must be used inside OrgProvider (which is inside AuthProvider).
     *
     * Returns: { orgId, industryVerticals, primaryVertical, loading }
     */
    export function useOrg(): OrgContextValue {
      const ctx = useContext(OrgContext);
      if (!ctx) {
        throw new Error('useOrg must be used within OrgProvider');
      }
      return ctx;
    }
    ```

    The import path `../lib/supabase` matches the pattern used in other files under `src/` (e.g., `src/lib/auth-manager.ts` imports from `./supabase`). Since this file is at `src/contexts/OrgContext.tsx`, the relative path to the supabase client is `../lib/supabase`.

    The import `from './AuthContext'` matches how SyncContext imports AuthContext (`src/contexts/SyncContext.tsx`).
  </action>
  <verify>
    `ls src/contexts/OrgContext.tsx` — file exists.
    `grep -c "useOrg" src/contexts/OrgContext.tsx` — at least 2 (function definition + export).
    `grep "sitemedic.org.vertical_cache" src/contexts/OrgContext.tsx` — 1 match.
    `grep "industryVerticals\[0\]" src/contexts/OrgContext.tsx` — 1 match (primaryVertical derivation).
    `pnpm tsc --noEmit` — zero TypeScript errors.
  </verify>
  <done>src/contexts/OrgContext.tsx exists with OrgProvider and useOrg exports. AsyncStorage caching with sitemedic.org.vertical_cache key. Network fetch always runs on login and updates the cache. Loading state gated on auth resolution. TypeScript compiles cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: Register OrgProvider in app/_layout.tsx between AuthProvider and SyncProvider</name>
  <files>app/_layout.tsx</files>
  <action>
    Read `app/_layout.tsx` first to confirm current state (confirmed from research: OrgProvider is not present).

    Make two changes to `app/_layout.tsx`:

    1. Add import at the top of the file, after the existing context imports (after line 24 where SyncProvider is imported):
       ```typescript
       import { OrgProvider } from '../src/contexts/OrgContext';
       ```

    2. In the JSX return (around lines 85-165), insert `<OrgProvider>` between `<AuthProvider>` and `<SyncProvider>`. The result should be:
       ```tsx
       <AuthProvider>
         <OrgProvider>
           <SyncProvider>
             <BottomSheetModalProvider>
               ...
             </BottomSheetModalProvider>
           </SyncProvider>
         </OrgProvider>
       </AuthProvider>
       ```

    Critical placement rules (from research):
    - OrgProvider MUST be inside AuthProvider because it calls useAuth() which reads from AuthContext. If placed outside, useAuth() throws "must be used within AuthProvider".
    - OrgProvider MUST be outside SyncProvider because SyncContext reads vertical for compliance scoring in later phases. SyncProvider can then call useOrg() safely.
    - SOSButton remains outside all providers (current line 164) — do not change this.
    - EmergencyAlertReceiver inside BottomSheetModalProvider — do not change this.

    Do NOT change any other part of the file (Stack.Screen definitions, database initialization, error handling, etc.).
  </action>
  <verify>
    `grep -n "OrgProvider" app/_layout.tsx` — expect 3 matches: import line, opening tag, closing tag.
    `grep -n "AuthProvider" app/_layout.tsx` — confirm OrgProvider appears between AuthProvider lines.
    `pnpm tsc --noEmit` — zero TypeScript errors.
  </verify>
  <done>app/_layout.tsx imports OrgProvider from src/contexts/OrgContext and wraps SyncProvider with it, inside AuthProvider. Provider nesting order is: AuthProvider > OrgProvider > SyncProvider > BottomSheetModalProvider. TypeScript compiles cleanly.</done>
</task>

</tasks>

<verification>
After both tasks complete:

1. OrgContext created: `ls src/contexts/OrgContext.tsx` → exists
2. Provider tree: `grep -A3 "AuthProvider>" app/_layout.tsx` → shows OrgProvider immediately inside
3. Cache key: `grep "sitemedic.org.vertical_cache" src/contexts/OrgContext.tsx` → 1 match
4. Hook export: `grep "export function useOrg" src/contexts/OrgContext.tsx` → 1 match
5. TypeScript: `pnpm tsc --noEmit` → zero errors
6. Import: `grep "OrgProvider" app/_layout.tsx` → 3 lines (import + open + close tags)
</verification>

<success_criteria>
- src/contexts/OrgContext.tsx exists with OrgProvider and useOrg exported
- OrgProvider reads from org_settings table using state.user.orgId from AuthContext
- AsyncStorage caching under 'sitemedic.org.vertical_cache' with { orgId, verticals } format
- Network fetch always runs on login to keep cache fresh (Pitfall 4 mitigation)
- app/_layout.tsx has OrgProvider between AuthProvider and SyncProvider
- pnpm tsc --noEmit passes with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/18-vertical-infrastructure-riddor-fix/18-03-SUMMARY.md`
</output>
