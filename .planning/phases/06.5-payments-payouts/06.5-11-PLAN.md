---
phase: 06.5-payments-payouts
plan: 11
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/025_payslip_schema_fix.sql
  - supabase/migrations/026_late_payment_cron_auth_fix.sql
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Payslip PDF generated (gross, deductions, net) for medic records with payslip_reference"
    - "Late payment auto-reminders cron uses vault.decrypted_secrets for production-safe auth"
  artifacts:
    - path: "supabase/migrations/025_payslip_schema_fix.sql"
      provides: "payslip_reference column and pg_net trigger for Edge Function invocation"
      contains: "payslip_reference"
    - path: "supabase/migrations/026_late_payment_cron_auth_fix.sql"
      provides: "Corrected late payment cron job using vault secrets"
      contains: "vault.decrypted_secrets"
  key_links:
    - from: "supabase/migrations/025_payslip_schema_fix.sql"
      to: "supabase/functions/generate-payslip-pdf/index.ts"
      via: "pg_net.http_post call in trigger after payslip INSERT"
      pattern: "net\\.http_post.*generate-payslip-pdf"
    - from: "supabase/migrations/026_late_payment_cron_auth_fix.sql"
      to: "vault.decrypted_secrets"
      via: "SELECT decrypted_secret FROM vault.decrypted_secrets"
      pattern: "vault\\.decrypted_secrets"
---

<objective>
Close the final 2 verification gaps in Phase 6.5 Payments & Payouts.

**Gap 1 (Payslip PDF):** The payslips table (migration 024) is missing a `payslip_reference` field that the Edge Function `generate-payslip-pdf/index.ts` expects at line 107. Additionally, the trigger that creates payslip records does NOT invoke the Edge Function, so `pdf_url` remains null. Fix: Add the column and wire a pg_net HTTP POST trigger to call the Edge Function after payslip creation.

**Gap 2 (Late Payment Cron Auth):** Migration 020 uses `current_setting()` for auth (lines 22-23) which requires manual env var configuration and is inconsistent with the `vault.decrypted_secrets` pattern used by migrations 021 (RIDDOR) and 022 (Friday payout). Fix: Unschedule the old cron job and re-create it with vault pattern.

Purpose: Achieve 12/12 must-haves for Phase 6.5 verification (currently 10/12).
Output: Two corrective migrations that close both remaining gaps.
</objective>

<execution_context>
@/Users/sabineresoagli/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sabineresoagli/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06.5-payments-payouts/06.5-VERIFICATION.md
@supabase/migrations/024_payslip_generation.sql
@supabase/migrations/020_late_payment_reminders.sql
@supabase/migrations/022_friday_payout_cron.sql
@supabase/migrations/021_riddor_deadline_cron.sql
@supabase/functions/generate-payslip-pdf/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix payslip_reference schema and wire Edge Function trigger</name>
  <files>supabase/migrations/025_payslip_schema_fix.sql</files>
  <action>
    Create migration `025_payslip_schema_fix.sql` that does three things:

    1. **Add payslip_reference column** to the payslips table:
       ```sql
       ALTER TABLE payslips ADD COLUMN payslip_reference TEXT UNIQUE NOT NULL
         DEFAULT ('PS-' || to_char(NOW(), 'YYYYMMDD') || '-' || substr(gen_random_uuid()::text, 1, 8));
       ```
       This generates a human-readable reference like `PS-20260216-a1b2c3d4` that the Edge Function expects at line 107.

    2. **Enable pg_net extension** (if not already enabled):
       ```sql
       CREATE EXTENSION IF NOT EXISTS pg_net;
       ```

    3. **Create or replace the trigger function** `generate_payslip_pdf_on_insert()` that fires AFTER INSERT on payslips table and calls the Edge Function via pg_net:
       ```sql
       CREATE OR REPLACE FUNCTION generate_payslip_pdf_on_insert()
       RETURNS TRIGGER AS $$
       DECLARE
         project_url TEXT;
         service_key TEXT;
       BEGIN
         -- Get credentials from vault (consistent with 021, 022 pattern)
         SELECT decrypted_secret INTO project_url
           FROM vault.decrypted_secrets WHERE name = 'project_url';
         SELECT decrypted_secret INTO service_key
           FROM vault.decrypted_secrets WHERE name = 'service_role_key';

         -- Call Edge Function to generate PDF (non-blocking via pg_net)
         PERFORM net.http_post(
           url := project_url || '/functions/v1/generate-payslip-pdf',
           headers := jsonb_build_object(
             'Content-Type', 'application/json',
             'Authorization', 'Bearer ' || service_key
           ),
           body := jsonb_build_object(
             'payslipId', NEW.id::text
           )
         );

         RETURN NEW;
       END;
       $$ LANGUAGE plpgsql;
       ```

    4. **Create the trigger** on the payslips table:
       ```sql
       CREATE TRIGGER trigger_generate_payslip_pdf
         AFTER INSERT ON payslips
         FOR EACH ROW
         EXECUTE FUNCTION generate_payslip_pdf_on_insert();
       ```

    5. Add comments explaining the migration purpose and dependencies.

    **Important:** Do NOT modify migration 024 directly (immutable migration files). This corrective migration layers on top.

    **Trigger execution order (cross-table cascade):**
    The two triggers fire on DIFFERENT tables and form a cascade chain, NOT a same-table ordering concern:
    1. `trigger_generate_payslip_on_payout` (migration 024) fires `AFTER UPDATE ON timesheets` -- creates a payslip row via INSERT.
    2. `trigger_generate_payslip_pdf` (this migration 025) fires `AFTER INSERT ON payslips` -- calls the Edge Function via pg_net.
    PostgreSQL executes cascading triggers correctly: when trigger 024's INSERT INTO payslips fires, it triggers 025's AFTER INSERT on payslips within the same transaction. No alphabetical ordering concern exists because these triggers live on separate tables (timesheets vs payslips).

    **Why this approach:**
    - The payslip_reference field uses gen_random_uuid() substring for uniqueness, matching the Edge Function expectation at line 107.
    - pg_net makes the HTTP POST non-blocking (returns immediately, PDF generates asynchronously).
    - vault.decrypted_secrets matches the auth pattern established in migrations 021 and 022.
    - The AFTER INSERT trigger fires automatically when the existing trigger_generate_payslip_on_payout creates a payslip row.
  </action>
  <verify>
    Verify the migration file exists and contains:
    1. `ALTER TABLE payslips ADD COLUMN payslip_reference` with UNIQUE constraint
    2. `CREATE OR REPLACE FUNCTION generate_payslip_pdf_on_insert()` using vault.decrypted_secrets
    3. `net.http_post` call to `generate-payslip-pdf` Edge Function
    4. `CREATE TRIGGER trigger_generate_payslip_pdf AFTER INSERT ON payslips`

    Run: `grep -c 'payslip_reference\|vault.decrypted_secrets\|generate-payslip-pdf\|trigger_generate_payslip_pdf' supabase/migrations/025_payslip_schema_fix.sql` should return 4+

    Verify trigger cascade chain (both triggers exist with correct timing on their respective tables):
    Run: `grep -A 3 'CREATE TRIGGER trigger_generate_payslip' supabase/migrations/024_payslip_generation.sql supabase/migrations/025_payslip_schema_fix.sql`
    Expected: 024 shows `AFTER UPDATE ON timesheets`, 025 shows `AFTER INSERT ON payslips` -- confirming cross-table cascade.
  </verify>
  <done>
    payslips table has payslip_reference column, and new payslip rows automatically trigger Edge Function invocation via pg_net to generate PDF.
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix late payment cron auth pattern to use vault secrets</name>
  <files>supabase/migrations/026_late_payment_cron_auth_fix.sql</files>
  <action>
    Create migration `026_late_payment_cron_auth_fix.sql` that:

    1. **Unschedule the old cron job** created by migration 020:
       ```sql
       SELECT cron.unschedule('check-overdue-invoices-daily');
       ```

    2. **Re-create the cron job** with the vault.decrypted_secrets pattern (matching migrations 021 and 022):
       ```sql
       SELECT cron.schedule(
         'check-overdue-invoices-daily',
         '0 10 * * *',
         $$
         DECLARE
           invoice_rec RECORD;
         BEGIN
           -- Find invoices needing 7-day reminder
           FOR invoice_rec IN
             SELECT id FROM invoices
             WHERE status = 'sent'
               AND due_date = CURRENT_DATE - INTERVAL '7 days'
               AND reminder_sent_7_days = FALSE
           LOOP
             PERFORM net.http_post(
               url := (SELECT decrypted_secret FROM vault.decrypted_secrets WHERE name = 'project_url')
                      || '/functions/v1/send-invoice-reminder',
               headers := jsonb_build_object(
                 'Content-Type', 'application/json',
                 'Authorization', 'Bearer ' || (SELECT decrypted_secret FROM vault.decrypted_secrets WHERE name = 'service_role_key')
               ),
               body := jsonb_build_object('invoiceId', invoice_rec.id, 'reminderType', '7_days')
             );
           END LOOP;

           -- Find invoices needing 14-day reminder
           FOR invoice_rec IN
             SELECT id FROM invoices
             WHERE status IN ('sent', 'overdue')
               AND due_date = CURRENT_DATE - INTERVAL '14 days'
               AND reminder_sent_14_days = FALSE
           LOOP
             PERFORM net.http_post(
               url := (SELECT decrypted_secret FROM vault.decrypted_secrets WHERE name = 'project_url')
                      || '/functions/v1/send-invoice-reminder',
               headers := jsonb_build_object(
                 'Content-Type', 'application/json',
                 'Authorization', 'Bearer ' || (SELECT decrypted_secret FROM vault.decrypted_secrets WHERE name = 'service_role_key')
               ),
               body := jsonb_build_object('invoiceId', invoice_rec.id, 'reminderType', '14_days')
             );
           END LOOP;

           -- Find invoices needing 21-day reminder (with late fee)
           FOR invoice_rec IN
             SELECT id FROM invoices
             WHERE status IN ('sent', 'overdue')
               AND due_date = CURRENT_DATE - INTERVAL '21 days'
               AND reminder_sent_21_days = FALSE
           LOOP
             PERFORM net.http_post(
               url := (SELECT decrypted_secret FROM vault.decrypted_secrets WHERE name = 'project_url')
                      || '/functions/v1/send-invoice-reminder',
               headers := jsonb_build_object(
                 'Content-Type', 'application/json',
                 'Authorization', 'Bearer ' || (SELECT decrypted_secret FROM vault.decrypted_secrets WHERE name = 'service_role_key')
               ),
               body := jsonb_build_object('invoiceId', invoice_rec.id, 'reminderType', '21_days')
             );
           END LOOP;
         END;
         $$
       );
       ```

    3. Add comments explaining this is a corrective migration replacing current_setting() with vault pattern.

    **Why this approach:**
    - `cron.unschedule()` cleanly removes the old job before re-creating it.
    - `vault.decrypted_secrets` is the established production pattern (used by 021_riddor and 022_friday_payout).
    - `current_setting()` requires manual `ALTER DATABASE postgres SET app.supabase_url = ...` configuration which is fragile and may not persist across restarts.
    - vault secrets are configured once in Supabase Dashboard and available to all cron jobs.
    - The invoice query logic and reminder types (7, 14, 21 days) remain identical -- only the auth pattern changes.
  </action>
  <verify>
    Verify the migration file exists and contains:
    1. `cron.unschedule('check-overdue-invoices-daily')` to remove old job
    2. `cron.schedule('check-overdue-invoices-daily'` to re-create with vault
    3. `vault.decrypted_secrets` pattern (NOT current_setting)
    4. NO `current_setting` references

    Run: `grep -c 'vault.decrypted_secrets' supabase/migrations/026_late_payment_cron_auth_fix.sql` should return 6 (project_url x3 + service_role_key x3)
    Run: `grep -c 'current_setting' supabase/migrations/026_late_payment_cron_auth_fix.sql` should return 0

    Verify the cron job is properly scheduled (SQL structure is valid):
    Run: `grep 'SELECT cron.schedule' supabase/migrations/026_late_payment_cron_auth_fix.sql` should confirm the schedule call exists.
    Run: `grep 'SELECT cron.unschedule' supabase/migrations/026_late_payment_cron_auth_fix.sql` should confirm the old job removal exists.
  </verify>
  <done>
    Late payment reminder cron job uses vault.decrypted_secrets for auth, consistent with RIDDOR (021) and Friday payout (022) crons. No manual env var configuration required.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **Payslip flow verification:** Confirm the chain: timesheet.payout_status='paid' -> trigger_generate_payslip_on_payout (024) creates payslip row -> trigger_generate_payslip_pdf (025) calls Edge Function -> Edge Function reads payslip_reference (now exists) -> PDF uploaded -> pdf_url updated.

2. **Auth pattern consistency:** Verify all 3 cron jobs use vault.decrypted_secrets:
   - `grep -r 'vault.decrypted_secrets' supabase/migrations/021_riddor_deadline_cron.sql` (should match)
   - `grep -r 'vault.decrypted_secrets' supabase/migrations/022_friday_payout_cron.sql` (should match)
   - `grep -r 'vault.decrypted_secrets' supabase/migrations/026_late_payment_cron_auth_fix.sql` (should match)
   - `grep -r 'current_setting' supabase/migrations/` (should match ONLY migration 020 which is superseded by 026)

3. **Migration numbering:** Confirm sequential: 024 -> 025 -> 026 with no gaps or duplicates.
</verification>

<success_criteria>
- payslips table has payslip_reference TEXT UNIQUE NOT NULL column
- New payslip INSERT triggers Edge Function call via pg_net
- Late payment cron uses vault.decrypted_secrets (not current_setting)
- All 3 cron jobs (RIDDOR, Friday payout, late payment) use consistent auth pattern
- Phase 6.5 verification score moves from 10/12 to 12/12
</success_criteria>

<output>
After completion, create `.planning/phases/06.5-payments-payouts/06.5-11-SUMMARY.md`
</output>
