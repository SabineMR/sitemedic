---
phase: 26
plan: 02
name: Middleware Subdomain Extraction & Header Injection
wave: 1
depends_on: []
autonomous: true
gap_closure: false
files_modified:
  - web/lib/supabase/middleware.ts
  - web/middleware.ts
---

<objective>
Add subdomain extraction, security header stripping, service-role org lookup, and x-org-* header injection to the Next.js middleware. This is the core infrastructure for the entire white-label subdomain system. After this plan, all downstream SSR pages can read org context from request headers.

Requirements addressed: ROUTE-01 (partial — code side), ROUTE-02, ROUTE-03.
</objective>

<must_haves>
- extractSubdomain() helper correctly parses subdomain from host header
- All x-org-* headers are stripped BEFORE any processing (CVE-2025-29927 mitigation)
- Service-role Supabase client performs org lookup by slug
- x-org-id, x-org-slug, x-org-tier, x-org-company-name, x-org-primary-colour, x-org-logo-url, x-org-tagline headers injected for resolved orgs
- Unknown subdomain redirects to apex domain root
- Apex domain and Vercel preview deploys pass through unmodified
- Existing auth flow (getUser, public routes, role redirects) continues to work unchanged
</must_haves>

<tasks>

<task id="1" name="Add extractSubdomain helper to middleware" type="code">
Add a new function `extractSubdomain()` to `web/lib/supabase/middleware.ts` (above `updateSession`):

```typescript
/**
 * Extract subdomain from the request host header.
 * Returns the subdomain string (e.g., 'apex') or null for apex/www/preview domains.
 */
function extractSubdomain(request: NextRequest): string | null {
  const hostname = request.headers.get('host') ?? '';
  const rootDomain = process.env.NEXT_PUBLIC_ROOT_DOMAIN ?? 'sitemedic.co.uk';

  // Apex domain and www — no subdomain
  if (hostname === rootDomain || hostname === `www.${rootDomain}`) {
    return null;
  }

  // Vercel preview deployments — skip subdomain logic
  if (hostname.endsWith('.vercel.app')) {
    return null;
  }

  // Local dev: tenant.localhost:30500 → 'tenant'
  const hostnameWithoutPort = hostname.split(':')[0];
  const rootWithoutPort = rootDomain.split(':')[0];

  if (hostnameWithoutPort.endsWith(`.${rootWithoutPort}`)) {
    const subdomain = hostnameWithoutPort.replace(`.${rootWithoutPort}`, '');
    return subdomain || null;
  }

  return null;
}
```

Edge cases handled:
- `sitemedic.co.uk` → null (apex)
- `www.sitemedic.co.uk` → null
- `apex.sitemedic.co.uk` → 'apex'
- `tenant.localhost:30500` → 'tenant' (local dev)
- `my-preview.vercel.app` → null (preview deploy)
</task>

<task id="2" name="Add security header stripping at top of updateSession" type="code">
At the VERY TOP of the `updateSession()` function (before the Supabase client creation), add header stripping:

```typescript
export async function updateSession(request: NextRequest) {
  // SECURITY: Strip any externally-injected x-org-* headers (CVE-2025-29927 mitigation)
  // These headers are set by OUR middleware only — never trust incoming values
  const ORG_HEADERS = [
    'x-org-id', 'x-org-slug', 'x-org-tier',
    'x-org-company-name', 'x-org-primary-colour',
    'x-org-logo-url', 'x-org-tagline',
  ];
  const requestHeaders = new Headers(request.headers);
  ORG_HEADERS.forEach(h => requestHeaders.delete(h));

  // ... rest of existing middleware ...
```

This must be the FIRST operation in `updateSession()` — before any Supabase client creation or route checking.

Modify the initial `NextResponse.next()` call to use the cleaned headers:
```typescript
  let supabaseResponse = NextResponse.next({
    request: { headers: requestHeaders },
  });
```
</task>

<task id="3" name="Add subdomain resolution and org lookup" type="code">
After header stripping and before the Supabase auth client creation, add subdomain resolution:

```typescript
  // Subdomain resolution — resolve org from slug
  const subdomain = extractSubdomain(request);

  if (subdomain) {
    // Service-role client for org lookup (bypasses RLS, server-only)
    const { createClient: createAdminClient } = await import('@supabase/supabase-js');
    const adminClient = createAdminClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.SUPABASE_SERVICE_ROLE_KEY!
    );

    // Single query: org + branding via join
    const { data: orgData } = await adminClient
      .from('organizations')
      .select(`
        id, slug, subscription_tier, subscription_status,
        org_branding ( company_name, primary_colour_hex, logo_path, tagline )
      `)
      .eq('slug', subdomain)
      .maybeSingle();

    if (!orgData) {
      // Unknown subdomain — redirect to apex domain root
      const rootDomain = process.env.NEXT_PUBLIC_ROOT_DOMAIN ?? 'sitemedic.co.uk';
      const protocol = request.nextUrl.protocol;
      return NextResponse.redirect(new URL(`${protocol}//${rootDomain}/`));
    }

    // Inject org context headers for downstream SSR pages
    requestHeaders.set('x-org-id', orgData.id);
    requestHeaders.set('x-org-slug', orgData.slug);
    requestHeaders.set('x-org-tier', orgData.subscription_tier ?? 'starter');

    // Branding headers (org_branding is returned as an object from the join)
    const branding = Array.isArray(orgData.org_branding)
      ? orgData.org_branding[0]
      : orgData.org_branding;

    if (branding) {
      requestHeaders.set('x-org-company-name', branding.company_name ?? '');
      requestHeaders.set('x-org-primary-colour', branding.primary_colour_hex ?? '');
      // Construct public logo URL from storage path
      if (branding.logo_path) {
        const logoUrl = `${process.env.NEXT_PUBLIC_SUPABASE_URL}/storage/v1/object/public/org-logos/${branding.logo_path}`;
        requestHeaders.set('x-org-logo-url', logoUrl);
      }
      requestHeaders.set('x-org-tagline', branding.tagline ?? '');
    }
  }
```

**Important:** The `supabaseResponse = NextResponse.next({ request: { headers: requestHeaders } })` at the bottom of the function ensures these headers propagate. The existing Supabase client creation that follows uses `request.cookies.getAll()` which is unaffected.

Also update the Supabase auth client `setAll` callback to preserve org headers:
```typescript
        setAll(cookiesToSet) {
          cookiesToSet.forEach(({ name, value }) =>
            request.cookies.set(name, value)
          );
          supabaseResponse = NextResponse.next({
            request: { headers: requestHeaders },
          });
          cookiesToSet.forEach(({ name, value, options }) =>
            supabaseResponse.cookies.set(name, value, options)
          );
        },
```
Note: Use `requestHeaders` (our cleaned + org-injected headers) instead of bare `request`.
</task>

<task id="4" name="Update middleware matcher for subdomain compatibility" type="code">
Review `web/middleware.ts` matcher config. The current matcher excludes `api/` routes. This is fine — API routes don't need subdomain headers (they read org_id from JWT).

Ensure the matcher does NOT exclude the login page or auth routes — they need to pass through middleware for subdomain branding:

The current pattern `/((?!_next/static|_next/image|favicon.ico|api/|pricing|...)(?!$).*)` already lets `/login` through (it's not in the exclusion list). Verify no changes needed.

If the matcher is correct, this task is a no-op verification. Document that matcher is compatible.
</task>

</tasks>

<verification>
- [ ] `extractSubdomain()` returns correct values for apex, www, subdomains, localhost, vercel.app
- [ ] All x-org-* headers are stripped at the top of updateSession() before any processing
- [ ] Service-role org lookup fetches org + branding in a single query
- [ ] Unknown subdomains redirect to apex domain root (not 404)
- [ ] Org headers are injected into the request for resolved subdomains
- [ ] Logo URL is correctly constructed from logo_path
- [ ] Existing auth flow (login redirect, role-based redirect, org_id check) is unchanged
- [ ] Middleware matcher allows /login through for subdomain branding
- [ ] No import of @supabase/supabase-js at module top level (dynamic import inside subdomain block to avoid bundling when not needed)
</verification>
