# Phase 7.5: Territory Management & Auto-Assignment - Research

**Researched:** 2026-02-16
**Domain:** Territory management, geospatial systems, workforce optimization
**Confidence:** HIGH

## Summary

Phase 7.5 implements a UK-wide territory management system with postcode-based coverage, intelligent auto-assignment algorithm, coverage gap detection, and hiring recommendations. The phase builds on existing infrastructure from Phase 1.5 (UK postcode seeding, Google Maps API, auto-assignment scoring) and Phase 5.5 (admin dashboards, territory queries).

**Current state:** The codebase already has significant territory infrastructure:
- UK postcode sector database seeded (Plan 01.5-04)
- Auto-assignment scoring algorithm implemented (Plan 01.5-03)
- Out-of-territory cost logic operational (Plan 06.5-05)
- Territory queries with utilization metrics (Plan 05.5-04)
- Coverage gap detection logic (rejection rate >10% threshold)

**Primary recommendation:** Focus on admin UI enhancements (drag-drop assignment, visual coverage map), real-time metrics aggregation (pg_cron scheduled jobs), and hiring trigger automation. Use dnd-kit for drag-and-drop, react-leaflet for map visualization, and TanStack Query patterns already established in the codebase.

## Standard Stack

The established libraries/tools for this domain:

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| @dnd-kit/core | Latest | Drag-and-drop for territory assignment | Modern, actively maintained replacement for react-beautiful-dnd (which is deprecated); supports grids, custom animations, accessibility |
| react-leaflet | 4.x | Interactive map with circle markers | SSR-compatible (with dynamic import), lightweight, pairs with Leaflet's proven choropleth capabilities |
| Leaflet | 1.9.x | Map rendering engine | Industry standard for web maps, extensive plugin ecosystem, open-source |
| Google Maps Distance Matrix API | Current | Travel time/distance calculations | Already integrated (Phase 1.5), official UK postcode support, handles traffic patterns |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| TanStack Query | 5.x | Real-time polling, optimistic updates | Already used throughout codebase, 60-second polling pattern established |
| pg_cron | Latest | Scheduled territory metrics aggregation | Native PostgreSQL scheduling, already used for payouts (Phase 6.5) |
| chroma-js | 2.x | Color scale generation for choropleth | Interpolates green/yellow/red utilization bands |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| dnd-kit | react-dnd | react-dnd is lower-level but more complex, dnd-kit offers better DX for this use case |
| react-leaflet | Mapbox GL JS | Mapbox has better performance but requires API key and billing, Leaflet is free and sufficient for admin dashboard |
| Circle markers | GeoJSON polygons | Polygons require OS Data Hub boundary data (external dependency), circles are simpler and load faster |

**Installation:**
```bash
pnpm add @dnd-kit/core @dnd-kit/sortable @dnd-kit/utilities
pnpm add react-leaflet leaflet
pnpm add chroma-js
pnpm add -D @types/leaflet
```

## Architecture Patterns

### Recommended Project Structure
```
web/
├── app/admin/territories/        # Territory admin page
│   ├── page.tsx                  # Server component with initial data
│   ├── territory-map.tsx         # Client component: Leaflet map with dynamic import
│   ├── assignment-panel.tsx      # Drag-drop medic assignment UI
│   └── coverage-alerts.tsx       # Gap detection + hiring triggers
├── lib/
│   ├── queries/admin/
│   │   └── territories.ts        # TanStack Query hooks (already exists)
│   └── territory/
│       ├── metrics.ts            # Utilization calculation logic
│       ├── hiring-triggers.ts    # Capacity planning rules
│       └── coverage-gaps.ts      # Rejection rate analysis
└── supabase/
    └── migrations/
        └── 024_territory_metrics_cron.sql  # pg_cron job for aggregation
```

### Pattern 1: Dynamic Map Import for SSR Compatibility
**What:** Leaflet requires browser APIs (window, document) unavailable during SSR
**When to use:** All Leaflet-based map components in Next.js
**Example:**
```typescript
// Source: Existing pattern from web/lib/queries/admin/territories.ts (D-05.5-04-003)
// territory-map.tsx
'use client';
import dynamic from 'next/dynamic';

const TerritoryMap = dynamic(() => import('./territory-map-component'), {
  ssr: false,
  loading: () => <div>Loading map...</div>
});

export default TerritoryMap;
```

### Pattern 2: Optimistic Updates for Drag-Drop Assignment
**What:** Update UI immediately when dragging medic to territory, rollback on failure
**When to use:** All mutations triggered by drag-and-drop
**Example:**
```typescript
// Source: TanStack Query optimistic updates pattern
// https://tanstack.com/query/latest/docs/react/guides/optimistic-updates
export function useAssignMedicToTerritory() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({ medicId, territoryId, role }) => {
      // API call to update territory assignment
    },
    onMutate: async (variables) => {
      // Cancel outgoing refetches
      await queryClient.cancelQueries({ queryKey: ['admin', 'territories'] });

      // Snapshot previous value
      const previousData = queryClient.getQueryData(['admin', 'territories']);

      // Optimistically update
      queryClient.setQueryData(['admin', 'territories'], (old) => {
        // Update territory with new medic assignment
      });

      return { previousData };
    },
    onError: (err, variables, context) => {
      // Rollback on error
      queryClient.setQueryData(['admin', 'territories'], context.previousData);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['admin', 'territories'] });
    },
  });
}
```

### Pattern 3: Scheduled Metrics Aggregation with pg_cron
**What:** Daily aggregation of territory metrics (utilization, rejection rate, fulfillment rate)
**When to use:** Heavy aggregations that don't need real-time precision
**Example:**
```sql
-- Source: Existing pattern from supabase/migrations/021_friday_payout_cron.sql
-- 024_territory_metrics_cron.sql
CREATE TABLE IF NOT EXISTS territory_metrics (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  postcode_sector TEXT NOT NULL,
  metric_date DATE NOT NULL DEFAULT CURRENT_DATE,
  total_bookings INT DEFAULT 0,
  confirmed_bookings INT DEFAULT 0,
  rejected_bookings INT DEFAULT 0,
  rejection_rate DECIMAL(5,2) DEFAULT 0,
  fulfillment_rate DECIMAL(5,2) DEFAULT 100,
  primary_medic_utilization DECIMAL(5,2) DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(postcode_sector, metric_date)
);

-- Schedule daily aggregation at 3 AM UTC
SELECT cron.schedule(
  'aggregate-territory-metrics',
  '0 3 * * *',
  $$
    INSERT INTO territory_metrics (postcode_sector, metric_date, ...)
    SELECT postcode_sector, CURRENT_DATE, ...
    FROM territories t
    LEFT JOIN bookings b ON ...
    WHERE b.shift_date >= CURRENT_DATE - INTERVAL '7 days'
    GROUP BY postcode_sector
    ON CONFLICT (postcode_sector, metric_date)
    DO UPDATE SET total_bookings = EXCLUDED.total_bookings, ...
  $$
);
```

### Pattern 4: Choropleth Color Mapping with Utilization Bands
**What:** Green (<50%), yellow (50-80%), red (>80%) color-coded territories
**When to use:** Visual coverage map display
**Example:**
```typescript
// Source: Existing pattern from web/lib/queries/admin/territories.ts (D-05.5-04-005)
import chroma from 'chroma-js';

export function getUtilizationColor(pct: number): string {
  if (pct < 50) return '#22c55e'; // green-400
  if (pct <= 80) return '#eab308'; // yellow-400
  return '#ef4444'; // red-400
}

// For smooth gradients (advanced)
const utilizationScale = chroma.scale(['#22c55e', '#eab308', '#ef4444'])
  .domain([0, 50, 100]);

export function getUtilizationGradient(pct: number): string {
  return utilizationScale(pct).hex();
}
```

### Anti-Patterns to Avoid
- **Don't hand-roll drag-and-drop:** Use dnd-kit instead of pointer events. Native pointer events lack accessibility, keyboard navigation, and cross-browser compatibility.
- **Don't fetch territories in a loop:** Use parallel queries with Promise.all (already implemented in territories.ts). N+1 queries will cause 10-100x slowdown with ~11,000 postcode sectors.
- **Don't cache Google Maps responses indefinitely:** Google ToS prohibits caching distance/time data beyond 30 days. Use 7-day TTL (already implemented in D-06.5-05-005).
- **Don't render full UK map on initial load:** Start with London/user's region and lazy-load other areas. Rendering 11,000+ markers will freeze the UI.

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Drag-and-drop territory assignment | Custom pointer event handlers | dnd-kit | Handles touch devices, keyboard navigation, screen readers, cancellation, multi-drag, and 20+ edge cases |
| UK postcode validation | Regex-only validation | Existing validation in codebase + Postcodes.io API | Postcodes have 6 format patterns, character restrictions (Q/V/X not in position 1), common typos (O vs 0, N vs M) |
| Choropleth color scales | Manual HSL interpolation | chroma-js | Handles perceptually uniform color spaces, accessibility contrast ratios, colorblind-safe palettes |
| Distance calculations | Haversine formula | Google Maps Distance Matrix API | Accounts for actual road routes, traffic patterns, one-way streets, road closures |
| Map rendering | Canvas/SVG from scratch | Leaflet/react-leaflet | Handles tile loading, zoom levels, projection transforms, pan/zoom gestures, mobile touch |
| Capacity planning thresholds | Hardcoded percentages | Industry-standard 75-85% utilization bands | Research shows 70-90% is optimal depending on industry, allows buffer for unplanned work |

**Key insight:** Territory management is a solved problem with mature libraries. Focus effort on business logic (hiring triggers, cost optimization) not reinventing geospatial infrastructure.

## Common Pitfalls

### Pitfall 1: SSR Crashes with Leaflet
**What goes wrong:** Leaflet accesses `window` and `document` during import, causing Next.js SSR to crash with "window is not defined"
**Why it happens:** Leaflet is a browser-only library not designed for Node.js environment
**How to avoid:** Use `dynamic import with ssr: false` (already documented in D-05.5-04-003)
**Warning signs:** Build fails with "ReferenceError: window is not defined" when importing map components

### Pitfall 2: Google Maps API Cost Explosion
**What goes wrong:** Distance Matrix API charges per element (origin x destination), costs spiral with large medic rosters
**Why it happens:** Auto-assignment queries N medics × M sites = N*M API calls per booking
**How to avoid:**
- Cache distance/time data with 7-day TTL (already implemented in D-06.5-05-005)
- Filter medics by postcode area before API call (e.g., only query Manchester medics for Manchester booking)
- Use territory-based pre-assignment to reduce search space
**Warning signs:** Google Cloud billing alerts, slow auto-assignment responses (>5 seconds)

### Pitfall 3: Stale Territory Metrics
**What goes wrong:** Admin sees outdated utilization percentages, assigns medics to overloaded territories
**Why it happens:** Real-time aggregation of 11,000+ territories with booking joins is too slow (>10 seconds)
**How to avoid:**
- Use pg_cron daily aggregation to materialized territory_metrics table (Pattern 3)
- Display "Last updated: X hours ago" timestamp on map
- Accept staleness for operational dashboard (3-24 hour delay is acceptable)
**Warning signs:** Slow map loading (>5 seconds), PostgreSQL query timeouts

### Pitfall 4: Invalid Postcode Assignments
**What goes wrong:** Admin assigns medic to non-existent postcode sector (e.g., "E99" doesn't exist)
**Why it happens:** UK postcode system has gaps in numbering (not all district numbers exist for all areas)
**How to avoid:**
- Validate against seeded territories table (only allow assignment to existing postcodes)
- Use autocomplete with existing postcode sectors
- Show "X sectors assigned" count to catch typos early
**Warning signs:** Bookings fail to match with "No medic in territory" despite assignments

### Pitfall 5: Rejection Rate False Positives
**What goes wrong:** Coverage gap alerts fire for territories with 1 booking and 1 rejection (100% rejection rate)
**Why it happens:** Percentage-only thresholds don't account for low sample sizes
**How to avoid:**
- Require minimum booking volume (e.g., >10 bookings in 3 weeks) before triggering alert
- Use confidence intervals: flag if rejection rate >10% AND total bookings >10
- Show absolute numbers alongside percentages: "5/50 rejected" vs "1/1 rejected"
**Warning signs:** Alert fatigue from rural low-volume territories

### Pitfall 6: Drag-and-Drop Accessibility Failures
**What goes wrong:** Keyboard-only users or screen reader users cannot assign medics to territories
**Why it happens:** Custom drag-and-drop implementations often forget non-mouse interaction
**How to avoid:**
- Use dnd-kit which includes keyboard navigation and ARIA attributes by default
- Test with keyboard only (Tab, Enter, Arrow keys)
- Provide alternative "Assign" button as fallback
**Warning signs:** WCAG audit failures, user complaints from accessibility team

## Code Examples

Verified patterns from official sources:

### Drag-and-Drop Territory Assignment
```typescript
// Source: dnd-kit documentation
// https://dndkit.com/
'use client';
import { DndContext, closestCenter, DragEndEvent } from '@dnd-kit/core';
import { SortableContext, useSortable } from '@dnd-kit/sortable';
import { CSS } from '@dnd-kit/utilities';

function MedicCard({ medic }: { medic: MedicWithMetrics }) {
  const { attributes, listeners, setNodeRef, transform, transition } = useSortable({
    id: medic.id,
  });

  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
  };

  return (
    <div ref={setNodeRef} style={style} {...attributes} {...listeners}>
      {medic.first_name} {medic.last_name} - {medic.utilization_pct}%
    </div>
  );
}

function TerritoryAssignmentPanel() {
  const { data: medics } = useMedics();
  const { data: territories } = useTerritories();
  const assignMedic = useAssignMedicToTerritory();

  function handleDragEnd(event: DragEndEvent) {
    const { active, over } = event;
    if (!over) return;

    const medicId = active.id as string;
    const territoryId = over.id as string;

    assignMedic.mutate({ medicId, territoryId, role: 'primary' });
  }

  return (
    <DndContext collisionDetection={closestCenter} onDragEnd={handleDragEnd}>
      <div className="flex gap-4">
        <div className="w-1/3">
          <h3>Available Medics</h3>
          <SortableContext items={medics?.map(m => m.id) || []}>
            {medics?.map(medic => <MedicCard key={medic.id} medic={medic} />)}
          </SortableContext>
        </div>
        <div className="w-2/3">
          <h3>Territories</h3>
          {/* Territory drop zones */}
        </div>
      </div>
    </DndContext>
  );
}
```

### React-Leaflet Choropleth Map with Circle Markers
```typescript
// Source: Leaflet documentation + existing pattern from territories.ts
// https://leafletjs.com/examples/choropleth/
'use client';
import { MapContainer, TileLayer, CircleMarker, Popup } from 'react-leaflet';
import { getUtilizationColor } from '@/lib/queries/admin/territories';
import 'leaflet/dist/leaflet.css';

export default function TerritoryMap({ territories }: { territories: TerritoryWithMetrics[] }) {
  return (
    <MapContainer
      center={[51.505, -0.09]} // London center
      zoom={10}
      style={{ height: '600px', width: '100%' }}
    >
      <TileLayer
        attribution='&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>'
        url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
      />
      {territories.map(territory => (
        <CircleMarker
          key={territory.id}
          center={[territory.lat, territory.lng]}
          radius={8}
          pathOptions={{
            fillColor: getUtilizationColor(territory.utilization_pct),
            fillOpacity: 0.7,
            color: '#fff',
            weight: 2,
          }}
        >
          <Popup>
            <div>
              <strong>{territory.postcode_sector}</strong>
              <p>Utilization: {territory.utilization_pct}%</p>
              <p>Primary: {territory.primary_medic_name || 'Unassigned'}</p>
              <p>Bookings: {territory.recent_metrics.total_bookings}</p>
            </div>
          </Popup>
        </CircleMarker>
      ))}
    </MapContainer>
  );
}
```

### Hiring Trigger Detection
```typescript
// Source: Industry capacity planning thresholds
// https://www.runn.io/blog/capacity-planning
export interface HiringTrigger {
  territory_id: string;
  postcode_sector: string;
  region: string;
  trigger_type: 'high_utilization' | 'low_fulfillment' | 'coverage_gap';
  severity: 'info' | 'warning' | 'critical';
  message: string;
  metric_value: number;
  threshold: number;
}

export function detectHiringTriggers(territories: TerritoryWithMetrics[]): HiringTrigger[] {
  const triggers: HiringTrigger[] = [];

  territories.forEach(territory => {
    const { utilization_pct, recent_metrics } = territory;

    // High utilization: >80% for 3+ weeks (critical), >70% (warning)
    if (utilization_pct > 80) {
      triggers.push({
        territory_id: territory.id,
        postcode_sector: territory.postcode_sector,
        region: territory.region,
        trigger_type: 'high_utilization',
        severity: 'critical',
        message: `Hire medic in ${territory.region} (${territory.postcode_sector}, ${utilization_pct}% utilization)`,
        metric_value: utilization_pct,
        threshold: 80,
      });
    } else if (utilization_pct > 70) {
      triggers.push({
        territory_id: territory.id,
        postcode_sector: territory.postcode_sector,
        region: territory.region,
        trigger_type: 'high_utilization',
        severity: 'warning',
        message: `Monitor ${territory.postcode_sector}: approaching capacity (${utilization_pct}%)`,
        metric_value: utilization_pct,
        threshold: 70,
      });
    }

    // Low fulfillment rate: <90% (critical), <95% (warning)
    const fulfillment = recent_metrics.fulfillment_rate;
    if (fulfillment < 90 && recent_metrics.total_bookings > 10) {
      triggers.push({
        territory_id: territory.id,
        postcode_sector: territory.postcode_sector,
        region: territory.region,
        trigger_type: 'low_fulfillment',
        severity: 'critical',
        message: `Hire medic in ${territory.region}: only ${fulfillment.toFixed(1)}% bookings fulfilled`,
        metric_value: fulfillment,
        threshold: 90,
      });
    }

    // Coverage gap: rejection rate >10%
    const rejection_rate = recent_metrics.rejection_rate;
    if (rejection_rate > 10 && recent_metrics.total_bookings > 10) {
      const severity = rejection_rate > 25 ? 'critical' : 'warning';
      triggers.push({
        territory_id: territory.id,
        postcode_sector: territory.postcode_sector,
        region: territory.region,
        trigger_type: 'coverage_gap',
        severity,
        message: `Coverage gap in ${territory.postcode_sector}: ${rejection_rate.toFixed(1)}% rejection rate`,
        metric_value: rejection_rate,
        threshold: 10,
      });
    }
  });

  return triggers;
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| react-beautiful-dnd | dnd-kit | 2023 (react-beautiful-dnd deprecated) | dnd-kit is actively maintained, supports more use cases (grids, not just lists) |
| Manual distance calculations (Haversine) | Google Maps Distance Matrix API | Ongoing industry standard | Accounts for actual road routes, traffic, one-way streets vs straight-line distance |
| Real-time territory aggregation | Scheduled pg_cron aggregation | 2024+ (pg_cron maturity) | Materialized metrics tables prevent query timeouts, 3-24hr staleness acceptable for operational dashboards |
| 100% utilization targets | 75-85% optimal utilization | 2025-2026 research | Allows buffer for unplanned work, prevents burnout, industry consensus |
| GeoJSON polygon boundaries | Circle markers with centroids | Simplification | Polygons require OS Data Hub API (external dependency), circles load faster and suffice for admin overview |

**Deprecated/outdated:**
- **react-beautiful-dnd:** No longer maintained as of 2023. Use dnd-kit or hello-pangea/dnd (community fork).
- **Synchronous Google Maps API calls in booking flow:** Use async Edge Function invocation to prevent blocking user experience.
- **Hardcoded 100% utilization targets:** Research shows 70-90% is healthier depending on industry, with 75-85% as optimal.

## Open Questions

Things that couldn't be fully resolved:

1. **UK Postcode Boundary Data Licensing**
   - What we know: OS Data Hub provides official boundary polygons for postcode sectors
   - What's unclear: Licensing restrictions for commercial use, cost implications
   - Recommendation: Start with circle markers (free, no licensing), add polygons only if customer feedback demands it. Existing code uses circle markers per D-05.5-04-002.

2. **Google Maps API Cost Thresholds**
   - What we know: Distance Matrix API charges per element (origin × destination), caching saves 90%+ of costs
   - What's unclear: Exact cost at scale (1000+ bookings/day with 50+ medics)
   - Recommendation: Monitor usage in Google Cloud Console, set billing alerts at £50/£100/£200 thresholds, implement distance pre-filtering (only query medics within 50 miles of booking site before API call).

3. **Optimal Territory Size**
   - What we know: Currently using postcode AREA+DISTRICT level (outward code) per D-01.5-04-001
   - What's unclear: Whether full sector granularity (11,232 sectors) provides better matching than district level (~2,900 districts)
   - Recommendation: Start with district level as implemented, add sector-level refinement only if coverage gaps persist in high-density areas (London, Manchester, Birmingham).

4. **Hiring Trigger Automation**
   - What we know: Industry standard is 75-85% utilization optimal, >80% triggers hiring discussion
   - What's unclear: How to automate hiring workflow (create job posting? notify HR? trigger recruiter platform API?)
   - Recommendation: Phase 7.5 surfaces alerts only. Automation of hiring workflow should be separate epic (Phase 8+) after validating alert thresholds with real usage data.

## Sources

### Primary (HIGH confidence)
- [Google Maps Distance Matrix API Best Practices](https://developers.google.com/maps/documentation/distance-matrix/web-service-best-practices) - Official API documentation
- [dnd-kit Official Documentation](https://dndkit.com/) - Modern drag-and-drop toolkit
- [TanStack Query Optimistic Updates](https://tanstack.com/query/latest/docs/react/guides/optimistic-updates) - Official query caching patterns
- [Leaflet Choropleth Tutorial](https://leafletjs.com/examples/choropleth/) - Official interactive map example
- [PostgreSQL pg_cron GitHub](https://github.com/citusdata/pg_cron) - Official scheduled jobs extension

### Secondary (MEDIUM confidence)
- [UK Postcode Format Guide](https://ideal-postcodes.co.uk/guides/uk-postcode-format) - Authoritative UK postcode structure
- [Capacity Planning Guide 2026](https://www.runn.io/blog/capacity-planning) - Industry utilization thresholds
- [Workforce Coverage Gap Detection](https://www.covalentnetworks.com/post/managing-workforce-coverage-and-filling-gaps) - Alerting patterns
- [Top 5 Drag-and-Drop Libraries for React in 2026](https://puckeditor.com/blog/top-5-drag-and-drop-libraries-for-react) - Library comparison
- [npm trends: dnd-kit vs react-beautiful-dnd vs react-dnd](https://npmtrends.com/@dnd-kit/core-vs-react-beautiful-dnd-vs-react-dnd) - Download statistics and popularity

### Tertiary (LOW confidence)
- [React Leaflet Performance Issues](https://tmsvr.com/react-leaflet-map-performance-issues/) - Community blog post on optimization
- [Alert Coverage Analysis](https://oneuptime.com/blog/post/2026-01-30-alert-coverage-analysis/view) - General alerting patterns
- [UK Postcode Sector Maps](https://www.gbmaps.com/postcodemaps/postcodesectormaps.htm) - Commercial mapping service overview

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - All libraries are industry-standard with official documentation and active maintenance
- Architecture: HIGH - Patterns verified against existing codebase (Phase 1.5, 5.5) and official library documentation
- Pitfalls: HIGH - Based on official documentation warnings and existing project decisions (D-05.5-04-003, D-06.5-05-005)

**Research date:** 2026-02-16
**Valid until:** 2026-05-16 (90 days - stable ecosystem, mature libraries)
