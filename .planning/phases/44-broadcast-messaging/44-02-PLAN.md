---
phase: 44-broadcast-messaging
plan: 02
type: execute
wave: 2
depends_on: ["44-01"]
files_modified:
  - web/app/api/messages/broadcast/read/route.ts
  - web/app/api/messages/broadcast/[messageId]/recipients/route.ts
  - web/lib/queries/comms.ts
  - web/lib/queries/comms.hooks.ts
  - web/app/(dashboard)/messages/components/BroadcastReadSummary.tsx
  - web/app/(dashboard)/messages/components/BroadcastReadDrilldown.tsx
  - web/app/(dashboard)/messages/components/MessageItem.tsx
  - web/app/(dashboard)/messages/components/MessageThread.tsx
autonomous: true

must_haves:
  truths:
    - "When a medic opens the broadcast conversation, their message_recipients rows are updated with read_at timestamps AND conversation_read_status is upserted (for unread badge)"
    - "Admin sees 'Read by X of Y' below each broadcast message in the thread"
    - "Admin can click the read count to open a drilldown sheet listing every medic with their read/unread status"
    - "Unread badge on the broadcast conversation row accurately reflects unread broadcast count for medics"
  artifacts:
    - path: "web/app/api/messages/broadcast/read/route.ts"
      provides: "PATCH endpoint to mark broadcast messages as read"
      exports: ["PATCH"]
    - path: "web/app/api/messages/broadcast/[messageId]/recipients/route.ts"
      provides: "GET endpoint for broadcast read tracking summary and per-medic detail"
      exports: ["GET"]
    - path: "web/app/(dashboard)/messages/components/BroadcastReadSummary.tsx"
      provides: "Inline read count display below each broadcast message"
      min_lines: 20
    - path: "web/app/(dashboard)/messages/components/BroadcastReadDrilldown.tsx"
      provides: "Sheet drilldown with per-medic read/unread status"
      min_lines: 40
  key_links:
    - from: "web/app/(dashboard)/messages/components/MessageThread.tsx"
      to: "/api/messages/broadcast/read"
      via: "PATCH on mount when conversation type is broadcast and user is medic"
      pattern: "api/messages/broadcast/read"
    - from: "web/app/(dashboard)/messages/components/BroadcastReadSummary.tsx"
      to: "/api/messages/broadcast/[messageId]/recipients"
      via: "useBroadcastReadSummary hook fetching read counts"
      pattern: "broadcast.*recipients"
    - from: "web/app/(dashboard)/messages/components/BroadcastReadDrilldown.tsx"
      to: "/api/messages/broadcast/[messageId]/recipients"
      via: "TanStack Query fetch when sheet opens"
      pattern: "broadcast.*recipients"
---

<objective>
Build the broadcast read tracking system: mark-as-read API for medics, read summary API for admins, inline "Read by X of Y" display on each broadcast message, and a drilldown sheet showing per-medic read/unread status.

Purpose: This completes Phase 44 by giving admins visibility into broadcast reach. The admin can see how many medics have read each broadcast and who specifically has/hasn't read it.

Output: Working read tracking flow from medic opening broadcast to admin seeing read counts with drilldown detail.
</objective>

<execution_context>
@/Users/sabineresoagli/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sabineresoagli/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/44-broadcast-messaging/44-CONTEXT.md
@.planning/phases/44-broadcast-messaging/44-RESEARCH.md
@.planning/phases/44-broadcast-messaging/44-01-SUMMARY.md

Key source files (modified by Plan 01):
@web/types/comms.types.ts
@web/lib/queries/comms.ts
@web/lib/queries/comms.hooks.ts
@web/app/api/messages/broadcast/route.ts
@web/app/api/messages/conversations/[id]/read/route.ts
@web/app/(dashboard)/messages/components/MessageItem.tsx
@web/app/(dashboard)/messages/components/MessageThread.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Broadcast read and recipients API routes</name>
  <files>
    web/app/api/messages/broadcast/read/route.ts
    web/app/api/messages/broadcast/[messageId]/recipients/route.ts
  </files>
  <action>
    **1. Create `web/app/api/messages/broadcast/read/route.ts` (PATCH handler):**
    - Follow the same pattern as `/api/messages/conversations/[id]/read/route.ts`
    - Use `requireOrgId()` and `createClient()` from server utilities
    - Set `export const dynamic = 'force-dynamic'`
    - Auth check: verify user exists, get orgId
    - Parse body: `{ conversationId: string }` -- the broadcast conversation ID
    - Verify the conversation exists, belongs to user's org, and has `type = 'broadcast'`
    - Update ALL unread `message_recipients` rows for this user in this org:
      ```typescript
      // Get all message IDs in this broadcast conversation
      const { data: messages } = await supabase
        .from('messages')
        .select('id')
        .eq('conversation_id', conversationId)
        .is('deleted_at', null);

      if (messages && messages.length > 0) {
        const messageIds = messages.map(m => m.id);
        await supabase
          .from('message_recipients')
          .update({ read_at: new Date().toISOString() })
          .eq('recipient_id', user.id)
          .eq('org_id', orgId)
          .in('message_id', messageIds)
          .is('read_at', null);
      }
      ```
    - ALSO upsert `conversation_read_status` for the unread badge calculation (same pattern as existing read route):
      ```typescript
      await supabase
        .from('conversation_read_status')
        .upsert(
          {
            user_id: user.id,
            conversation_id: conversationId,
            org_id: orgId,
            last_read_at: new Date().toISOString(),
          },
          { onConflict: 'user_id,conversation_id' }
        );
      ```
    - Return `{ success: true }` with status 200
    - Non-fatal error handling: if message_recipients update fails, still try conversation_read_status (and vice versa)

    **2. Create `web/app/api/messages/broadcast/[messageId]/recipients/route.ts` (GET handler):**
    - Use `requireOrgId()` and `createClient()` from server utilities
    - Set `export const dynamic = 'force-dynamic'`
    - Auth check: verify user exists, get orgId, verify role is `org_admin` (return 403 if not)
    - Extract `messageId` from params (use `{ params }: { params: Promise<{ messageId: string }> }` pattern)
    - Verify the message exists and belongs to user's org
    - Fetch all `message_recipients` for this message:
      ```typescript
      const { data: recipients } = await supabase
        .from('message_recipients')
        .select('recipient_id, read_at, delivered_at')
        .eq('message_id', messageId)
        .eq('org_id', orgId);
      ```
    - Fetch medic names for all recipient_ids:
      ```typescript
      const recipientIds = recipients.map(r => r.recipient_id);
      const { data: medics } = await supabase
        .from('medics')
        .select('user_id, first_name, last_name')
        .in('user_id', recipientIds);
      ```
    - Build and return response matching `BroadcastReadSummary` + `BroadcastRecipientDetail[]`:
      ```typescript
      const totalRecipients = recipients.length;
      const readCount = recipients.filter(r => r.read_at !== null).length;
      const details = recipients.map(r => {
        const medic = medics?.find(m => m.user_id === r.recipient_id);
        return {
          recipient_id: r.recipient_id,
          name: medic ? `${medic.first_name} ${medic.last_name}` : 'Unknown',
          read_at: r.read_at,
          status: r.read_at ? 'read' : 'unread',
        };
      });
      // Sort: read medics first (by read_at DESC), then unread medics alphabetically
      details.sort((a, b) => {
        if (a.status === 'read' && b.status === 'unread') return -1;
        if (a.status === 'unread' && b.status === 'read') return 1;
        if (a.status === 'read' && b.status === 'read') {
          return new Date(b.read_at!).getTime() - new Date(a.read_at!).getTime();
        }
        return a.name.localeCompare(b.name);
      });
      ```
    - Return `{ messageId, totalRecipients, readCount, recipients: details }` with status 200
  </action>
  <verify>
    - `pnpm --filter web build` compiles without TypeScript errors
    - File exists at `web/app/api/messages/broadcast/read/route.ts` with PATCH export
    - File exists at `web/app/api/messages/broadcast/[messageId]/recipients/route.ts` with GET export
    - Both files import `requireOrgId` and `createClient`
  </verify>
  <done>
    - PATCH /api/messages/broadcast/read marks all unread message_recipients rows as read for the current user in the broadcast conversation AND upserts conversation_read_status
    - GET /api/messages/broadcast/{messageId}/recipients returns totalRecipients, readCount, and per-medic detail with name and read status (admin only)
  </done>
</task>

<task type="auto">
  <name>Task 2: Read summary UI components + thread integration</name>
  <files>
    web/app/(dashboard)/messages/components/BroadcastReadSummary.tsx
    web/app/(dashboard)/messages/components/BroadcastReadDrilldown.tsx
    web/app/(dashboard)/messages/components/MessageItem.tsx
    web/app/(dashboard)/messages/components/MessageThread.tsx
    web/lib/queries/comms.hooks.ts
  </files>
  <action>
    **1. Add `useBroadcastReadSummary` hook to `web/lib/queries/comms.hooks.ts`:**
    - Add a new hook below the existing hooks:
      ```typescript
      /**
       * Fetch broadcast read summary for multiple message IDs in a single batch.
       * Used by admin to see "X of Y read" on each broadcast message.
       * Returns a Map of messageId -> { totalRecipients, readCount }.
       */
      export function useBroadcastReadSummaries(messageIds: string[], enabled: boolean) {
        return useQuery({
          queryKey: ['broadcast-read-summaries', ...messageIds],
          queryFn: async () => {
            if (messageIds.length === 0) return new Map();
            // Batch: fetch all recipients for all messages in one query
            const supabase = createClient();
            const { data } = await supabase
              .from('message_recipients')
              .select('message_id, read_at')
              .in('message_id', messageIds);

            // Aggregate per message
            const summaryMap = new Map<string, { totalRecipients: number; readCount: number }>();
            if (data) {
              data.forEach((r) => {
                const existing = summaryMap.get(r.message_id) || { totalRecipients: 0, readCount: 0 };
                existing.totalRecipients++;
                if (r.read_at) existing.readCount++;
                summaryMap.set(r.message_id, existing);
              });
            }
            return summaryMap;
          },
          enabled,
          staleTime: 30_000, // 30s stale time -- admin can refresh to see updates
        });
      }
      ```
    - Import `createClient` from `@/lib/supabase/client` (already imported at top of file)

    **2. Create `web/app/(dashboard)/messages/components/BroadcastReadSummary.tsx`:**
    - 'use client' component
    - Props: `{ messageId: string; totalRecipients: number; readCount: number; onDrilldown: () => void }`
    - Renders a clickable inline element below the message:
      ```tsx
      <button
        onClick={onDrilldown}
        className="flex items-center gap-1 text-xs text-muted-foreground hover:text-foreground transition-colors mt-1"
      >
        <Eye className="h-3 w-3" />
        <span>Read by {readCount} of {totalRecipients}</span>
      </button>
      ```
    - Import `Eye` from `lucide-react`
    - If totalRecipients is 0, return null

    **3. Create `web/app/(dashboard)/messages/components/BroadcastReadDrilldown.tsx`:**
    - 'use client' component
    - Props: `{ messageId: string; open: boolean; onClose: () => void }`
    - Uses shadcn/ui `Sheet` with `SheetContent`, `SheetHeader`, `SheetTitle` (import from `@/components/ui/sheet`)
    - Uses TanStack Query to fetch recipient details when sheet is open:
      ```typescript
      const { data, isLoading } = useQuery({
        queryKey: ['broadcast-recipients', messageId],
        queryFn: async () => {
          const res = await fetch(`/api/messages/broadcast/${messageId}/recipients`);
          if (!res.ok) throw new Error('Failed to fetch recipients');
          return res.json();
        },
        enabled: open,
      });
      ```
    - Sheet header shows: "Read by {readCount} of {totalRecipients}"
    - Sheet content: list of medic rows, each with:
      - Medic name (text-sm font-medium)
      - Badge: green "Read" with Check icon if read_at exists, muted "Unread" with Clock icon if null
      - If read_at exists, show relative time below the badge in text-[10px] text-muted-foreground
    - Loading state: show `Loader2` spinner centered
    - Import: `Check, Clock, Loader2` from `lucide-react`, `Badge` from `@/components/ui/badge`
    - Import `useQuery` from `@tanstack/react-query`

    **4. Modify `web/app/(dashboard)/messages/components/MessageItem.tsx`:**
    - Add optional prop: `readSummary?: { totalRecipients: number; readCount: number } | null`
    - Add optional prop: `onReadDrilldown?: () => void`
    - After the timestamp `<span>`, conditionally render `BroadcastReadSummary`:
      ```tsx
      {readSummary && onReadDrilldown && (
        <BroadcastReadSummary
          messageId={message.id}
          totalRecipients={readSummary.totalRecipients}
          readCount={readSummary.readCount}
          onDrilldown={onReadDrilldown}
        />
      )}
      ```
    - Import `BroadcastReadSummary` from `./BroadcastReadSummary`

    **5. Modify `web/app/(dashboard)/messages/components/MessageThread.tsx`:**
    - Add two things: (a) broadcast mark-as-read on mount, (b) read summary display for admin

    **(a) Mark-as-read for broadcast conversations:**
    - In the existing `useEffect` that calls mark-as-read on mount, add a branch for broadcast:
      ```typescript
      useEffect(() => {
        if (conversationType === 'broadcast' && userRole === 'medic') {
          // Mark all broadcast messages as read via broadcast-specific endpoint
          fetch('/api/messages/broadcast/read', {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ conversationId }),
          })
            .then(() => {
              queryClient.invalidateQueries({ queryKey: ['conversations'] });
            })
            .catch(console.error);
        } else {
          // Existing direct message mark-as-read
          fetch(`/api/messages/conversations/${conversationId}/read`, {
            method: 'PATCH',
          })
            .then(() => {
              queryClient.invalidateQueries({ queryKey: ['conversations'] });
            })
            .catch(console.error);
        }
      }, [conversationId, conversationType, userRole, queryClient]);
      ```

    **(b) Read summary for admin viewing broadcast:**
    - Import `useBroadcastReadSummaries` from `@/lib/queries/comms.hooks`
    - Import `BroadcastReadDrilldown` from `./BroadcastReadDrilldown`
    - Add state for drilldown: `const [drilldownMessageId, setDrilldownMessageId] = useState<string | null>(null)`
    - Compute whether to show read summaries: `const showReadSummaries = conversationType === 'broadcast' && userRole === 'org_admin'`
    - Get all message IDs: `const messageIds = messages?.map(m => m.id) ?? []`
    - Call the hook: `const { data: readSummaryMap } = useBroadcastReadSummaries(messageIds, showReadSummaries)`
    - In the message rendering loop, pass read summary data to MessageItem:
      ```tsx
      {messages?.map((message) => (
        <MessageItem
          key={message.id}
          message={message}
          isOwnMessage={message.sender_id === currentUserId}
          readSummary={showReadSummaries ? readSummaryMap?.get(message.id) ?? null : undefined}
          onReadDrilldown={showReadSummaries ? () => setDrilldownMessageId(message.id) : undefined}
        />
      ))}
      ```
    - After the messages end ref, render the drilldown sheet:
      ```tsx
      {drilldownMessageId && (
        <BroadcastReadDrilldown
          messageId={drilldownMessageId}
          open={!!drilldownMessageId}
          onClose={() => setDrilldownMessageId(null)}
        />
      )}
      ```
    - Add `useState` to the import (already imported)
  </action>
  <verify>
    - `pnpm --filter web build` compiles without TypeScript errors
    - `grep "BroadcastReadSummary" web/app/\(dashboard\)/messages/components/MessageItem.tsx` shows integration
    - `grep "BroadcastReadDrilldown" web/app/\(dashboard\)/messages/components/MessageThread.tsx` shows drilldown rendering
    - `grep "useBroadcastReadSummaries" web/lib/queries/comms.hooks.ts` shows hook definition
    - `grep "broadcast/read" web/app/\(dashboard\)/messages/components/MessageThread.tsx` shows mark-as-read call
  </verify>
  <done>
    - PATCH /api/messages/broadcast/read marks all unread message_recipients as read for the medic AND updates conversation_read_status
    - GET /api/messages/broadcast/{messageId}/recipients returns read summary with per-medic detail (admin only)
    - BroadcastReadSummary shows "Read by X of Y" inline below each broadcast message (admin view only)
    - BroadcastReadDrilldown Sheet shows per-medic read/unread status with names, badges, and timestamps
    - MessageThread calls broadcast mark-as-read on mount for medics, and displays read summaries for admins
    - Read summaries fetched in batch (single query for all visible messages) to avoid N+1
    - Unread badge on broadcast conversation updates correctly after medic opens the channel
  </done>
</task>

</tasks>

<verification>
1. As medic: open broadcast conversation -- unread badge disappears, message_recipients rows get read_at timestamps
2. As admin: open broadcast conversation -- each message shows "Read by X of Y" below the timestamp
3. As admin: click "Read by X of Y" -- Sheet opens showing list of medics with Read/Unread badges
4. Read medics sorted first (by most recent read_at), unread medics sorted alphabetically
5. As admin: after medic reads broadcast (in another tab), refresh broadcast thread -- read count updates
6. `pnpm --filter web build` passes with no TypeScript errors
</verification>

<success_criteria>
- Medic opening broadcast conversation marks all messages as read (message_recipients.read_at updated + conversation_read_status upserted)
- Admin sees "Read by X of Y" below each broadcast message via batched query
- Admin can drill down into per-medic read status via Sheet component
- Drilldown shows medic name + read/unread badge + read timestamp
- Unread badge on broadcast conversation accurately reflects unread count for medics
- No N+1 queries: read summaries fetched in single batch for all visible messages
</success_criteria>

<output>
After completion, create `.planning/phases/44-broadcast-messaging/44-02-SUMMARY.md`
</output>
