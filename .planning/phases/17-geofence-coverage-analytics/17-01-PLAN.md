---
phase: 17-geofence-coverage-analytics
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - web/lib/queries/admin/geofences.ts
  - web/app/admin/geofences/page.tsx
autonomous: true

must_haves:
  truths:
    - "Admin navigates to /admin/geofences and sees a coverage stat card above the geofence list"
    - "Stat card shows 'X of Y active sites covered (Z%)' with correct numbers"
    - "When 0 active bookings exist, card shows 'No active bookings to cover'"
    - "When 0 geofences cover bookings, card shows '0 of Y active sites covered (0%)'"
    - "Stat refreshes every 60 seconds via polling"
  artifacts:
    - path: "web/lib/queries/admin/geofences.ts"
      provides: "TanStack Query hook for geofence coverage stats"
      exports: ["GeofenceCoverage", "fetchGeofenceCoverage", "useGeofenceCoverage"]
    - path: "web/app/admin/geofences/page.tsx"
      provides: "GeofenceCoverageCard component rendered above geofence list"
      contains: "GeofenceCoverageCard"
  key_links:
    - from: "web/app/admin/geofences/page.tsx"
      to: "web/lib/queries/admin/geofences.ts"
      via: "import { useGeofenceCoverage }"
      pattern: "useGeofenceCoverage"
    - from: "web/lib/queries/admin/geofences.ts"
      to: "supabase.from('bookings')"
      via: "parallel Supabase queries"
      pattern: "from\\('bookings'\\)"
    - from: "web/lib/queries/admin/geofences.ts"
      to: "supabase.from('geofences')"
      via: "parallel Supabase queries"
      pattern: "from\\('geofences'\\)"
---

<objective>
Add a geofence coverage analytics stat card to the admin geofences page showing what percentage of active booking sites are covered by at least one geofence.

Purpose: Closes GAP-3 from v1.1-MILESTONE-AUDIT.md — the Phase 13 requirement "Geofence coverage analytics" that was deferred during implementation.

Output: One new query hook file + one updated page file. Admin sees "X of Y active sites covered (Z%)" at the top of /admin/geofences.
</objective>

<execution_context>
@/Users/sabineresoagli/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sabineresoagli/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@web/lib/queries/admin/analytics.ts (pattern reference for TanStack Query hooks)
@web/app/admin/geofences/page.tsx (page to modify)
@web/contexts/org-context.tsx (useRequireOrg hook)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TanStack Query hook for geofence coverage</name>
  <files>web/lib/queries/admin/geofences.ts</files>
  <action>
Create a new file `web/lib/queries/admin/geofences.ts` following the exact pattern from `analytics.ts`:

1. Add `'use client'` directive at top.

2. Import `useQuery` from `@tanstack/react-query`, `createClient` from `@/lib/supabase/client`, `SupabaseClient` type from `@supabase/supabase-js`, and `useRequireOrg` from `@/contexts/org-context`.

3. Export interface `GeofenceCoverage`:
   ```typescript
   export interface GeofenceCoverage {
     covered: number;    // count of active bookings that have at least one active geofence
     total: number;      // count of all active/upcoming bookings
     percentage: number; // Math.round((covered / total) * 100), or 0 if total is 0
   }
   ```

4. Export async function `fetchGeofenceCoverage(supabase: SupabaseClient, orgId: string): Promise<GeofenceCoverage>`:
   - Compute `today` as `new Date().toISOString().split('T')[0]`
   - Run two parallel Supabase queries via `Promise.all`:
     - **Active bookings query:** `supabase.from('bookings').select('id').eq('org_id', orgId).in('status', ['confirmed', 'in_progress']).gte('shift_date', today)`
     - **Active geofences with booking_id query:** `supabase.from('geofences').select('booking_id').eq('org_id', orgId).eq('is_active', true).not('booking_id', 'is', null)`
   - IMPORTANT: The `.not('booking_id', 'is', null)` filter excludes org-level geofences (booking_id was made nullable in migration 119).
   - Build a `Set<string>` of active booking IDs from the bookings result.
   - Build a `Set<string>` of covered booking IDs by filtering geofence `booking_id` values that exist in the active bookings Set. This avoids double-counting bookings with multiple geofences.
   - Return `{ covered: coveredIds.size, total: activeBookingIds.size, percentage }` where percentage is `total === 0 ? 0 : Math.round((covered / total) * 100)`.

5. Export function `useGeofenceCoverage()`:
   ```typescript
   export function useGeofenceCoverage() {
     const supabase = createClient();
     const orgId = useRequireOrg();
     return useQuery({
       queryKey: ['admin', 'geofence-coverage', orgId],
       queryFn: () => fetchGeofenceCoverage(supabase, orgId),
       refetchInterval: 60_000, // 60-second polling per success criteria
     });
   }
   ```

Add a file-level JSDoc comment explaining the coverage calculation and the two queries.
  </action>
  <verify>
Run `npx tsc --noEmit --project web/tsconfig.json 2>&1 | grep geofences` — should return zero type errors for the new file. If the project has many pre-existing errors, verify the new file specifically by checking the output does not contain `web/lib/queries/admin/geofences.ts`.
  </verify>
  <done>
`web/lib/queries/admin/geofences.ts` exists, exports `GeofenceCoverage` interface, `fetchGeofenceCoverage` function, and `useGeofenceCoverage` hook. The hook uses 60-second polling, filters org-level geofences with `.not('booking_id', 'is', null)`, and uses Set intersection to avoid double-counting.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add GeofenceCoverageCard to admin geofences page</name>
  <files>web/app/admin/geofences/page.tsx</files>
  <action>
Modify `web/app/admin/geofences/page.tsx` to add a coverage stat card at the top of the page. The existing page uses raw useState/useEffect for data fetching — do NOT change the existing geofence list logic. This is purely additive.

1. Add imports at the top:
   - `import { Shield } from 'lucide-react';` (add Shield to existing lucide-react import or as new import)
   - `import { useGeofenceCoverage } from '@/lib/queries/admin/geofences';`

2. Create a `GeofenceCoverageCard` component INSIDE the same file (not a separate file — keeps it simple for a single-use component):

```tsx
function GeofenceCoverageCard() {
  const { data, isLoading } = useGeofenceCoverage();

  if (isLoading) {
    return <Skeleton className="h-20 w-full rounded-2xl" />;
  }

  let label: string;
  if (!data || data.total === 0) {
    label = 'No active bookings to cover';
  } else if (data.covered === 0) {
    label = `0 of ${data.total} active sites covered (0%)`;
  } else {
    label = `${data.covered} of ${data.total} active sites covered (${data.percentage}%)`;
  }

  const isFullCoverage = data && data.total > 0 && data.covered === data.total;
  const isNoCoverage = !data || data.total === 0 || data.covered === 0;

  return (
    <div className={`flex items-center gap-4 px-6 py-4 rounded-2xl border ${
      isFullCoverage
        ? 'bg-green-900/20 border-green-700/50'
        : isNoCoverage
          ? 'bg-gray-800/50 border-gray-700/50'
          : 'bg-blue-900/20 border-blue-700/50'
    }`}>
      <div className={`w-10 h-10 rounded-xl flex items-center justify-center flex-shrink-0 ${
        isFullCoverage
          ? 'bg-green-900/50'
          : isNoCoverage
            ? 'bg-gray-900/50'
            : 'bg-blue-900/50'
      }`}>
        <Shield className={`w-5 h-5 ${
          isFullCoverage
            ? 'text-green-400'
            : isNoCoverage
              ? 'text-gray-400'
              : 'text-blue-400'
        }`} />
      </div>
      <div>
        <p className="text-xs font-semibold uppercase tracking-wider text-gray-400">
          Geofence Coverage
        </p>
        <p className="text-white font-medium">{label}</p>
      </div>
    </div>
  );
}
```

Color logic notes:
- Full coverage (covered === total && total > 0): green — everything is good.
- Partial coverage (0 < covered < total): blue — progress but gaps remain.
- No coverage or no bookings: neutral gray — informational, not alarming. Do NOT use red for "no active bookings" as that is not a failure state.

3. In the `GeofencesPage` component's return JSX, insert `<GeofenceCoverageCard />` immediately after the header div (the one with "Geofences" h1 and "Add Geofence" button) and before the form/list section. Place it as a direct child of the outer `<div className="p-6 space-y-6">`:

```tsx
{/* Coverage stat card */}
<GeofenceCoverageCard />
```

This goes right after the closing `</div>` of the header flex container (around line 202 in current file) and before the `{/* Add / Edit Form */}` comment.

4. Do NOT modify any existing state, effects, handlers, or the geofence list rendering. The `Skeleton` import already exists in the file — reuse it.
  </action>
  <verify>
Run `pnpm --dir web build 2>&1 | tail -20` — build should succeed without errors.

Then manually verify by reading the file: the GeofenceCoverageCard component should appear in the file, and `<GeofenceCoverageCard />` should appear in the JSX between the header and the form section.
  </verify>
  <done>
The `/admin/geofences` page renders a coverage stat card at the top showing "X of Y active sites covered (Z%)" with color-coded styling (green for full coverage, blue for partial, gray for no data). The Skeleton component from shadcn/ui shows during loading. The card auto-refreshes every 60 seconds via the TanStack Query hook.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation: `pnpm --dir web build` succeeds without errors
2. File existence: `web/lib/queries/admin/geofences.ts` exists with exported hook
3. Integration: `web/app/admin/geofences/page.tsx` imports and renders GeofenceCoverageCard
4. Coverage logic: Hook filters active bookings (confirmed/in_progress, shift_date >= today) and active geofences (is_active = true, booking_id IS NOT NULL)
5. Edge cases: "No active bookings to cover" when total = 0; "0 of Y ... (0%)" when covered = 0 but total > 0
6. Polling: refetchInterval set to 60_000 (60 seconds)
</verification>

<success_criteria>
1. Admin navigates to /admin/geofences and sees a stat card above the geofence list showing coverage percentage
2. Card correctly calculates coverage using Set intersection (no double-counting)
3. Card handles edge cases: 0 bookings, 0 coverage, full coverage with distinct visual states
4. Stat auto-refreshes every 60 seconds via TanStack Query polling
5. Build passes with zero new errors
</success_criteria>

<output>
After completion, create `.planning/phases/17-geofence-coverage-analytics/17-01-SUMMARY.md`
</output>
