---
phase: 40-comms-docs-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/143_comms_docs_schema.sql
autonomous: true

must_haves:
  truths:
    - "Tables conversations, messages, message_recipients, conversation_read_status, document_categories, documents, document_versions exist in the database"
    - "Every table has an org_id column with a NOT NULL FK to organizations(id)"
    - "RLS is enabled on every table with org_id = (SELECT get_user_org_id()) policies for SELECT/INSERT/UPDATE/DELETE"
    - "Platform admin bypass policy (is_platform_admin()) exists on every table"
    - "Default document categories (Insurance, DBS, Qualification, ID, Other) are seeded for all existing orgs"
    - "A trigger seeds default categories when a new org is created"
    - "Indexes exist on org_id for every table plus composite indexes for common query patterns"
  artifacts:
    - path: "supabase/migrations/143_comms_docs_schema.sql"
      provides: "All 7 tables, RLS policies, indexes, triggers, seeding"
      contains: "CREATE TABLE conversations"
  key_links:
    - from: "conversations.org_id"
      to: "organizations(id)"
      via: "REFERENCES FK + RLS policy"
      pattern: "org_id = \\(SELECT get_user_org_id\\(\\)\\)"
    - from: "messages.org_id"
      to: "organizations(id)"
      via: "Denormalized FK for direct RLS (no JOIN to conversations)"
      pattern: "org_id UUID NOT NULL REFERENCES organizations"
    - from: "document_categories seeding trigger"
      to: "organizations INSERT"
      via: "AFTER INSERT trigger on organizations"
      pattern: "CREATE TRIGGER seed_document_categories"
---

<objective>
Create the complete database schema for v5.0 messaging and document management as a single Supabase migration.

Purpose: This migration establishes the data foundation for all subsequent v5.0 phases (41-47). Every table is scoped to org_id for multi-tenant isolation, with denormalized org_id on child tables (messages, message_recipients, document_versions) to avoid JOIN-based RLS performance issues.

Output: `supabase/migrations/143_comms_docs_schema.sql` containing 7 tables, RLS policies, indexes, triggers, and default category seeding.
</objective>

<execution_context>
@/Users/sabineresoagli/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sabineresoagli/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/40-comms-docs-foundation/40-CONTEXT.md
@.planning/phases/40-comms-docs-foundation/40-RESEARCH.md

# Reference migrations for established patterns:
@supabase/migrations/028_enable_org_rls.sql
@supabase/migrations/101_migrate_to_platform_admin.sql
@supabase/migrations/118_org_settings.sql
@supabase/migrations/141_compliance_documents.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create migration 143 — all tables, RLS, indexes, triggers, seeding</name>
  <files>supabase/migrations/143_comms_docs_schema.sql</files>
  <action>
Create `supabase/migrations/143_comms_docs_schema.sql` with the following content, in this exact order:

**1. document_categories table (lookup table with org_id)**
```sql
CREATE TABLE document_categories (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  org_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  slug TEXT NOT NULL,
  is_required BOOLEAN NOT NULL DEFAULT false,
  is_active BOOLEAN NOT NULL DEFAULT true,
  sort_order INT NOT NULL DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(org_id, slug)
);
```

**2. conversations table**
```sql
CREATE TABLE conversations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  org_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  type TEXT NOT NULL DEFAULT 'direct' CHECK (type IN ('direct', 'broadcast')),
  subject TEXT,
  medic_id UUID REFERENCES medics(id) ON DELETE SET NULL,
  created_by UUID NOT NULL REFERENCES auth.users(id),
  last_message_at TIMESTAMPTZ,
  last_message_preview TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);
```
Add partial unique index: `CREATE UNIQUE INDEX idx_conversations_org_medic_direct ON conversations(org_id, medic_id) WHERE type = 'direct';` — prevents duplicate direct conversations per medic per org.

**3. messages table (with denormalized org_id)**
```sql
CREATE TABLE messages (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  conversation_id UUID NOT NULL REFERENCES conversations(id) ON DELETE CASCADE,
  org_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  sender_id UUID NOT NULL REFERENCES auth.users(id),
  message_type TEXT NOT NULL DEFAULT 'text' CHECK (message_type IN ('text', 'attachment', 'system')),
  content TEXT,
  metadata JSONB,
  status TEXT NOT NULL DEFAULT 'sent' CHECK (status IN ('sent', 'delivered', 'read')),
  deleted_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);
```

**4. message_recipients table (for broadcast read tracking, denormalized org_id)**
```sql
CREATE TABLE message_recipients (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  message_id UUID NOT NULL REFERENCES messages(id) ON DELETE CASCADE,
  recipient_id UUID NOT NULL REFERENCES auth.users(id),
  org_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  delivered_at TIMESTAMPTZ,
  read_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(message_id, recipient_id)
);
```

**5. conversation_read_status table (lightweight unread tracking)**
```sql
CREATE TABLE conversation_read_status (
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  conversation_id UUID NOT NULL REFERENCES conversations(id) ON DELETE CASCADE,
  org_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  last_read_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  PRIMARY KEY (user_id, conversation_id)
);
```

**6. documents table**
```sql
CREATE TABLE documents (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  org_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  medic_id UUID NOT NULL REFERENCES medics(id) ON DELETE CASCADE,
  category_id UUID NOT NULL REFERENCES document_categories(id),
  current_version_id UUID,
  status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'approved', 'rejected', 'expired', 'archived')),
  reviewed_by UUID REFERENCES auth.users(id),
  reviewed_at TIMESTAMPTZ,
  review_notes TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);
```

**7. document_versions table (denormalized org_id)**
```sql
CREATE TABLE document_versions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
  org_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  storage_path TEXT NOT NULL,
  file_name TEXT NOT NULL,
  file_size_bytes INT,
  mime_type TEXT,
  issue_date DATE,
  expiry_date DATE,
  certificate_number TEXT,
  notes TEXT,
  version_number INT NOT NULL DEFAULT 1,
  uploaded_by UUID NOT NULL REFERENCES auth.users(id),
  created_at TIMESTAMPTZ DEFAULT NOW()
);
```

**8. Circular FK for current_version_id**
```sql
ALTER TABLE documents ADD CONSTRAINT fk_documents_current_version
  FOREIGN KEY (current_version_id) REFERENCES document_versions(id);
```

**9. Indexes** — Create these on every table:
- `CREATE INDEX idx_{table}_org_id ON {table}(org_id);` on: document_categories, conversations, messages, message_recipients, conversation_read_status, documents, document_versions
- Composite indexes:
  - `CREATE INDEX idx_conversations_medic_id ON conversations(medic_id);`
  - `CREATE INDEX idx_conversations_last_message ON conversations(org_id, last_message_at DESC);`
  - `CREATE INDEX idx_messages_conversation ON messages(conversation_id, created_at DESC);`
  - `CREATE INDEX idx_messages_sender ON messages(sender_id);`
  - `CREATE INDEX idx_message_recipients_recipient ON message_recipients(recipient_id);`
  - `CREATE INDEX idx_message_recipients_message ON message_recipients(message_id);`
  - `CREATE INDEX idx_documents_medic ON documents(medic_id);`
  - `CREATE INDEX idx_documents_category ON documents(category_id);`
  - `CREATE INDEX idx_documents_status ON documents(status);`
  - `CREATE INDEX idx_document_versions_doc ON document_versions(document_id);`
  - `CREATE INDEX idx_document_versions_expiry ON document_versions(expiry_date) WHERE expiry_date IS NOT NULL;`

**10. Enable RLS on all 7 tables:**
```sql
ALTER TABLE document_categories ENABLE ROW LEVEL SECURITY;
ALTER TABLE conversations ENABLE ROW LEVEL SECURITY;
ALTER TABLE messages ENABLE ROW LEVEL SECURITY;
ALTER TABLE message_recipients ENABLE ROW LEVEL SECURITY;
ALTER TABLE conversation_read_status ENABLE ROW LEVEL SECURITY;
ALTER TABLE documents ENABLE ROW LEVEL SECURITY;
ALTER TABLE document_versions ENABLE ROW LEVEL SECURITY;
```

**11. RLS policies** — For EACH of the 7 tables, create:
- SELECT policy: `USING (org_id = (SELECT get_user_org_id()))` — use `(SELECT ...)` wrapper for query plan caching
- INSERT policy: `WITH CHECK (org_id = (SELECT get_user_org_id()))`
- UPDATE policy: `USING (org_id = (SELECT get_user_org_id()))`
- DELETE policy: `USING (org_id = (SELECT get_user_org_id()))`
- Platform admin bypass: `FOR ALL USING (is_platform_admin())`

Use descriptive policy names like: `"Org users can view conversations"`, `"Platform admin full access to conversations"`, etc.

For messages, add an additional SELECT filter: `AND deleted_at IS NULL` in the org user SELECT policy — so soft-deleted messages are hidden from normal queries but visible to platform admin.

For conversation_read_status, the user should only see/modify their own rows:
- SELECT: `USING (user_id = auth.uid() AND org_id = (SELECT get_user_org_id()))`
- INSERT: `WITH CHECK (user_id = auth.uid() AND org_id = (SELECT get_user_org_id()))`
- UPDATE: `USING (user_id = auth.uid() AND org_id = (SELECT get_user_org_id()))`
- DELETE: `USING (user_id = auth.uid() AND org_id = (SELECT get_user_org_id()))`

**12. updated_at triggers** — Apply `update_updated_at_column()` trigger on tables with updated_at:
- document_categories, conversations, messages, documents (NOT message_recipients, conversation_read_status, document_versions — these lack updated_at)

**13. Seed default document categories for existing orgs:**
```sql
INSERT INTO document_categories (org_id, name, slug, sort_order)
SELECT o.id, cat.name, cat.slug, cat.sort_order
FROM organizations o
CROSS JOIN (VALUES
  ('Insurance', 'insurance', 1),
  ('DBS', 'dbs', 2),
  ('Qualification', 'qualification', 3),
  ('ID', 'id', 4),
  ('Other', 'other', 5)
) AS cat(name, slug, sort_order)
ON CONFLICT (org_id, slug) DO NOTHING;
```

**14. Trigger to seed categories on new org creation:**
Create a function `seed_default_document_categories()` and trigger:
```sql
CREATE OR REPLACE FUNCTION seed_default_document_categories()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO document_categories (org_id, name, slug, sort_order) VALUES
    (NEW.id, 'Insurance', 'insurance', 1),
    (NEW.id, 'DBS', 'dbs', 2),
    (NEW.id, 'Qualification', 'qualification', 3),
    (NEW.id, 'ID', 'id', 4),
    (NEW.id, 'Other', 'other', 5);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER trigger_seed_document_categories
  AFTER INSERT ON organizations
  FOR EACH ROW EXECUTE FUNCTION seed_default_document_categories();
```

Add a comment at the top of the migration file:
```sql
-- Migration 143: Comms & Docs Foundation (Phase 40-01)
-- Creates messaging tables (conversations, messages, message_recipients, conversation_read_status)
-- and document management tables (document_categories, documents, document_versions)
-- with org_id-scoped RLS policies, performance indexes, and default category seeding.
-- Part of v5.0 Internal Comms & Document Management.
```
  </action>
  <verify>
Run `grep -c "CREATE TABLE" supabase/migrations/143_comms_docs_schema.sql` — should return 7.
Run `grep -c "ENABLE ROW LEVEL SECURITY" supabase/migrations/143_comms_docs_schema.sql` — should return 7.
Run `grep -c "CREATE POLICY" supabase/migrations/143_comms_docs_schema.sql` — should return at least 35 (5 policies per table x 7 tables).
Run `grep -c "CREATE INDEX" supabase/migrations/143_comms_docs_schema.sql` — should return at least 18.
Run `grep -c "CREATE TRIGGER" supabase/migrations/143_comms_docs_schema.sql` — should return 5 (4 updated_at + 1 seed trigger).
Run `grep "get_user_org_id" supabase/migrations/143_comms_docs_schema.sql | wc -l` — should be at least 28 (4 policies per table x 7 tables).
  </verify>
  <done>
Migration 143 exists with all 7 tables, RLS policies using (SELECT get_user_org_id()) wrapper, performance indexes on org_id and composite columns, updated_at triggers, default category seeding for existing orgs, and an AFTER INSERT trigger on organizations to seed categories for new orgs. Platform admin bypass policy exists on every table.
  </done>
</task>

</tasks>

<verification>
1. File exists: `ls supabase/migrations/143_comms_docs_schema.sql`
2. All 7 tables present: conversations, messages, message_recipients, conversation_read_status, document_categories, documents, document_versions
3. Every table has `org_id UUID NOT NULL REFERENCES organizations(id)`
4. Every table has RLS enabled + 5 policies (SELECT, INSERT, UPDATE, DELETE for org users + ALL for platform admin)
5. Messages SELECT policy includes `deleted_at IS NULL` filter
6. conversation_read_status policies include `user_id = auth.uid()` check
7. Partial unique index on conversations(org_id, medic_id) WHERE type = 'direct'
8. Circular FK from documents.current_version_id to document_versions.id
9. Default categories seeded for existing orgs via CROSS JOIN
10. Trigger on organizations INSERT seeds default categories for new orgs
</verification>

<success_criteria>
- Migration file contains valid SQL for all 7 tables with org_id on every one
- RLS policies enforce org_id isolation using (SELECT get_user_org_id()) wrapper pattern
- Platform admin bypass exists on every table via is_platform_admin()
- Indexes exist for org_id on every table plus composite indexes for messages, conversations, documents
- Default document categories (Insurance, DBS, Qualification, ID, Other) seeded for existing orgs
- Auto-seeding trigger fires on new org creation
</success_criteria>

<output>
After completion, create `.planning/phases/40-comms-docs-foundation/40-01-SUMMARY.md`
</output>
