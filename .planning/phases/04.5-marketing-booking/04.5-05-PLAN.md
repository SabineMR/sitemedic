---
phase: 04.5-marketing-booking
plan: 05
type: execute
wave: 5
depends_on: ["04.5-04"]
files_modified:
  - web/app/api/bookings/[id]/route.ts
  - web/app/(booking)/book/confirmation/page.tsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Confirmation page shows actual booking site name and address from database (not hardcoded 'Construction Site' / 'London, UK')"
    - "Confirmation page shows accurate pricing breakdown from booking record (base_rate, urgency, travel, subtotal, VAT, total)"
    - "Confirmation page shows actual client email from clients table (not 'client@example.com')"
    - "Confirmation page shows actual shift times from booking record (shift_start_time, shift_end_time)"
    - "Recurring booking settings (is_recurring, recurrence_pattern, recurring_until) fetched from database and used for recurring flow"
  artifacts:
    - path: "web/app/api/bookings/[id]/route.ts"
      provides: "GET endpoint fetching booking by ID with client and medic joins"
      exports: ["GET"]
    - path: "web/app/(booking)/book/confirmation/page.tsx"
      provides: "Confirmation page using real booking data from API instead of mock"
      contains: "api/bookings/"
  key_links:
    - from: "web/app/(booking)/book/confirmation/page.tsx"
      to: "web/app/api/bookings/[id]/route.ts"
      via: "fetch to GET /api/bookings/{bookingId} after auto-match completes"
      pattern: "api/bookings/"
    - from: "web/app/api/bookings/[id]/route.ts"
      to: "bookings table"
      via: "Supabase query with joins to clients and medics tables"
      pattern: "from.*bookings.*select.*clients.*medics"
---

<objective>
Fix the confirmation page to fetch real booking data from Supabase instead of using hardcoded mock data.

Purpose: The confirmation page currently displays hardcoded values (£403.20, "Construction Site", "client@example.com") instead of the actual booking details from the database. This means clients see incorrect pricing, wrong site details, and cannot verify their booking information after payment. This is the single blocker preventing Phase 4.5 verification from passing (17/18 truths verified, this fixes #15).

Output: A GET API route for fetching booking details and an updated confirmation page that displays real data from the database.
</objective>

<execution_context>
@/Users/sabineresoagli/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sabineresoagli/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04.5-marketing-booking/04.5-04-SUMMARY.md
@.planning/phases/04.5-marketing-booking/04.5-VERIFICATION.md

Key existing files:
@web/app/(booking)/book/confirmation/page.tsx (current file with mock data on line 85-118)
@web/app/api/email/booking-confirmation/route.ts (reference for Supabase query pattern with joins)
@web/components/booking/booking-confirmation.tsx (BookingConfirmationProps interface)
@web/lib/supabase/server.ts (server-side Supabase client)
@supabase/migrations/002_business_operations.sql (bookings, clients, medics table schemas)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create booking detail API route and replace mock data in confirmation page</name>
  <files>
    web/app/api/bookings/[id]/route.ts
    web/app/(booking)/book/confirmation/page.tsx
  </files>
  <action>
    1. **web/app/api/bookings/[id]/route.ts** — Create GET endpoint to fetch a booking by ID with joined client and medic data:

       ```typescript
       import { createClient } from '@/lib/supabase/server';
       import { NextResponse } from 'next/server';
       ```

       - Export `async function GET(request, { params })` accepting booking ID from URL params
       - Use Supabase server client (`await createClient()`)
       - Query bookings table with joins (follow the EXACT same pattern as `web/app/api/email/booking-confirmation/route.ts` lines 34-52):
         ```typescript
         const { data: booking, error } = await supabase
           .from('bookings')
           .select(`
             *,
             clients (
               id,
               company_name,
               contact_name,
               contact_email
             ),
             medics (
               id,
               first_name,
               last_name,
               email,
               star_rating
             )
           `)
           .eq('id', bookingId)
           .single();
         ```
       - Note: include `star_rating` in medics select (fixes the TODO from match/route.ts line 137 where star_rating was hardcoded to 4.8)
       - Handle errors: 400 if no ID, 404 if booking not found
       - Normalize the joined relations (handle array vs object like email route does):
         ```typescript
         const client = Array.isArray(booking.clients) ? booking.clients[0] : booking.clients;
         const medic = booking.medics ? (Array.isArray(booking.medics) ? booking.medics[0] : booking.medics) : null;
         ```
       - Return JSON with all booking fields plus nested client and medic objects
       - Return format:
         ```json
         {
           "booking": { ...all booking columns },
           "client": { company_name, contact_name, contact_email },
           "medic": { first_name, last_name, star_rating } // null if not yet assigned
         }
         ```

    2. **web/app/(booking)/book/confirmation/page.tsx** — Replace the mockBooking (lines 85-118) with a real API call:

       - After the match API call succeeds (line 80), add a fetch to the new booking detail endpoint:
         ```typescript
         const bookingResponse = await fetch(`/api/bookings/${bookingId}`);
         if (!bookingResponse.ok) {
           throw new Error('Failed to fetch booking details');
         }
         const bookingDetail = await bookingResponse.json();
         ```

       - Remove the entire `mockBooking` object (lines 87-116)

       - Replace with a mapping from database fields to the BookingConfirmationProps interface that `booking-confirmation.tsx` expects:
         ```typescript
         const fetchedBooking = {
           id: bookingId,
           date: new Date(bookingDetail.booking.shift_date).toLocaleDateString('en-GB', {
             weekday: 'long',
             day: 'numeric',
             month: 'long',
             year: 'numeric',
           }),
           startTime: bookingDetail.booking.shift_start_time?.slice(0, 5) || '07:00',
           endTime: bookingDetail.booking.shift_end_time?.slice(0, 5) || '15:00',
           siteName: bookingDetail.booking.site_name,
           siteAddress: `${bookingDetail.booking.site_address}, ${bookingDetail.booking.site_postcode}`,
           medicName: bookingDetail.medic
             ? `${bookingDetail.medic.first_name} ${bookingDetail.medic.last_name}`
             : matchData.matches[0]?.medic_name || 'Assigned Medic',
           medicRating: bookingDetail.medic?.star_rating
             ? Number(bookingDetail.medic.star_rating)
             : matchData.matches[0]?.star_rating || 4.8,
           clientEmail: bookingDetail.client?.contact_email || 'No email on file',
           pricing: {
             baseRate: Number(bookingDetail.booking.base_rate),
             shiftHours: Number(bookingDetail.booking.shift_hours),
             hourlyTotal: Number(bookingDetail.booking.base_rate) * Number(bookingDetail.booking.shift_hours),
             urgencyPremiumPercent: bookingDetail.booking.urgency_premium_percent || 0,
             urgencyAmount: (Number(bookingDetail.booking.base_rate) * Number(bookingDetail.booking.shift_hours) * (bookingDetail.booking.urgency_premium_percent || 0)) / 100,
             travelSurcharge: Number(bookingDetail.booking.travel_surcharge) || 0,
             subtotal: Number(bookingDetail.booking.subtotal),
             vat: Number(bookingDetail.booking.vat),
             total: Number(bookingDetail.booking.total),
           },
           is_recurring: bookingDetail.booking.is_recurring || false,
           recurrence_pattern: bookingDetail.booking.recurrence_pattern || null,
           recurring_weeks: 0, // Calculate from recurring_until if needed
         };
         ```

       - Important field mappings from the bookings schema (002_business_operations.sql):
         - `shift_date` — DATE — needs `new Date()` conversion for display
         - `shift_start_time` — TIME — format "HH:MM:SS", slice to "HH:MM"
         - `shift_end_time` — TIME — same
         - `site_name` — TEXT
         - `site_address` — TEXT
         - `site_postcode` — TEXT
         - `base_rate` — DECIMAL — returned as string from Supabase, convert with `Number()`
         - `shift_hours` — DECIMAL
         - `urgency_premium_percent` — INT
         - `travel_surcharge` — DECIMAL
         - `subtotal` — DECIMAL
         - `vat` — DECIMAL
         - `total` — DECIMAL
         - `is_recurring` — BOOLEAN
         - `recurrence_pattern` — TEXT
         - `recurring_until` — DATE (schema uses recurring_until, NOT recurring_weeks per D-04.5-03-007)

       - Update the recurring booking logic (lines 121-147) to use `fetchedBooking.is_recurring` and `fetchedBooking.recurrence_pattern` from the real data. Calculate the number of weeks from `recurring_until` if is_recurring is true:
         ```typescript
         if (fetchedBooking.is_recurring && bookingDetail.booking.recurring_until) {
           const shiftDate = new Date(bookingDetail.booking.shift_date);
           const recurringUntil = new Date(bookingDetail.booking.recurring_until);
           const diffDays = Math.ceil((recurringUntil.getTime() - shiftDate.getTime()) / (1000 * 60 * 60 * 24));
           const weeks = fetchedBooking.recurrence_pattern === 'biweekly' ? Math.floor(diffDays / 14) : Math.floor(diffDays / 7);
           fetchedBooking.recurring_weeks = weeks; // Store calculated weeks in booking object for UI display
           // ... call recurring API with calculated weeks
         }
         ```

       - Replace `setBookingData(mockBooking)` with `setBookingData(fetchedBooking)`

       - Remove the TODO comment on line 85 ("// TODO: Fetch booking from Supabase") and the "// For now, mock the data structure" comment on line 86
  </action>
  <verify>
    Run `pnpm build` from web/ directory. Verify:
    1. web/app/api/bookings/[id]/route.ts compiles and exports GET handler
    2. web/app/(booking)/book/confirmation/page.tsx compiles without the mockBooking object
    3. No references to "Construction Site", "London, UK", or "client@example.com" remain in confirmation/page.tsx
    4. grep for "mockBooking" returns zero matches in confirmation/page.tsx
    5. grep for "TODO.*Fetch booking from Supabase" returns zero matches
  </verify>
  <done>
    Confirmation page fetches real booking data from GET /api/bookings/{id} with joins to clients and medics tables. All hardcoded mock values removed. Pricing breakdown uses actual database values (base_rate, urgency_premium_percent, travel_surcharge, subtotal, vat, total). Site details show real site_name and site_address + site_postcode. Client email comes from clients.contact_email. Medic name and star_rating come from medics table. Recurring booking logic uses is_recurring and recurring_until from database. The single verification blocker (truth #15: "Confirmation page shows booking summary with assigned medic details") is now achievable.
  </done>
</task>

</tasks>

<verification>
1. `pnpm build` succeeds without errors
2. GET /api/bookings/{id} returns booking with joined client and medic data
3. Confirmation page has ZERO hardcoded mock values (no "Construction Site", no "London, UK", no "client@example.com", no hardcoded pricing)
4. No TODO comments about fetching from Supabase remain
5. Pricing breakdown maps correctly: base_rate * shift_hours = hourlyTotal, urgency_premium_percent applied, travel_surcharge included, subtotal/vat/total from database
6. Recurring booking logic uses is_recurring and recurring_until from database (not hardcoded false/0)
7. Medic star_rating fetched from database (not hardcoded 4.8)
</verification>

<success_criteria>
- Confirmation page displays real booking data from Supabase (not mock)
- Pricing breakdown accurate (comes from booking record, not hardcoded)
- Client email from clients.contact_email (not hardcoded)
- Site details from booking.site_name and booking.site_address (not hardcoded)
- Recurring booking settings from database (is_recurring, recurrence_pattern, recurring_until)
- Medic name from medics.first_name + last_name, rating from medics.star_rating
- No TODO comments or mock data remain in confirmation page
- `pnpm build` succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/04.5-marketing-booking/04.5-05-SUMMARY.md`
</output>
