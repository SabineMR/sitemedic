# Phase 04.5: Marketing Website & Booking Portal - Research

**Researched:** 2026-02-15
**Domain:** Next.js SSG/SSR hybrid architecture, Stripe payment integration, booking system implementation
**Confidence:** HIGH

## Summary

Phase 04.5 builds a public-facing marketing website and client self-service booking portal with Stripe payment processing. The research identifies Next.js 15's App Router as the ideal foundation, leveraging Server Components for marketing pages (static generation) and booking flows (dynamic server rendering). Stripe Payment Intents API is recommended over Checkout Sessions for custom booking UI requirements, with careful handling of 3D Secure/SCA compliance.

The standard stack for this phase combines **shadcn/ui calendar components** (already in project dependencies) with **react-day-picker** for booking calendar UI, **Resend** for transactional emails with calendar attachments, and **ical-generator** for .ics file creation. Critical race condition prevention uses PostgreSQL's `SELECT ... FOR UPDATE` row-level locking, which is fully supported by Supabase.

**Primary recommendation:** Use Next.js 15 App Router with static generation (`generateStaticParams`) for marketing pages and Server Components for booking flows. Implement Stripe Payment Intents with 3D Secure support, use PostgreSQL row-level locking to prevent double-booking, and send booking confirmations via Resend with ical-generator for calendar invites.

## Standard Stack

The established libraries/tools for this domain:

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| Next.js | 15.1+ | Framework (App Router) | Official React framework, built-in SSG/SSR, industry standard for hybrid rendering |
| Stripe | 14+ | Payment processing | De facto payment platform, SCA-compliant, already integrated (Phase 1.5) |
| @stripe/stripe-js | 4.15+ | Client-side Stripe | Official Stripe client for Payment Element integration |
| Resend | 3.0+ | Email API | Modern developer-first API, React Email integration, minimal setup (5 min vs SendGrid's 30 min) |
| ical-generator | 10.0+ | Calendar invite (.ics) | De facto Node.js library for iCal generation, battle-tested |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| react-day-picker | 9.4+ | Calendar date picker | Already via shadcn/ui calendar (project uses date-fns 4.1.0) |
| react-email | 3.0+ | Email templates | When using Resend, enables JSX email templates |
| date-fns | 4.1+ | Date manipulation | Already in project (4.1.0), pairs with react-day-picker |
| Nodemailer | 6.9+ | Email sending fallback | If Resend unavailable, but adds complexity |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Resend | SendGrid | SendGrid has 15+ years reputation, better deliverability at scale, but worse DX and 6x longer setup time |
| Payment Intents API | Checkout Sessions API | Checkout Sessions has built-in features (tax, subscriptions, discounts) but less UI control—use if custom booking UI not required |
| ical-generator | ics (npm) | `ics` is browser-friendly but less feature-complete (no alarm support, limited timezone handling) |
| react-day-picker | React Big Calendar | Big Calendar for full calendar UI (Google Cal clone), but overkill for simple date picker—use only if displaying medic schedules |

**Installation:**
```bash
pnpm add @stripe/stripe-js resend react-email ical-generator
pnpm add @radix-ui/react-popover react-day-picker # (already installed via shadcn/ui)
```

## Architecture Patterns

### Recommended Project Structure
```
web/
├── app/
│   ├── (marketing)/          # Route group (SSG)
│   │   ├── page.tsx           # Homepage (static)
│   │   ├── pricing/           # Pricing page (static)
│   │   └── layout.tsx         # Marketing layout
│   ├── (booking)/             # Route group (SSR)
│   │   ├── book/              # Booking flow (dynamic)
│   │   │   ├── page.tsx       # Step 1: Calendar + location
│   │   │   ├── payment/       # Step 2: Payment
│   │   │   └── confirmation/  # Step 3: Confirmation
│   │   └── layout.tsx         # Booking layout
│   ├── api/
│   │   ├── stripe/            # Stripe webhooks
│   │   │   └── route.ts       # POST /api/stripe
│   │   ├── bookings/          # Booking mutations
│   │   │   ├── create/        # POST /api/bookings/create
│   │   │   └── match/         # POST /api/bookings/match (auto-matching)
│   │   └── email/             # Email sending
│   │       └── route.ts       # POST /api/email (Resend)
├── components/
│   ├── marketing/             # Marketing components
│   │   ├── hero.tsx
│   │   ├── pricing-table.tsx
│   │   └── trust-signals.tsx
│   ├── booking/               # Booking flow components
│   │   ├── calendar-picker.tsx
│   │   ├── location-input.tsx
│   │   ├── medic-matcher.tsx  # Auto-matching UI
│   │   └── payment-form.tsx   # Stripe Payment Element
│   └── ui/                    # shadcn/ui components (existing)
├── lib/
│   ├── stripe/
│   │   ├── client.ts          # Client-side Stripe
│   │   └── server.ts          # Server-side Stripe (Payment Intents)
│   ├── email/
│   │   ├── resend.ts          # Resend client
│   │   └── templates/         # React Email templates
│   │       ├── booking-confirmation.tsx
│   │       └── medic-assignment.tsx
│   └── booking/
│       ├── auto-matcher.ts    # Auto-matching algorithm
│       ├── pricing.ts         # Pricing calculation
│       └── calendar.ts        # .ics generation (ical-generator)
└── emails/                    # React Email templates (separate from components)
    ├── booking-confirmation.tsx
    └── medic-assignment.tsx
```

### Pattern 1: Next.js 15 Hybrid Rendering (SSG for Marketing, SSR for Booking)

**What:** Use static generation for marketing pages (fast CDN delivery, Lighthouse >90) and server-side rendering for booking flows (real-time availability, personalized pricing).

**When to use:** Any application with both public content (marketing) and dynamic user flows (booking).

**Example:**
```typescript
// app/(marketing)/page.tsx - STATIC (SSG)
// Source: https://nextjs.org/docs/app/api-reference/functions/generate-static-params

export const dynamic = 'force-static'; // Force static generation
export const revalidate = 86400; // Revalidate daily (ISR)

export default function HomePage() {
  return (
    <main>
      <Hero />
      <PricingTable />
      <TrustSignals />
    </main>
  );
}
```

```typescript
// app/(booking)/book/page.tsx - DYNAMIC (SSR)
// Source: https://nextjs.org/docs/app/building-your-application/rendering/server-components

import { CalendarPicker } from '@/components/booking/calendar-picker';

// Default behavior: Server Component with dynamic rendering
export default async function BookingPage() {
  // Server-side data fetching (real-time availability)
  const availableSlots = await fetchAvailableSlots();

  return (
    <main>
      <h1>Book a Medic</h1>
      <CalendarPicker availableSlots={availableSlots} />
    </main>
  );
}
```

**Key insight:** In Next.js 15 App Router, pages are Server Components by default. Use `'use client'` only for interactive components (calendar picker, payment form). Marketing pages use `export const dynamic = 'force-static'` to ensure SSG.

### Pattern 2: Stripe Payment Intents with Custom UI

**What:** Use Payment Intents API for custom booking UI with embedded Payment Element for card collection.

**When to use:** When you need custom checkout UI, manual pricing calculation (urgency premium, travel surcharge), and conditional payment logic (prepay vs Net 30).

**Example:**
```typescript
// app/api/bookings/create-payment-intent/route.ts
// Source: https://docs.stripe.com/payments/payment-intents

import { stripe } from '@/lib/stripe/server';
import { calculateBookingPrice } from '@/lib/booking/pricing';

export async function POST(request: Request) {
  const { bookingId, clientId } = await request.json();

  // Fetch client payment terms (prepay vs Net 30)
  const client = await fetchClient(clientId);

  // Calculate total with urgency premium, travel, VAT
  const pricing = calculateBookingPrice({
    baseRate: 250, // £250/shift
    isUrgent: isWithin24Hours(booking.date),
    travelDistance: 15, // miles
  });

  // Only create Payment Intent for prepay clients
  if (client.payment_terms === 'prepay') {
    const paymentIntent = await stripe.paymentIntents.create({
      amount: Math.round(pricing.total * 100), // Convert £ to pence
      currency: 'gbp',
      customer: client.stripe_customer_id,
      metadata: {
        booking_id: bookingId,
        client_id: clientId,
      },
      automatic_payment_methods: {
        enabled: true, // Enables 3D Secure automatically
      },
    });

    return Response.json({ clientSecret: paymentIntent.client_secret });
  } else {
    // Net 30 client - create booking without payment
    return Response.json({ net30: true });
  }
}
```

```typescript
// components/booking/payment-form.tsx
// Source: https://docs.stripe.com/payments/payment-element

'use client';

import { PaymentElement, useStripe, useElements } from '@stripe/react-stripe-js';

export function PaymentForm({ clientSecret }: { clientSecret: string }) {
  const stripe = useStripe();
  const elements = useElements();

  async function handleSubmit(e: React.FormEvent) {
    e.preventDefault();

    if (!stripe || !elements) return;

    // Confirm payment (triggers 3D Secure if required)
    const { error } = await stripe.confirmPayment({
      elements,
      confirmParams: {
        return_url: `${window.location.origin}/book/confirmation`,
      },
    });

    if (error) {
      console.error('Payment failed:', error);
    }
  }

  return (
    <form onSubmit={handleSubmit}>
      <PaymentElement />
      <button type="submit" disabled={!stripe}>
        Confirm Booking & Pay
      </button>
    </form>
  );
}
```

**Key insight:** Payment Intents API automatically handles 3D Secure when `automatic_payment_methods.enabled = true`. The client confirms payment, which redirects to bank's 3DS page if required, then returns to `return_url`.

### Pattern 3: PostgreSQL Row-Level Locking for Double-Booking Prevention

**What:** Use `SELECT ... FOR UPDATE` to lock availability slots before inserting bookings, preventing race conditions.

**When to use:** Any booking system where concurrent users might select the same time slot.

**Example:**
```typescript
// lib/booking/create-booking.ts
// Source: https://jsupskills.dev/how-to-solve-the-double-booking-problem/

import { createClient } from '@/lib/supabase/server';

export async function createBooking(data: BookingData) {
  const supabase = createClient();

  // Start transaction with row-level locking
  const { data: existingBooking, error } = await supabase.rpc('create_booking_with_lock', {
    p_medic_id: data.medicId,
    p_date: data.date,
    p_shift_time: data.shiftTime,
    p_client_id: data.clientId,
    p_site_location: data.siteLocation,
  });

  if (error) {
    if (error.code === 'P0001') { // Custom error from function
      throw new Error('This time slot has been booked by another user');
    }
    throw error;
  }

  return existingBooking;
}
```

```sql
-- Migration: Add create_booking_with_lock function
-- Source: https://medium.com/@krishnaraj/postgresql-handling-double-booking-problem-2-phase-locking-8432aa650910

CREATE OR REPLACE FUNCTION create_booking_with_lock(
  p_medic_id UUID,
  p_date DATE,
  p_shift_time TEXT,
  p_client_id UUID,
  p_site_location TEXT
) RETURNS bookings AS $$
DECLARE
  v_booking bookings;
BEGIN
  -- Lock existing bookings for this medic/date (prevents concurrent inserts)
  PERFORM 1 FROM bookings
  WHERE medic_id = p_medic_id
    AND booking_date = p_date
    AND shift_time = p_shift_time
    AND status != 'cancelled'
  FOR UPDATE; -- Exclusive lock until transaction commits

  -- Check if slot is available
  IF FOUND THEN
    RAISE EXCEPTION 'Booking slot already taken' USING ERRCODE = 'P0001';
  END IF;

  -- Insert booking (lock held, safe from race conditions)
  INSERT INTO bookings (medic_id, booking_date, shift_time, client_id, site_location, status)
  VALUES (p_medic_id, p_date, p_shift_time, p_client_id, p_site_location, 'confirmed')
  RETURNING * INTO v_booking;

  RETURN v_booking;
END;
$$ LANGUAGE plpgsql;
```

**Key insight:** `FOR UPDATE` locks rows until transaction commits, preventing other concurrent transactions from reading or modifying them. Supabase fully supports this PostgreSQL feature.

### Pattern 4: Resend Email with Calendar Attachments

**What:** Send booking confirmation emails with .ics calendar invites using Resend + ical-generator.

**When to use:** Any booking system requiring calendar invites (appointments, reservations).

**Example:**
```typescript
// lib/email/send-booking-confirmation.ts
// Source: https://resend.com/nextjs

import { Resend } from 'resend';
import ical, { ICalCalendar } from 'ical-generator';
import BookingConfirmation from '@/emails/booking-confirmation';

const resend = new Resend(process.env.RESEND_API_KEY);

export async function sendBookingConfirmation(booking: Booking, client: Client) {
  // Generate .ics calendar invite
  const calendar = ical({ name: 'SiteMedic Booking' });

  calendar.createEvent({
    start: new Date(booking.booking_date + 'T' + booking.shift_start_time),
    end: new Date(booking.booking_date + 'T' + booking.shift_end_time),
    summary: `Medic Visit - ${client.company_name}`,
    description: `Site Medic: ${booking.medic_name}\nLocation: ${booking.site_location}`,
    location: booking.site_location,
    organizer: {
      name: 'SiteMedic',
      email: 'bookings@sitemedic.co.uk',
    },
    attendees: [
      { email: client.contact_email, name: client.contact_name },
      { email: booking.medic_email, name: booking.medic_name },
    ],
  });

  // Send email with React Email template + .ics attachment
  const { data, error } = await resend.emails.send({
    from: 'SiteMedic Bookings <bookings@sitemedic.co.uk>',
    to: client.contact_email,
    subject: `Booking Confirmed - ${booking.booking_date}`,
    react: BookingConfirmation({ booking, client }),
    attachments: [
      {
        filename: 'booking.ics',
        content: calendar.toString(),
        contentType: 'text/calendar; charset=utf-8; method=REQUEST',
      },
    ],
  });

  if (error) throw error;
  return data;
}
```

```tsx
// emails/booking-confirmation.tsx
// Source: https://react.email

import { Html, Head, Body, Container, Heading, Text, Button } from '@react-email/components';

export default function BookingConfirmation({ booking, client }) {
  return (
    <Html>
      <Head />
      <Body style={{ fontFamily: 'sans-serif' }}>
        <Container>
          <Heading>Booking Confirmed</Heading>
          <Text>Hi {client.contact_name},</Text>
          <Text>
            Your medic booking for {booking.booking_date} has been confirmed.
          </Text>
          <Text>
            <strong>Medic:</strong> {booking.medic_name}<br />
            <strong>Date:</strong> {booking.booking_date}<br />
            <strong>Time:</strong> {booking.shift_start_time} - {booking.shift_end_time}<br />
            <strong>Location:</strong> {booking.site_location}
          </Text>
          <Text>
            A calendar invite (.ics file) is attached to this email.
          </Text>
          <Button href="https://sitemedic.co.uk/bookings">
            View Booking
          </Button>
        </Container>
      </Body>
    </Html>
  );
}
```

**Key insight:** Resend integrates seamlessly with React Email (same team built both). Use `attachments` field with `contentType: 'text/calendar'` and `method=REQUEST` for calendar invites. CRITICAL: Don't add extra file attachments—they break calendar rendering in email clients.

### Anti-Patterns to Avoid

- **Don't use Client Components for entire pages** - Only mark interactive components with `'use client'`. Server Components are default and should remain so for data fetching.
- **Don't use Checkout Sessions for custom booking UI** - Checkout Sessions redirects users to Stripe-hosted page. Use Payment Intents for embedded checkout.
- **Don't skip transaction locking for bookings** - Without `FOR UPDATE`, concurrent requests can create double-bookings (race condition).
- **Don't use `generateStaticParams` for booking pages** - Booking flows need real-time data (availability, pricing). Only use SSG for marketing pages.
- **Don't create Payment Intent on every calendar date click** - Create Payment Intent only when user confirms booking details (Step 2 of flow). Creating too early wastes Stripe API calls.

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Calendar invite generation | Custom .ics string builder | ical-generator | .ics format has 20+ edge cases (timezones, DST, recurrence rules, VTIMEZONE). ical-generator handles all RFC 5545 compliance. |
| Email sending with attachments | Raw SMTP with nodemailer | Resend | Resend handles DKIM/SPF/DMARC automatically (5 min setup vs 30-60 min), built-in React Email integration, better DX. |
| 3D Secure payment flow | Custom redirect handling | Stripe Payment Element + `automatic_payment_methods` | Stripe handles 3DS2, SCA compliance, bank redirects, fallback to 3DS1. Custom implementation misses edge cases (soft declines, issuer errors). |
| Date picker with disabled dates | Custom calendar component | shadcn/ui Calendar (react-day-picker) | react-day-picker handles keyboard navigation, ARIA labels, timezone edge cases, locale formatting. Custom builds miss accessibility. |
| Pricing calculation with VAT | Manual percentage math | Dedicated pricing function with tests | VAT rounding errors cause audit issues. Build once with comprehensive tests (zero-rating, reverse charge, margin schemes). |
| Double-booking prevention | Client-side checks only | PostgreSQL `FOR UPDATE` row-level locking | Client-side checks fail with concurrent requests (race condition). Database-level locking is atomic and guaranteed. |

**Key insight:** Calendar invites, email deliverability, and payment compliance have deep complexity. Use battle-tested libraries that handle edge cases.

## Common Pitfalls

### Pitfall 1: Race Conditions in Booking Creation

**What goes wrong:** Two clients book the same medic/time simultaneously. Without database-level locking, both bookings succeed, creating double-booking.

**Why it happens:**
1. Client A checks availability → slot is free
2. Client B checks availability → slot is free (A hasn't inserted yet)
3. Client A inserts booking → success
4. Client B inserts booking → success (double-booked!)

**How to avoid:**
Use PostgreSQL `SELECT ... FOR UPDATE` in a stored function:
```sql
-- Lock existing bookings first (atomic operation)
PERFORM 1 FROM bookings
WHERE medic_id = p_medic_id AND booking_date = p_date
FOR UPDATE;

-- Then check and insert in same transaction
IF EXISTS (SELECT 1 FROM bookings WHERE ...) THEN
  RAISE EXCEPTION 'Slot taken';
END IF;

INSERT INTO bookings (...);
```

**Warning signs:**
- Multiple bookings for same medic/time in database
- Clients reporting "booked successfully" but no medic assigned
- Stripe charges without corresponding bookings

**Source:** [How to Solve Race Conditions in a Booking System - HackerNoon](https://hackernoon.com/how-to-solve-race-conditions-in-a-booking-system), [PostgreSQL Row-Level Locks Guide](https://scalablearchitect.com/postgresql-row-level-locks-a-complete-guide-to-for-update-for-share-skip-locked-and-nowait/)

### Pitfall 2: 3D Secure Redirect Loop (Payment Intent)

**What goes wrong:** After 3D Secure authentication, user redirects to `return_url` but payment is still "processing" or "requires_action" status. Page keeps redirecting in a loop.

**Why it happens:** Payment Intent confirmation is asynchronous. The redirect happens before Stripe finalizes the payment. Checking payment status on `return_url` page before webhook confirms it causes loop.

**How to avoid:**
1. **Use webhooks to confirm payment** - Listen for `payment_intent.succeeded` event
2. **On return_url page, poll payment status** - Use `stripe.retrievePaymentIntent(clientSecret)` to check status
3. **Show loading state** - Don't assume payment succeeded on redirect

```typescript
// app/book/confirmation/page.tsx
'use client';

import { useEffect, useState } from 'react';
import { useSearchParams } from 'next/navigation';
import { stripe } from '@/lib/stripe/client';

export default function ConfirmationPage() {
  const searchParams = useSearchParams();
  const paymentIntentClientSecret = searchParams.get('payment_intent_client_secret');
  const [status, setStatus] = useState<'loading' | 'success' | 'error'>('loading');

  useEffect(() => {
    if (!paymentIntentClientSecret) return;

    // Poll payment intent status (don't trust redirect alone)
    stripe.retrievePaymentIntent(paymentIntentClientSecret).then(({ paymentIntent }) => {
      if (paymentIntent.status === 'succeeded') {
        setStatus('success');
      } else if (paymentIntent.status === 'requires_action') {
        // Still processing 3DS - wait for webhook
        setStatus('loading');
      } else {
        setStatus('error');
      }
    });
  }, [paymentIntentClientSecret]);

  if (status === 'loading') return <p>Confirming payment...</p>;
  if (status === 'error') return <p>Payment failed</p>;
  return <p>Booking confirmed!</p>;
}
```

**Warning signs:**
- User redirects to confirmation page but sees "payment processing"
- Payment Intent status stuck at "requires_action" for minutes
- Webhook received but UI not updating

**Source:** [Stripe 3D Secure Authentication Flow](https://docs.stripe.com/payments/3d-secure/authentication-flow), [Payment Intents API](https://docs.stripe.com/payments/payment-intents)

### Pitfall 3: Calendar Attachments Breaking Email Rendering

**What goes wrong:** Email with .ics attachment displays as plain text or corrupted calendar invite in Outlook/Gmail.

**Why it happens:** Email clients (especially Outlook) are sensitive to MIME structure. Adding multiple attachments or incorrect `Content-Type` headers breaks calendar rendering.

**How to avoid:**
1. **Use `contentType: 'text/calendar; charset=utf-8; method=REQUEST'`** - Exact format required
2. **Don't add extra file attachments** - Keep email simple (text + html + icalEvent only)
3. **Use `method=REQUEST` for invites** - This tells email clients to show "Accept/Decline" buttons

```typescript
// CORRECT: Single .ics attachment with proper content type
await resend.emails.send({
  from: 'bookings@sitemedic.co.uk',
  to: client.email,
  subject: 'Booking Confirmed',
  react: BookingConfirmation({ booking }),
  attachments: [
    {
      filename: 'booking.ics',
      content: calendar.toString(),
      contentType: 'text/calendar; charset=utf-8; method=REQUEST', // Critical!
    },
  ],
});

// WRONG: Extra PDF attachment breaks calendar rendering
attachments: [
  { filename: 'booking.ics', content: ics, contentType: 'text/calendar' },
  { filename: 'invoice.pdf', content: pdf, contentType: 'application/pdf' }, // ❌ Breaks calendar
]
```

**Warning signs:**
- Calendar invite shows as .ics file attachment instead of event
- Outlook shows "This calendar invite cannot be processed"
- Gmail doesn't display "Add to Calendar" button

**Source:** [Nodemailer Calendar Events](https://nodemailer.com/message/calendar-events), [WebSearch: Calendar invite .ics file generation](https://medium.com/@webcore1/react-native-stripe-paymentintent-implementation-with-3d-secure-3149177dc6c7)

### Pitfall 4: Static Generation for Dynamic Booking Pages

**What goes wrong:** Booking page shows stale availability data (yesterday's calendar) because Next.js statically generated it at build time.

**Why it happens:** Using `export const dynamic = 'force-static'` or `generateStaticParams` on booking pages caches them as static HTML. Real-time availability data never refreshes.

**How to avoid:**
1. **Only use SSG for marketing pages** - Homepage, pricing, about pages are static
2. **Booking pages MUST be dynamic** - Don't use `force-static` or `revalidate` on booking flows
3. **Server Components fetch data on each request** - Default Next.js 15 behavior

```typescript
// ✅ CORRECT: Marketing page (static)
// app/(marketing)/pricing/page.tsx
export const dynamic = 'force-static';
export const revalidate = 86400; // Revalidate daily

export default function PricingPage() {
  return <PricingTable />;
}

// ✅ CORRECT: Booking page (dynamic)
// app/(booking)/book/page.tsx
// NO export const dynamic = 'force-static' here!

export default async function BookPage() {
  const availableSlots = await fetchAvailableSlots(); // Real-time data
  return <CalendarPicker slots={availableSlots} />;
}

// ❌ WRONG: Booking page with static generation
export const dynamic = 'force-static'; // ❌ Breaks real-time availability
export default function BookPage() {
  // Stale data from build time!
}
```

**Warning signs:**
- Booking calendar shows slots that are already taken
- Client books a slot that medic shows as unavailable
- New bookings don't appear until redeploy

**Source:** [Next.js ISR Guide](https://nextjs.org/docs/app/guides/incremental-static-regeneration), [SSG vs SSR in Next.js](https://colorwhistle.com/ssr-ssg-trends-nextjs/)

### Pitfall 5: Prepay vs Net 30 Logic Not Enforced

**What goes wrong:** New clients bypass prepayment and book with "Net 30" terms, creating bad debt risk.

**Why it happens:** Client registration doesn't enforce `payment_terms = 'prepay'` for new accounts, or booking flow doesn't check payment terms before allowing Net 30.

**How to avoid:**
1. **Default new clients to `prepay`** - Database constraint ensures safety
2. **Check payment terms server-side** - Never trust client-side logic
3. **Only create Payment Intent for prepay clients** - Net 30 creates invoice instead

```sql
-- Database constraint: New clients must prepay
ALTER TABLE clients
ADD CONSTRAINT new_clients_must_prepay
CHECK (
  (created_at = updated_at AND payment_terms = 'prepay') OR
  (created_at < updated_at) -- Existing clients can have Net 30
);
```

```typescript
// Server-side enforcement
export async function createBooking(data: BookingData) {
  const client = await fetchClient(data.clientId);

  // CRITICAL: Check payment terms on server (not client)
  if (client.payment_terms === 'prepay') {
    const paymentIntent = await createPaymentIntent(data);
    if (!paymentIntent.paid) {
      throw new Error('Payment required before booking confirmed');
    }
  } else if (client.payment_terms === 'net_30') {
    // Check credit limit before allowing Net 30
    if (client.outstanding_balance + data.price > client.credit_limit) {
      throw new Error('Credit limit exceeded - payment required');
    }
  }

  // Create booking only after payment/credit check
  return insertBooking(data);
}
```

**Warning signs:**
- New clients with `payment_terms = 'net_30'` in database
- Bookings created without corresponding Stripe charges
- Outstanding balance exceeds credit limit

**Source:** Existing database schema (`002_business_operations.sql` lines 52-74), Stripe best practices

## Code Examples

Verified patterns from official sources:

### Example 1: Auto-Matching Algorithm UI with Transparency

```typescript
// components/booking/medic-matcher.tsx
// Source: UX best practices for AI transparency (2026)

'use client';

import { useState } from 'react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';

interface MedicMatch {
  medic_id: string;
  medic_name: string;
  star_rating: number;
  distance_miles: number;
  travel_time_minutes: number;
  availability: 'available' | 'backup' | 'unavailable';
  match_score: number; // 0-100
  match_reasons: string[]; // Transparency: explain WHY this medic
}

export function MedicMatcher({ matches }: { matches: MedicMatch[] }) {
  const [selectedMedic, setSelectedMedic] = useState<string | null>(null);

  return (
    <div className="space-y-4">
      <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
        <h3 className="font-semibold mb-2">How We Match Medics</h3>
        <p className="text-sm text-gray-700">
          Our algorithm ranks medics based on:
          <ul className="list-disc list-inside mt-2">
            <li>Distance to your site (closer is better)</li>
            <li>Availability on your selected date</li>
            <li>Performance rating (4.5+ stars preferred)</li>
            <li>Qualifications matching your requirements</li>
          </ul>
        </p>
      </div>

      <div className="space-y-3">
        {matches.map((match) => (
          <Card key={match.medic_id} className={selectedMedic === match.medic_id ? 'border-primary' : ''}>
            <CardHeader>
              <div className="flex items-start justify-between">
                <div>
                  <CardTitle>{match.medic_name}</CardTitle>
                  <CardDescription>
                    {match.distance_miles} miles away • {match.travel_time_minutes} min travel
                  </CardDescription>
                </div>
                <Badge variant={match.availability === 'available' ? 'default' : 'secondary'}>
                  {match.availability}
                </Badge>
              </div>
            </CardHeader>
            <CardContent>
              <div className="space-y-3">
                <div className="flex items-center gap-2">
                  <span className="text-2xl font-bold">{match.star_rating}</span>
                  <span className="text-sm text-gray-600">/ 5.0 rating</span>
                </div>

                {/* TRANSPARENCY: Show why this medic was matched */}
                <div className="bg-gray-50 rounded-lg p-3">
                  <p className="text-sm font-semibold mb-1">Why this medic?</p>
                  <ul className="text-sm text-gray-700 space-y-1">
                    {match.match_reasons.map((reason, i) => (
                      <li key={i}>✓ {reason}</li>
                    ))}
                  </ul>
                </div>

                <Button
                  onClick={() => setSelectedMedic(match.medic_id)}
                  variant={selectedMedic === match.medic_id ? 'default' : 'outline'}
                  className="w-full"
                >
                  {selectedMedic === match.medic_id ? 'Selected' : 'Select This Medic'}
                </Button>
              </div>
            </CardContent>
          </Card>
        ))}
      </div>
    </div>
  );
}
```

**Source:** [UX Design Trends 2026 - Explainable AI](https://www.uxdesigninstitute.com/blog/the-top-ux-design-trends-in-2026/), [Algorithm Transparency Best Practices](https://jakobnielsenphd.substack.com/p/2026-predictions)

### Example 2: Booking Calendar with Disabled Dates

```typescript
// components/booking/calendar-picker.tsx
// Source: shadcn/ui Calendar documentation

'use client';

import { useState } from 'react';
import { Calendar } from '@/components/ui/calendar';
import { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover';
import { Button } from '@/components/ui/button';
import { format } from 'date-fns';
import { CalendarIcon } from 'lucide-react';

interface CalendarPickerProps {
  availableDates: Date[];
  onDateSelect: (date: Date) => void;
}

export function CalendarPicker({ availableDates, onDateSelect }: CalendarPickerProps) {
  const [selectedDate, setSelectedDate] = useState<Date | undefined>();

  // Disable dates that aren't available (no medics, past dates)
  const disabledDates = (date: Date) => {
    const isPast = date < new Date();
    const isAvailable = availableDates.some(
      (availableDate) => format(availableDate, 'yyyy-MM-dd') === format(date, 'yyyy-MM-dd')
    );
    return isPast || !isAvailable;
  };

  return (
    <Popover>
      <PopoverTrigger asChild>
        <Button variant="outline" className="w-full justify-start text-left font-normal">
          <CalendarIcon className="mr-2 h-4 w-4" />
          {selectedDate ? format(selectedDate, 'PPP') : <span>Pick a date</span>}
        </Button>
      </PopoverTrigger>
      <PopoverContent className="w-auto p-0" align="start">
        <Calendar
          mode="single"
          selected={selectedDate}
          onSelect={(date) => {
            if (date) {
              setSelectedDate(date);
              onDateSelect(date);
            }
          }}
          disabled={disabledDates}
          initialFocus
        />
      </PopoverContent>
    </Popover>
  );
}
```

**Source:** [shadcn/ui Calendar](https://ui.shadcn.com/docs/components/radix/calendar), [Date Picker with shadcn/ui](https://medium.com/@enayetflweb/adding-calendar-and-date-picker-to-your-application-with-shadcn-ui-378a0d57fc6f)

### Example 3: Pricing Breakdown Component

```typescript
// components/booking/pricing-breakdown.tsx

interface PricingBreakdownProps {
  baseRate: number;
  isUrgent: boolean;
  travelDistance: number;
}

export function PricingBreakdown({ baseRate, isUrgent, travelDistance }: PricingBreakdownProps) {
  const urgencyPremium = isUrgent ? baseRate * 0.5 : 0; // 50% premium for <24h
  const travelSurcharge = travelDistance > 10 ? 25 : 0; // £25 for >10 miles
  const subtotal = baseRate + urgencyPremium + travelSurcharge;
  const vat = subtotal * 0.20; // 20% VAT
  const total = subtotal + vat;

  return (
    <div className="bg-gray-50 rounded-lg p-4 space-y-2">
      <h3 className="font-semibold mb-3">Pricing Breakdown</h3>

      <div className="flex justify-between text-sm">
        <span>Base rate (8-hour shift)</span>
        <span>£{baseRate.toFixed(2)}</span>
      </div>

      {isUrgent && (
        <div className="flex justify-between text-sm text-orange-600">
          <span>Urgency premium (booking within 24h)</span>
          <span>+£{urgencyPremium.toFixed(2)}</span>
        </div>
      )}

      {travelSurcharge > 0 && (
        <div className="flex justify-between text-sm">
          <span>Travel surcharge (>{travelDistance} miles)</span>
          <span>+£{travelSurcharge.toFixed(2)}</span>
        </div>
      )}

      <div className="flex justify-between text-sm pt-2 border-t">
        <span>Subtotal</span>
        <span>£{subtotal.toFixed(2)}</span>
      </div>

      <div className="flex justify-between text-sm">
        <span>VAT (20%)</span>
        <span>£{vat.toFixed(2)}</span>
      </div>

      <div className="flex justify-between font-bold text-lg pt-2 border-t">
        <span>Total</span>
        <span>£{total.toFixed(2)}</span>
      </div>
    </div>
  );
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Pages Router (getServerSideProps) | App Router (Server Components) | Next.js 13+ (2022) | Simpler data fetching, better performance (streaming), no need for getServerSideProps/getStaticProps |
| Stripe Checkout Sessions (redirect) | Payment Intents + Payment Element (embedded) | Stripe v4+ (2020) | More control over UI, custom pricing logic, better UX (no redirect) |
| SendGrid for transactional email | Resend + React Email | 2023 | 6x faster setup (5 min vs 30 min), React components for emails, automatic DKIM/SPF |
| react-datepicker | shadcn/ui Calendar (react-day-picker v9) | 2024 | Better accessibility (ARIA), Radix UI primitives, matches project design system |
| Optimistic locking (version fields) | Pessimistic locking (FOR UPDATE) | Always preferred for bookings | Prevents race conditions at database level (atomic), no client-side retry logic needed |

**Deprecated/outdated:**
- **getServerSideProps/getStaticProps**: Replaced by Server Components in App Router (Next.js 13+). Use `async` functions in Server Components instead.
- **Stripe Charges API**: Deprecated in favor of Payment Intents API (better 3DS support, SCA compliance).
- **Nodemailer for calendar invites with manual SMTP**: Still works but Resend is 6x faster to setup and handles deliverability automatically.
- **Client-side only booking validation**: Race conditions inevitable. Always use database-level locking.

## Open Questions

Things that couldn't be fully resolved:

1. **Auto-matching algorithm weights**
   - What we know: Algorithm should consider distance, availability, rating, qualifications
   - What's unclear: Exact weights (e.g., is 5 miles closer worth 0.5 stars lower rating?)
   - Recommendation: Start with simple scoring (50% distance, 30% rating, 20% availability), iterate based on client feedback

2. **Recurring bookings implementation**
   - What we know: Success criteria requires recurring booking support ("same medic, weekly schedule")
   - What's unclear: Should recurring use Stripe Subscriptions API or manual booking creation?
   - Recommendation: Phase 1 - Manual (create 4 bookings for "every Monday in March"), Phase 2 - Stripe Subscriptions if demand is high

3. **Medic availability real-time updates**
   - What we know: Booking portal needs real-time availability checking
   - What's unclear: Should this use WebSockets, polling, or stale-while-revalidate pattern?
   - Recommendation: Start with Server Component (fetch on page load), add polling if booking flow >2 minutes, consider WebSockets only if high concurrency

4. **Calendar invite timezone handling**
   - What we know: UK-based business (GMT/BST), but what if client/medic travel abroad?
   - What's unclear: Should .ics files use fixed Europe/London timezone or user's local timezone?
   - Recommendation: Use Europe/London for all bookings (business operates in UK), ical-generator handles DST automatically

## Sources

### Primary (HIGH confidence)
- [Next.js Official Docs - Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components) - App Router patterns
- [Stripe Official Docs - Payment Intents vs Checkout Sessions](https://docs.stripe.com/payments/checkout-sessions-and-payment-intents-comparison) - API comparison
- [Stripe Official Docs - 3D Secure Authentication](https://docs.stripe.com/payments/3d-secure/authentication-flow) - SCA compliance
- [Resend Official Docs - Next.js Integration](https://resend.com/nextjs) - Email API setup
- [shadcn/ui Calendar](https://ui.shadcn.com/docs/components/radix/calendar) - Date picker component
- [PostgreSQL Official Docs - Explicit Locking](https://www.postgresql.org/docs/current/explicit-locking.html) - Row-level locks

### Secondary (MEDIUM confidence)
- [Next.js ISR Guide](https://nextjs.org/docs/app/guides/incremental-static-regeneration) - Static generation patterns (verified via official docs)
- [How to Solve Race Conditions in a Booking System - HackerNoon](https://hackernoon.com/how-to-solve-race-conditions-in-a-booking-system) - Double-booking prevention (verified via PostgreSQL docs)
- [PostgreSQL Row-Level Locks Guide](https://scalablearchitect.com/postgresql-row-level-locks-a-complete-guide-to-for-update-for-share-skip-locked-and-nowait/) - FOR UPDATE patterns (verified via PostgreSQL docs)
- [Resend vs SendGrid Comparison - Sequenzy](https://www.sequenzy.com/versus/resend-vs-sendgrid) - Email service comparison (2026)
- [SSR vs SSG in Next.js - ColorWhistle](https://colorwhistle.com/ssr-ssg-trends-nextjs/) - Rendering strategies (2026)

### Tertiary (LOW confidence)
- [WebSearch: React Big Calendar Next.js integration](https://github.com/lramos33/big-calendar) - Calendar UI library (if full calendar needed, not just date picker)
- [WebSearch: Nodemailer Calendar Events](https://medium.com/@thxdeadshotxht/how-to-use-static-site-generation-ssg-and-isr-with-generatestaticparams-in-next-js-app-router-41b04fe0d2bb) - Calendar attachment patterns (npm package blocked by 403)
- [WebSearch: ical-generator npm](https://www.npmjs.com/package/ical-generator) - .ics generation (verified examples on GitHub)

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - All libraries verified via official docs or npm registry (Next.js 15, Stripe 14, Resend, ical-generator)
- Architecture: HIGH - Next.js App Router patterns verified via official docs, PostgreSQL locking verified via PostgreSQL docs
- Pitfalls: HIGH - Race conditions verified via multiple sources + PostgreSQL docs, 3DS flow verified via Stripe docs, calendar attachments verified via Resend docs

**Research date:** 2026-02-15
**Valid until:** 2026-03-15 (30 days - stack is stable, but Stripe API versions change quarterly)

**Notes:**
- Project already has: Stripe integration (Deno Edge Functions), Supabase (PostgreSQL), Next.js 15, shadcn/ui, date-fns
- Missing dependencies: @stripe/stripe-js, Resend, react-email, ical-generator
- Database schema (002_business_operations.sql) already has: clients, medics, territories tables with payment_terms, stripe_customer_id
- No existing booking flow - Phase 04.5 builds from scratch
