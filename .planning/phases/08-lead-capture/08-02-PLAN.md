---
phase: 08-lead-capture
plan: 08-02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - web/app/api/contact/submit/route.ts
  - web/app/api/quotes/submit/route.ts
autonomous: true

must_haves:
  truths:
    - "Contact form submission writes to contact_submissions table BEFORE sending email"
    - "Quote form submission writes to quote_submissions table BEFORE sending email"
    - "If DB insert fails, the route returns 500 and does NOT send the email"
    - "If email fails, the route still returns success (DB write is what matters)"
    - "Both routes use service-role Supabase client, not the session-based server client"
  artifacts:
    - path: "web/app/api/contact/submit/route.ts"
      provides: "DB-first contact form persistence with fire-and-forget email"
      contains: "getServiceRoleClient"
    - path: "web/app/api/quotes/submit/route.ts"
      provides: "DB-first quote persistence with fire-and-forget email"
      contains: "getServiceRoleClient"
  key_links:
    - from: "web/app/api/contact/submit/route.ts"
      to: "contact_submissions table"
      via: "supabase.from('contact_submissions').insert()"
      pattern: "from\\('contact_submissions'\\)"
    - from: "web/app/api/quotes/submit/route.ts"
      to: "quote_submissions table"
      via: "supabase.from('quote_submissions').insert()"
      pattern: "from\\('quote_submissions'\\)"
---

<objective>
Update both public API routes (/api/contact/submit and /api/quotes/submit) to write to the database BEFORE sending email, using a service-role Supabase client.

Purpose: This is the critical persistence change. Currently leads are email-only and lost if email fails or admin inbox is missed. DB-first ensures every lead is captured.
Output: Two modified route files with DB-first, email-second pattern.
</objective>

<execution_context>
@/Users/sabineresoagli/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sabineresoagli/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-lead-capture/08-RESEARCH.md

Key references:
- Current contact route: `web/app/api/contact/submit/route.ts` (email-only, ~80 lines)
- Current quote route: `web/app/api/quotes/submit/route.ts` (email-only, ~103 lines)
- Service role pattern from research: inline `getServiceRoleClient()` function using `createClient` from `@supabase/supabase-js`
- Org ID: use `process.env.ASG_ORG_ID` server-only env var, validate it exists
</context>

<tasks>

<task id="08-02-T1" type="auto">
  <name>Add DB-first persistence to contact form route</name>
  <files>web/app/api/contact/submit/route.ts</files>
  <action>
Modify `web/app/api/contact/submit/route.ts` to insert into `contact_submissions` BEFORE sending email.

**Changes to make (preserve all existing code, add to it):**

1. Add import at top:
```typescript
import { createClient } from '@supabase/supabase-js';
```

2. Add `getServiceRoleClient()` helper function ABOVE the POST handler:
```typescript
function getServiceRoleClient() {
  const url = process.env.NEXT_PUBLIC_SUPABASE_URL;
  const key = process.env.SUPABASE_SERVICE_ROLE_KEY;
  if (!url || !key) throw new Error('Supabase service role env vars not configured');
  return createClient(url, key, {
    auth: { autoRefreshToken: false, persistSession: false },
  });
}
```

3. Inside the POST handler, AFTER the validation block (after the `if (!body.firstName...)` check) and BEFORE the `const adminEmail` line, add the DB insert:
```typescript
    // --- DB-first: persist lead before email ---
    const supabase = getServiceRoleClient();
    const orgId = process.env.ASG_ORG_ID;
    if (!orgId) {
      console.error('ASG_ORG_ID env var not configured');
      return NextResponse.json({ error: 'Server configuration error' }, { status: 500 });
    }

    const { error: dbError } = await supabase
      .from('contact_submissions')
      .insert({
        org_id: orgId,
        first_name: body.firstName,
        last_name: body.lastName,
        company: body.company,
        email: body.email,
        phone: body.phone || null,
        site_size: body.siteSize || null,
        enquiry_type: body.enquiryType,
        message: body.message || null,
        status: 'new',
      });

    if (dbError) {
      console.error('DB insert failed for contact submission:', dbError);
      return NextResponse.json({ error: 'Failed to save enquiry' }, { status: 500 });
    }
```

4. Change the email send to fire-and-forget. Replace the current `const result = await resend.emails.send(...)` block (lines ~56-69) with:
```typescript
    // Fire-and-forget email (DB write already succeeded)
    resend.emails.send({
      from: 'SiteMedic Contact <bookings@sitemedic.co.uk>',
      to: adminEmail,
      replyTo: body.email,
      subject: `New Enquiry: ${body.enquiryType} — ${body.company} (${fullName})`,
      html: emailHtml,
    }).catch((err) => {
      console.error('Email send failed (non-blocking):', err);
    });
```

5. Remove the old `if (result.error)` / `else` block that logged email success/failure since email is now fire-and-forget.

6. Update the file's JSDoc header comment — remove "No DB table required" and add "Persists to contact_submissions table, then emails admin (fire-and-forget)."

**Do NOT change:**
- The ContactRequest interface
- The validation logic
- The emailHtml template
- The `export const dynamic = 'force-dynamic'`
- The outer try/catch block
  </action>
  <verify>
1. `grep "getServiceRoleClient" web/app/api/contact/submit/route.ts` returns matches
2. `grep "contact_submissions" web/app/api/contact/submit/route.ts` returns a match
3. `grep "fire-and-forget\|non-blocking" web/app/api/contact/submit/route.ts` returns a match
4. `grep "ASG_ORG_ID" web/app/api/contact/submit/route.ts` returns a match
5. Run `pnpm --filter web build 2>&1 | tail -5` to confirm no TypeScript errors (or at minimum `npx tsc --noEmit --project web/tsconfig.json 2>&1 | grep "route.ts"`)
  </verify>
  <done>Contact route inserts to DB first, returns 500 on DB failure, sends email as fire-and-forget after successful DB write.</done>
</task>

<task id="08-02-T2" type="auto">
  <name>Add DB-first persistence to quote submission route</name>
  <files>web/app/api/quotes/submit/route.ts</files>
  <action>
Modify `web/app/api/quotes/submit/route.ts` to insert into `quote_submissions` BEFORE sending email.

**Changes to make (preserve all existing code, add to it):**

1. Add import at top:
```typescript
import { createClient } from '@supabase/supabase-js';
```

2. Fix the `QuoteSubmitRequest` interface — add the missing `coordinates` field:
```typescript
interface QuoteSubmitRequest {
  workerCount: string;
  projectType: string;
  medicCount: string;
  duration: string;        // Dead field — always empty, do NOT persist
  durationKnown: string;
  estimatedDuration: string;
  location: string;        // Dead field — always empty, do NOT persist
  siteAddress: string;
  coordinates?: string;    // NEW — was missing from interface
  what3wordsAddress?: string;
  startDate: string;
  endDate: string;
  projectPhase: string;
  specialRequirements: string[];
  name: string;
  email: string;
  phone: string;
  company: string;
}
```

3. Add `getServiceRoleClient()` helper function ABOVE the POST handler (same as contact route):
```typescript
function getServiceRoleClient() {
  const url = process.env.NEXT_PUBLIC_SUPABASE_URL;
  const key = process.env.SUPABASE_SERVICE_ROLE_KEY;
  if (!url || !key) throw new Error('Supabase service role env vars not configured');
  return createClient(url, key, {
    auth: { autoRefreshToken: false, persistSession: false },
  });
}
```

4. Inside the POST handler, AFTER the `const quoteRef = ...` line and BEFORE the `const adminEmail` line, add the DB insert:
```typescript
    // --- DB-first: persist quote before email ---
    const supabase = getServiceRoleClient();
    const orgId = process.env.ASG_ORG_ID;
    if (!orgId) {
      console.error('ASG_ORG_ID env var not configured');
      return NextResponse.json({ error: 'Server configuration error' }, { status: 500 });
    }

    const { error: dbError } = await supabase
      .from('quote_submissions')
      .insert({
        org_id: orgId,
        quote_ref: quoteRef,
        name: body.name,
        email: body.email,
        phone: body.phone,
        company: body.company || null,
        worker_count: body.workerCount || null,
        project_type: body.projectType || null,
        medic_count: body.medicCount || null,
        duration_known: body.durationKnown || null,
        estimated_duration: body.estimatedDuration || null,
        site_address: body.siteAddress || null,
        coordinates: body.coordinates || null,
        what3words_address: body.what3wordsAddress || null,
        start_date: body.startDate || null,
        end_date: body.endDate || null,
        project_phase: body.projectPhase || null,
        special_requirements: body.specialRequirements?.length ? body.specialRequirements : null,
        calculated_price: null,  // Price calculation is client-side only; null for now
        status: 'new',
      });

    if (dbError) {
      console.error('DB insert failed for quote submission:', dbError);
      return NextResponse.json({ error: 'Failed to save quote' }, { status: 500 });
    }
```

IMPORTANT:
- Do NOT persist `body.duration` (dead field, always '1-day' default)
- Do NOT persist `body.location` (dead field, always empty string)
- Pass `body.specialRequirements` as a JS array directly — do NOT JSON.stringify it
- Pass `calculated_price: null` (accurate client-side price not available server-side; admin can see quote details)

5. Change the email send to fire-and-forget. Replace the current `const result = await resend.emails.send(...)` block with:
```typescript
    // Fire-and-forget email (DB write already succeeded)
    resend.emails.send({
      from: 'SiteMedic Quotes <bookings@sitemedic.co.uk>',
      to: adminEmail,
      replyTo: body.email,
      subject: `New Quote Request ${quoteRef} — ${body.company || body.name}`,
      html: emailHtml,
    }).catch((err) => {
      console.error('Email send failed (non-blocking):', err);
    });
```

6. Remove the old `if (result.error)` block.

7. Update the file's JSDoc header — remove "No DB table required" and add "Persists to quote_submissions table, then emails admin (fire-and-forget)."

**Do NOT change:**
- The validation logic
- The quoteRef generation logic
- The emailHtml template
- The response format (`{ success: true, quoteRef }`)
- The `export const dynamic = 'force-dynamic'`
  </action>
  <verify>
1. `grep "getServiceRoleClient" web/app/api/quotes/submit/route.ts` returns matches
2. `grep "quote_submissions" web/app/api/quotes/submit/route.ts` returns a match
3. `grep "coordinates" web/app/api/quotes/submit/route.ts` returns matches (interface + insert)
4. `grep -c "body.location\|body.duration" web/app/api/quotes/submit/route.ts` — confirm `location` and `duration` are NOT in the insert block (only in emailHtml which is unchanged)
5. Run `pnpm --filter web build 2>&1 | tail -5` to confirm no TypeScript errors
  </verify>
  <done>Quote route inserts to DB first with all relevant fields (excluding dead location/duration), returns 500 on DB failure, sends email as fire-and-forget. QuoteSubmitRequest interface now includes coordinates field.</done>
</task>

</tasks>

<verification>
1. Both routes compile without TypeScript errors
2. `grep -c "getServiceRoleClient" web/app/api/contact/submit/route.ts web/app/api/quotes/submit/route.ts` — both return at least 1
3. `grep "from('contact_submissions')" web/app/api/contact/submit/route.ts` — confirms DB write
4. `grep "from('quote_submissions')" web/app/api/quotes/submit/route.ts` — confirms DB write
5. Neither route has `await resend.emails.send` (email is fire-and-forget, no await on the send call itself)
6. Both routes check `process.env.ASG_ORG_ID` and return 500 if missing
</verification>

<success_criteria>
- Contact form POST writes to contact_submissions BEFORE email, returns 500 on DB failure
- Quote form POST writes to quote_submissions BEFORE email, returns 500 on DB failure
- Email is fire-and-forget (.catch() logs error, does not block response)
- Dead fields (location, duration) are NOT persisted to quote_submissions
- coordinates field added to QuoteSubmitRequest interface
- Both routes use service-role client (not session-based server client)
- Both routes validate ASG_ORG_ID env var exists
</success_criteria>

<output>
After completion, create `.planning/phases/08-lead-capture/08-02-SUMMARY.md`
</output>
