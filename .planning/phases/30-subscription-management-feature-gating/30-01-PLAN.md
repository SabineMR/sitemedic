---
phase: 30-subscription-management-feature-gating
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - web/components/billing/tier-gate.tsx
  - web/components/billing/upgrade-prompt.tsx
  - web/lib/billing/require-tier.ts
autonomous: true

must_haves:
  truths:
    - "TierGate component renders children when org has sufficient tier"
    - "TierGate component renders UpgradePrompt when org tier is insufficient"
    - "requireTier() throws TIER_INSUFFICIENT error for insufficient tiers"
    - "requireTier() returns the tier when access is granted"
  artifacts:
    - path: "web/components/billing/tier-gate.tsx"
      provides: "TierGate client component"
      exports: ["TierGate"]
    - path: "web/components/billing/upgrade-prompt.tsx"
      provides: "UpgradePrompt client component with contextual messaging"
      exports: ["UpgradePrompt"]
    - path: "web/lib/billing/require-tier.ts"
      provides: "Server-side API route gating helper"
      exports: ["requireTier"]
  key_links:
    - from: "web/components/billing/tier-gate.tsx"
      to: "web/lib/billing/feature-gates.ts"
      via: "hasFeature() import"
      pattern: "import.*hasFeature.*feature-gates"
    - from: "web/lib/billing/require-tier.ts"
      to: "web/lib/billing/feature-gates.ts"
      via: "hasFeature() import"
      pattern: "import.*hasFeature.*feature-gates"
    - from: "web/lib/billing/require-tier.ts"
      to: "web/lib/organizations/org-resolver.ts"
      via: "requireOrgId() import"
      pattern: "import.*requireOrgId.*org-resolver"
---

<objective>
Create the TierGate UI component and requireTier() API helper -- the two enforcement primitives that all downstream feature gating depends on.

Purpose: These are the shared building blocks for GATE-03 (dual UI+API enforcement) and GATE-04 (contextual upgrade prompts). Every gated page wraps content in `<TierGate>`, every gated API route calls `requireTier()`.

Output: Three new files -- TierGate.tsx, UpgradePrompt.tsx, require-tier.ts
</objective>

<execution_context>
@/Users/sabineresoagli/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sabineresoagli/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/30-subscription-management-feature-gating/30-RESEARCH.md

@web/lib/billing/feature-gates.ts
@web/lib/organizations/org-resolver.ts
@web/lib/supabase/server.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create UpgradePrompt component and TierGate wrapper</name>
  <files>web/components/billing/upgrade-prompt.tsx, web/components/billing/tier-gate.tsx</files>
  <action>
Create `web/components/billing/upgrade-prompt.tsx`:
- 'use client' directive
- Import `FeatureKey`, `SubscriptionTier` from `@/lib/billing/feature-gates`
- Import `Sparkles`, `ArrowRight` from `lucide-react`
- Export `FEATURE_DISPLAY_NAMES` record mapping all 12 FeatureKey values to human-readable names (e.g., 'white_label' -> 'White-Label Branding', 'subdomain' -> 'Custom Subdomain', 'advanced_analytics' -> 'Advanced Analytics', etc.)
- Export `FEATURE_REQUIRED_TIER` partial record mapping Growth+ and Enterprise features to their required tier (white_label/subdomain/advanced_analytics -> 'growth', custom_domain/api_access/priority_support -> 'enterprise')
- Interface `UpgradePromptProps`: feature (FeatureKey), currentTier (SubscriptionTier | null), optional message (string)
- Component renders a gradient card (dark blue/purple) with:
  - Sparkles icon in a bordered circle
  - Heading: "{featureName} is a {TierDisplayName} Feature"
  - Description: custom message or default "Upgrade to the {tierName} plan to unlock {featureName} and more."
  - CTA button linking to `/admin/settings#billing` with ArrowRight icon: "Upgrade to {TierName}"
- Use the same styling pattern from the research (bg-gradient-to-br from-blue-900/30 to-purple-900/30, border border-blue-700/50, rounded-2xl, etc.)

Create `web/components/billing/tier-gate.tsx`:
- 'use client' directive
- Import `hasFeature`, `FeatureKey`, `SubscriptionTier` from `@/lib/billing/feature-gates`
- Import `UpgradePrompt` from `./upgrade-prompt`
- Interface `TierGateProps`: feature (FeatureKey), tier (SubscriptionTier | null), children (React.ReactNode), optional upgradeMessage (string)
- If `hasFeature(tier, feature)` returns true, render children
- Otherwise render `<UpgradePrompt>` with the feature, currentTier, and optional message
  </action>
  <verify>
Run `pnpm tsc --noEmit` from the web directory to verify TypeScript compilation passes with no errors in the new files.
  </verify>
  <done>TierGate component conditionally renders children or UpgradePrompt based on hasFeature() check. All type imports resolve correctly.</done>
</task>

<task type="auto">
  <name>Task 2: Create requireTier() server-side API helper</name>
  <files>web/lib/billing/require-tier.ts</files>
  <action>
Create `web/lib/billing/require-tier.ts`:
- Import `createClient` from `@/lib/supabase/server`
- Import `requireOrgId` from `@/lib/organizations/org-resolver`
- Import `hasFeature`, `FeatureKey`, `SubscriptionTier` from `./feature-gates`
- Export async function `requireTier(feature: FeatureKey): Promise<SubscriptionTier>`:
  1. Call `requireOrgId()` to get orgId (throws if not authenticated)
  2. Create Supabase server client
  3. Query `organizations` table: `.select('subscription_tier').eq('id', orgId).single()`
  4. Extract tier, defaulting to 'starter' if null: `const tier: SubscriptionTier = (org?.subscription_tier as SubscriptionTier) ?? 'starter'`
  5. If `!hasFeature(tier, feature)`, throw `new Error('TIER_INSUFFICIENT')`
  6. Return tier

Add JSDoc comment explaining:
- This is the server-side counterpart to the TierGate client component
- Every API route serving Growth/Enterprise-only data must call this
- Usage pattern: wrap in try/catch, check for TIER_INSUFFICIENT error message, return 403

Do NOT use NextResponse in this file -- it is a pure utility. The API route handler wraps it in try/catch and returns the appropriate response.
  </action>
  <verify>
Run `pnpm tsc --noEmit` from the web directory to verify TypeScript compilation passes.
  </verify>
  <done>requireTier() helper exists, imports compile correctly, throws TIER_INSUFFICIENT for insufficient tiers, returns tier on success.</done>
</task>

</tasks>

<verification>
- `pnpm tsc --noEmit` passes in the web workspace
- `web/components/billing/tier-gate.tsx` exports TierGate
- `web/components/billing/upgrade-prompt.tsx` exports UpgradePrompt, FEATURE_DISPLAY_NAMES, FEATURE_REQUIRED_TIER
- `web/lib/billing/require-tier.ts` exports requireTier
- All imports resolve to existing modules (feature-gates.ts, org-resolver.ts, supabase/server.ts)
</verification>

<success_criteria>
- TierGate renders children when hasFeature returns true
- TierGate renders UpgradePrompt when hasFeature returns false
- requireTier() reads org tier from DB and throws TIER_INSUFFICIENT for insufficient tiers
- All 12 feature keys have human-readable display names in FEATURE_DISPLAY_NAMES
- No new dependencies needed (uses existing lucide-react, @supabase/ssr)
</success_criteria>

<output>
After completion, create `.planning/phases/30-subscription-management-feature-gating/30-01-SUMMARY.md`
</output>
