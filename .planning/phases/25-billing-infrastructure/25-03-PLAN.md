---
phase: 25-billing-infrastructure
plan: 03
type: execute
wave: 2
depends_on: ["25-01"]
files_modified:
  - supabase/migrations/135_webhook_events.sql
  - web/app/api/stripe/billing-webhooks/route.ts
autonomous: true

must_haves:
  truths:
    - "A Stripe checkout.session.completed event writes correct stripe_customer_id, stripe_subscription_id, subscription_tier, and subscription_status to the organizations table"
    - "A Stripe customer.subscription.updated event updates subscription_tier and subscription_status on the correct org row"
    - "A Stripe customer.subscription.deleted event sets subscription_status to 'cancelled' (British spelling)"
    - "Duplicate Stripe events are silently ignored (idempotency via webhook_events UNIQUE constraint)"
    - "The existing Connect webhook endpoint at /api/stripe/webhooks is completely untouched"
    - "invoice.payment_failed is logged but does NOT change subscription_status"
  artifacts:
    - path: "supabase/migrations/135_webhook_events.sql"
      provides: "webhook_events table with UNIQUE constraint on stripe_event_id, RLS for platform admin read"
      contains: "CREATE TABLE webhook_events"
    - path: "web/app/api/stripe/billing-webhooks/route.ts"
      provides: "POST handler for Stripe billing webhook events"
      exports: ["POST"]
      min_lines: 120
  key_links:
    - from: "web/app/api/stripe/billing-webhooks/route.ts"
      to: "process.env.STRIPE_BILLING_WEBHOOK_SECRET"
      via: "stripe.webhooks.constructEvent() signature verification"
      pattern: "STRIPE_BILLING_WEBHOOK_SECRET"
    - from: "web/app/api/stripe/billing-webhooks/route.ts"
      to: "organizations table"
      via: "service-role Supabase client UPDATE"
      pattern: "supabase.*from.*organizations.*update"
    - from: "web/app/api/stripe/billing-webhooks/route.ts"
      to: "webhook_events table"
      via: "service-role Supabase client INSERT for idempotency"
      pattern: "supabase.*from.*webhook_events.*insert"
    - from: "web/app/api/stripe/billing-webhooks/route.ts"
      to: "web/lib/stripe/server.ts"
      via: "import { stripe } from '@/lib/stripe/server'"
      pattern: "import.*stripe.*from.*@/lib/stripe/server"
---

<objective>
Create the billing webhook handler at /api/stripe/billing-webhooks and the webhook_events migration table. The handler processes subscription lifecycle events (checkout.session.completed, customer.subscription.updated, customer.subscription.deleted, invoice.payment_failed) and writes to the organizations table using a service-role Supabase client.

Purpose: This endpoint must be deployed and receiving events before any org completes Stripe Checkout (Phase 29). If the handler does not exist when checkout.session.completed fires, the org's subscription state is never written to the database.

Output: Migration 135 (webhook_events table) and the billing webhook route handler.
</objective>

<execution_context>
@/Users/sabineresoagli/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sabineresoagli/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-billing-infrastructure/25-RESEARCH.md
@.planning/phases/25-billing-infrastructure/25-CONTEXT.md

# Existing patterns to clone
@web/app/api/stripe/webhooks/route.ts
@web/lib/stripe/server.ts
@web/app/api/contracts/webhooks/route.ts
@supabase/migrations/133_subscription_columns.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create webhook_events migration (135)</name>
  <files>supabase/migrations/135_webhook_events.sql</files>
  <action>
Create `supabase/migrations/135_webhook_events.sql` with the following structure:

**Table: webhook_events**
```sql
CREATE TABLE webhook_events (
  id                UUID        PRIMARY KEY DEFAULT uuid_generate_v4(),
  stripe_event_id   TEXT        NOT NULL UNIQUE,  -- Stripe event ID (evt_xxx) for idempotency
  event_type        TEXT        NOT NULL,          -- e.g. 'checkout.session.completed'
  event_data        JSONB,                         -- Full event.data.object payload
  processing_error  TEXT,                          -- Error message if processing failed
  created_at        TIMESTAMPTZ NOT NULL,          -- Stripe event created timestamp
  processed_at      TIMESTAMPTZ DEFAULT NOW()      -- When we received/processed it
);
```

**Indexes:**
- `idx_webhook_events_type ON webhook_events (event_type)` -- for filtering by event type in platform admin dashboard
- `idx_webhook_events_created ON webhook_events (created_at)` -- for chronological queries

**RLS:**
- Enable RLS on the table
- CREATE POLICY "Platform admins can view webhook events" ON webhook_events FOR SELECT USING (is_platform_admin())
- No INSERT/UPDATE/DELETE policies for authenticated users -- the webhook handler uses service-role which bypasses RLS

**Also add subscription_status_updated_at column to organizations:**
```sql
ALTER TABLE organizations
  ADD COLUMN IF NOT EXISTS subscription_status_updated_at TIMESTAMPTZ DEFAULT NULL;

COMMENT ON COLUMN organizations.subscription_status_updated_at IS
  'Timestamp of the Stripe event that last changed subscription_status. '
  'Used for out-of-order webhook event protection -- only events newer than this timestamp can update status.';
```

Add clear header comments explaining purpose, why UNIQUE on stripe_event_id (idempotency), and why no INSERT RLS policy (service-role bypasses).
  </action>
  <verify>
1. Read the migration file and verify:
   - webhook_events table has all 6 columns
   - UNIQUE constraint on stripe_event_id
   - Two indexes exist
   - RLS enabled with platform admin SELECT policy
   - subscription_status_updated_at column added to organizations
2. The SQL syntax is valid (no obvious errors)
  </verify>
  <done>
- supabase/migrations/135_webhook_events.sql exists
- webhook_events table defined with UNIQUE stripe_event_id constraint
- Platform admin SELECT RLS policy in place
- organizations table gains subscription_status_updated_at column
- Migration number is 135 (follows 134_org_logos_bucket.sql)
  </done>
</task>

<task type="auto">
  <name>Task 2: Create billing webhook route handler</name>
  <files>web/app/api/stripe/billing-webhooks/route.ts</files>
  <action>
Create `web/app/api/stripe/billing-webhooks/route.ts` by cloning the pattern from the existing Connect webhook handler at `web/app/api/stripe/webhooks/route.ts`.

**Route configuration:**
```typescript
export const dynamic = 'force-dynamic';
export const runtime = 'nodejs';
```

**Service-role Supabase client** (same pattern as contracts/webhooks/route.ts):
```typescript
import { createClient } from '@supabase/supabase-js';

function getAdminClient() {
  const url = process.env.NEXT_PUBLIC_SUPABASE_URL;
  const key = process.env.SUPABASE_SERVICE_ROLE_KEY;
  if (!url || !key) throw new Error('Supabase service role env vars not configured');
  return createClient(url, key, {
    auth: { autoRefreshToken: false, persistSession: false },
  });
}
```

**POST handler flow:**
1. `await request.text()` for raw body (NOT request.json() -- breaks signature verification)
2. Get `stripe-signature` header
3. `stripe.webhooks.constructEvent(body, signature, process.env.STRIPE_BILLING_WEBHOOK_SECRET!)` -- CRITICAL: use STRIPE_BILLING_WEBHOOK_SECRET, NOT STRIPE_WEBHOOK_SECRET
4. Log event to webhook_events table (INSERT with stripe_event_id, event_type, event_data, created_at)
5. If INSERT fails with code '23505' (unique violation), log "Duplicate event" and return 200 -- this is the idempotency mechanism
6. Switch on event.type and call handler functions
7. Return `{ received: true }` with 200

**Event handlers:**

**handleCheckoutComplete(supabase, event):**
- Cast `event.data.object as Stripe.Checkout.Session`
- Extract customerId (handle string | object), subscriptionId, orgId from session.metadata
- If any missing, log error and return (Phase 29 will set metadata during session creation)
- Call `stripe.subscriptions.retrieve(subscriptionId)` to get price ID
- Call `priceIdToTier(priceId)` to determine tier
- UPDATE organizations SET stripe_customer_id, stripe_subscription_id, subscription_tier, subscription_status='active', subscription_status_updated_at WHERE id = orgId
- On error, UPDATE webhook_events SET processing_error WHERE stripe_event_id = event.id

**handleSubscriptionUpdated(supabase, event):**
- Cast `event.data.object as Stripe.Subscription`
- Extract customerId
- Get priceId from subscription.items.data[0]?.price?.id
- Call priceIdToTier(priceId) for new tier
- Call normalizeSubscriptionStatus(subscription.status) for new status
- **Out-of-order protection:** Compare event.created (Unix timestamp) against the org's subscription_status_updated_at. Only proceed if event is newer:
  ```typescript
  const eventTimestamp = new Date(event.created * 1000).toISOString();
  // Use a conditional update: only apply if event is newer
  ```
  Use a Supabase .update() with a .or() filter or handle via application logic: fetch current org, compare timestamps, then update if newer.
- UPDATE organizations SET subscription_tier, subscription_status, subscription_status_updated_at WHERE stripe_customer_id = customerId
- CRITICAL: normalizeSubscriptionStatus must map Stripe's 'canceled' (American, one L) to database's 'cancelled' (British, two Ls) per migration 133 CHECK constraint

**handleSubscriptionDeleted(supabase, event):**
- Cast `event.data.object as Stripe.Subscription`
- Extract customerId
- UPDATE organizations SET subscription_status = 'cancelled', subscription_status_updated_at WHERE stripe_customer_id = customerId
- NOTE: subscription_tier is PRESERVED (data hidden, not deleted per CONTEXT.md decision)

**handlePaymentFailed(supabase, event):**
- Cast `event.data.object as Stripe.Invoice`
- Extract customerId
- Log warning with customerId and invoiceId
- Do NOT change subscription_status (wait for customer.subscription.updated with status: 'past_due' per Stripe best practice and RESEARCH.md Pitfall 5)
- Add a comment: "// Future Phase 30: Add platform admin dashboard alert here"

**Helper functions:**

**priceIdToTier(priceId: string | undefined): SubscriptionTier | null**
- Parse comma-separated price IDs from STRIPE_PRICE_STARTER, STRIPE_PRICE_GROWTH, STRIPE_PRICE_ENTERPRISE env vars
- Return 'starter', 'growth', or 'enterprise' if priceId matches
- Log error and return null if no match
- Import SubscriptionTier from '@/lib/billing/feature-gates'

**normalizeSubscriptionStatus(stripeStatus: string): 'active' | 'past_due' | 'cancelled' | null**
- 'active' -> 'active'
- 'past_due' -> 'past_due'
- 'canceled' -> 'cancelled' (US -> UK spelling normalization)
- All other statuses (incomplete, trialing, etc.) -> null (don't update)

**Imports:**
- `import { stripe } from '@/lib/stripe/server';` (existing)
- `import { createClient } from '@supabase/supabase-js';` (direct import, not the auth-aware one)
- `import Stripe from 'stripe';` (for types)
- `import type { SubscriptionTier } from '@/lib/billing/feature-gates';` (type-only import for priceIdToTier return type)

**DO NOT:**
- Touch the existing Connect webhook at web/app/api/stripe/webhooks/route.ts
- Use request.json() instead of request.text()
- Use STRIPE_WEBHOOK_SECRET instead of STRIPE_BILLING_WEBHOOK_SECRET
- Store tier in JWT claims
- Change subscription_status on invoice.payment_failed events
  </action>
  <verify>
1. Run `pnpm --filter web exec tsc --noEmit` -- no TypeScript errors
2. Read the file and confirm:
   - Uses STRIPE_BILLING_WEBHOOK_SECRET (not STRIPE_WEBHOOK_SECRET)
   - Uses request.text() (not request.json())
   - Uses service-role createClient from @supabase/supabase-js (not auth-aware client)
   - normalizeSubscriptionStatus maps 'canceled' to 'cancelled'
   - handlePaymentFailed does NOT update subscription_status
   - handleSubscriptionDeleted preserves subscription_tier
   - webhook_events INSERT for idempotency with 23505 duplicate handling
3. Verify the existing Connect webhook route.ts is unchanged:
   `git diff web/app/api/stripe/webhooks/route.ts` should show no changes
  </verify>
  <done>
- web/app/api/stripe/billing-webhooks/route.ts exists with POST handler
- Handles 4 event types: checkout.session.completed, customer.subscription.updated, customer.subscription.deleted, invoice.payment_failed
- Uses STRIPE_BILLING_WEBHOOK_SECRET for signature verification
- Service-role Supabase client for RLS-bypassing writes
- Idempotency via webhook_events UNIQUE constraint (23505 duplicate check)
- Stripe 'canceled' normalized to database 'cancelled'
- Out-of-order protection via subscription_status_updated_at timestamp comparison
- Existing Connect webhook completely untouched
- TypeScript compiles without errors
  </done>
</task>

</tasks>

<verification>
1. `pnpm --filter web exec tsc --noEmit` passes
2. supabase/migrations/135_webhook_events.sql exists with correct table definition
3. web/app/api/stripe/billing-webhooks/route.ts exists with POST handler
4. The handler uses STRIPE_BILLING_WEBHOOK_SECRET (grep confirms)
5. The handler uses request.text() not request.json() (grep confirms)
6. normalizeSubscriptionStatus maps 'canceled' -> 'cancelled' (grep confirms)
7. `git diff web/app/api/stripe/webhooks/route.ts` shows no changes (Connect webhook untouched)
8. The file imports SubscriptionTier from '@/lib/billing/feature-gates' (wired to 25-02 output)
</verification>

<success_criteria>
- Billing webhook handler deployed at /api/stripe/billing-webhooks
- webhook_events migration ready to apply (135_webhook_events.sql)
- checkout.session.completed writes stripe_customer_id, stripe_subscription_id, subscription_tier, subscription_status to organizations
- customer.subscription.updated updates tier and status with spelling normalization
- customer.subscription.deleted sets status to 'cancelled' while preserving tier
- invoice.payment_failed logged but does not change subscription_status
- Duplicate events silently ignored via UNIQUE constraint
- Existing Connect webhook endpoint completely untouched
</success_criteria>

<output>
After completion, create `.planning/phases/25-billing-infrastructure/25-03-SUMMARY.md`
</output>
