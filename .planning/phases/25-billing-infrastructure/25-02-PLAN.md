---
phase: 25-billing-infrastructure
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - web/lib/billing/feature-gates.ts
autonomous: true

must_haves:
  truths:
    - "hasFeature('starter', 'white_label') returns false"
    - "hasFeature('growth', 'white_label') returns true"
    - "hasFeature('enterprise', 'white_label') returns true"
    - "hasFeature(null, 'dashboard') returns true (legacy orgs get starter access)"
    - "isAtLeastTier('starter', 'growth') returns false"
    - "isAtLeastTier('growth', 'growth') returns true"
    - "FEATURE_GATES is the sole source of truth for tier gating"
  artifacts:
    - path: "web/lib/billing/feature-gates.ts"
      provides: "FEATURE_GATES constant, hasFeature() helper, isAtLeastTier() helper, SubscriptionTier type, FeatureKey type"
      exports: ["TIERS", "FEATURES", "FEATURE_GATES", "hasFeature", "getTierFeatures", "isAtLeastTier"]
      min_lines: 60
  key_links:
    - from: "web/lib/billing/feature-gates.ts"
      to: "organizations.subscription_tier column"
      via: "SubscriptionTier type matches CHECK constraint values"
      pattern: "starter.*growth.*enterprise"
---

<objective>
Create the FEATURE_GATES constant and hasFeature() helper as the single source of truth for tier-based feature gating across the entire application.

Purpose: Every downstream phase (27, 28, 29, 30, 31) that checks tier access will import from this module. It must exist before any gating logic is written. The type system enforces that only valid tiers and feature keys are used.

Output: web/lib/billing/feature-gates.ts with typed constants and helper functions.
</objective>

<execution_context>
@/Users/sabineresoagli/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sabineresoagli/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-billing-infrastructure/25-RESEARCH.md
@.planning/phases/25-billing-infrastructure/25-CONTEXT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create feature-gates.ts with FEATURE_GATES constant and helper functions</name>
  <files>web/lib/billing/feature-gates.ts</files>
  <action>
Create `web/lib/billing/feature-gates.ts` with the following structure. Create the `web/lib/billing/` directory if it does not exist.

**Types:**
- `TIERS = ['starter', 'growth', 'enterprise'] as const`
- `type SubscriptionTier = typeof TIERS[number]`
- `FEATURES` array with all feature keys as const
- `type FeatureKey = typeof FEATURES[number]`

**Feature Keys (from RESEARCH.md tier matrix):**
- All tiers: `dashboard`, `treatment_logs`, `worker_registry`, `weekly_reports`, `compliance`, `basic_analytics`
- Growth+: `white_label`, `subdomain`, `advanced_analytics`
- Enterprise: `custom_domain`, `api_access`, `priority_support`

**FEATURE_GATES constant:**
- Type: `Record<SubscriptionTier, ReadonlySet<FeatureKey>>`
- Each tier maps to a `new Set([...])` of its feature keys
- Growth includes all Starter features plus Growth-specific
- Enterprise includes all Growth features plus Enterprise-specific

**Helper functions:**

1. `hasFeature(tier: SubscriptionTier | null, feature: FeatureKey): boolean`
   - NULL tier defaults to 'starter' (legacy orgs get starter access per Phase 24 decision)
   - Returns true if the tier's feature set includes the feature

2. `getTierFeatures(tier: SubscriptionTier): ReadonlySet<FeatureKey>`
   - Returns the full feature set for a tier

3. `isAtLeastTier(currentTier: SubscriptionTier | null, minimumTier: SubscriptionTier): boolean`
   - Compares tiers using numeric ordering: starter=0, growth=1, enterprise=2
   - NULL tier defaults to 'starter'
   - Returns true if current >= minimum

**Important:**
- Add JSDoc comments on all exports explaining their purpose and the "sole source of truth" contract
- Use `as const satisfies` pattern for maximum type safety where applicable
- Do NOT use `any` types anywhere
- The SubscriptionTier values MUST exactly match the CHECK constraint values in migration 133: 'starter' | 'growth' | 'enterprise'
  </action>
  <verify>
1. Run `pnpm --filter web exec tsc --noEmit` from the project root -- no TypeScript errors
2. Read the file and verify:
   - FEATURE_GATES has exactly 3 keys (starter, growth, enterprise)
   - Starter set has 6 features
   - Growth set has 9 features (6 + 3)
   - Enterprise set has 12 features (9 + 3)
   - hasFeature(null, 'dashboard') would return true (starter default)
   - hasFeature('starter', 'white_label') would return false
   - hasFeature('growth', 'white_label') would return true
  </verify>
  <done>
- web/lib/billing/feature-gates.ts exists with FEATURE_GATES constant, hasFeature(), getTierFeatures(), and isAtLeastTier() exported
- TypeScript compiles without errors
- hasFeature('starter', 'white_label') returns false
- hasFeature('growth', 'white_label') returns true
- NULL tier defaults to 'starter' access
- SubscriptionTier type matches database CHECK constraint values exactly
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify feature gates with inline TypeScript assertions</name>
  <files>web/lib/billing/feature-gates.ts</files>
  <action>
After creating the feature-gates module, add a verification block at the bottom of the file (inside a `if (process.env.NODE_ENV === 'test')` block or as a compile-time assertion) that validates the tier matrix is internally consistent:

1. Every feature in the Growth set must also be in the Enterprise set (superset invariant)
2. Every feature in the Starter set must also be in the Growth set (superset invariant)
3. The FEATURES array must contain exactly the union of all features in FEATURE_GATES

Use TypeScript compile-time assertions where possible. For runtime checks, wrap in a development-only block.

Also run a quick check: import the module in a Node.js one-liner to confirm all exports are accessible:
```bash
cd web && npx tsx -e "const fg = require('./lib/billing/feature-gates'); console.log('hasFeature starter/white_label:', fg.hasFeature('starter', 'white_label')); console.log('hasFeature growth/white_label:', fg.hasFeature('growth', 'white_label')); console.log('isAtLeastTier growth/growth:', fg.isAtLeastTier('growth', 'growth')); console.log('isAtLeastTier starter/growth:', fg.isAtLeastTier('starter', 'growth'));"
```

Expected output:
- hasFeature starter/white_label: false
- hasFeature growth/white_label: true
- isAtLeastTier growth/growth: true
- isAtLeastTier starter/growth: false
  </action>
  <verify>
1. The tsx one-liner runs without errors and outputs the expected boolean values
2. `pnpm --filter web exec tsc --noEmit` still passes
  </verify>
  <done>
- hasFeature('starter', 'white_label') returns false (confirmed by runtime check)
- hasFeature('growth', 'white_label') returns true (confirmed by runtime check)
- isAtLeastTier('growth', 'growth') returns true (confirmed by runtime check)
- isAtLeastTier('starter', 'growth') returns false (confirmed by runtime check)
- Superset invariant verified (Starter subset of Growth subset of Enterprise)
  </done>
</task>

</tasks>

<verification>
1. `pnpm --filter web exec tsc --noEmit` passes with no errors
2. The module exports: TIERS, FEATURES, FEATURE_GATES, hasFeature, getTierFeatures, isAtLeastTier
3. hasFeature('starter', 'white_label') === false
4. hasFeature('growth', 'white_label') === true
5. hasFeature('enterprise', 'white_label') === true
6. hasFeature(null, 'dashboard') === true
7. isAtLeastTier('starter', 'growth') === false
8. isAtLeastTier('growth', 'growth') === true
</verification>

<success_criteria>
- FEATURE_GATES constant is the sole source of truth for tier gating
- All 12 feature keys are defined with correct tier assignments
- hasFeature() handles null tier (defaults to starter)
- isAtLeastTier() correctly compares tier hierarchy
- TypeScript types enforce valid tier and feature key usage at compile time
- No dependencies on external services -- pure TypeScript module
</success_criteria>

<output>
After completion, create `.planning/phases/25-billing-infrastructure/25-02-SUMMARY.md`
</output>
