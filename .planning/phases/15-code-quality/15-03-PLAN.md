---
phase: 15-code-quality
plan: 03
type: execute
wave: 2
depends_on: ["15-01"]
files_modified:
  - web/app/api/bookings/match/route.ts
  - web/components/admin/booking-detail-panel.tsx
autonomous: true

must_haves:
  truths:
    - "Admin can manually assign a specific medic to an unmatched booking"
    - "Manual assignment triggers the email notification chain (same as auto-match)"
    - "Medic selector shows only available medics sorted by star rating"
    - "Assignment dialog only appears when booking has no medic or requires manual approval"
  artifacts:
    - path: "web/app/api/bookings/match/route.ts"
      provides: "Match endpoint with optional overrideMedicId parameter"
      contains: "overrideMedicId"
    - path: "web/components/admin/booking-detail-panel.tsx"
      provides: "Booking detail panel with Assign Medic Manually button and dialog"
      contains: "Assign Medic"
  key_links:
    - from: "web/components/admin/booking-detail-panel.tsx"
      to: "/api/bookings/match"
      via: "fetch POST with overrideMedicId"
      pattern: "fetch.*api/bookings/match.*overrideMedicId"
    - from: "web/components/admin/booking-detail-panel.tsx"
      to: "web/lib/queries/admin/bookings.ts"
      via: "useAvailableMedics hook"
      pattern: "useAvailableMedics"
---

<objective>
Add manual medic assignment to the admin booking detail panel via the match endpoint.

Purpose: When auto-assignment fails or returns `requires_manual_approval`, admins currently have no way to manually assign a medic through the proper channel (which triggers email notifications). The existing "Reassign Medic" in the table does a raw DB update with no email. This plan extends `/api/bookings/match` to accept an optional `overrideMedicId` and adds an "Assign Medic Manually" button + dialog to the BookingDetailPanel.
Output: Match endpoint extended with manual override path. Booking detail panel gains assign dialog.
</objective>

<execution_context>
@/Users/sabineresoagli/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sabineresoagli/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-code-quality/15-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend /api/bookings/match with overrideMedicId parameter</name>
  <files>web/app/api/bookings/match/route.ts</files>
  <action>
    Extend the POST handler in `/web/app/api/bookings/match/route.ts` to support manual medic assignment.

    1. **Update the AutoMatchRequest interface** (line 14-16):
       ```typescript
       interface AutoMatchRequest {
         bookingId: string;
         overrideMedicId?: string; // Admin manual override - skips auto-assign
       }
       ```

    2. **Extract overrideMedicId from request body** (line 31):
       Change:
       ```typescript
       const { bookingId }: AutoMatchRequest = await request.json();
       ```
       To:
       ```typescript
       const { bookingId, overrideMedicId }: AutoMatchRequest = await request.json();
       ```

    3. **Add manual override branch** immediately after the `bookingId` validation check (after line 38, before the STEP 1 comment). Insert a new code path:

       ```typescript
       // === MANUAL OVERRIDE PATH ===
       // When admin selects a specific medic, skip auto-assign edge function entirely
       if (overrideMedicId) {
         // STEP 1: Update booking with manually selected medic
         const { error: updateError } = await supabase
           .from('bookings')
           .update({
             medic_id: overrideMedicId,
             requires_manual_approval: false,
           })
           .eq('id', bookingId);

         if (updateError) {
           console.error('Failed to manually assign medic:', updateError);
           return NextResponse.json(
             { error: 'Failed to assign medic', details: updateError.message },
             { status: 500 }
           );
         }

         // STEP 2: Trigger email notification chain
         const emailResponse = await fetch(
           `${process.env.NEXT_PUBLIC_SITE_URL || 'http://localhost:30500'}/api/email/booking-confirmation`,
           {
             method: 'POST',
             headers: { 'Content-Type': 'application/json' },
             body: JSON.stringify({ bookingId }),
           }
         );

         if (!emailResponse.ok) {
           console.error('Email sending failed after manual assignment, but booking is confirmed');
         }

         // STEP 3: Fetch medic details for response
         const { data: medicRecord } = await supabase
           .from('medics')
           .select('first_name, last_name, star_rating')
           .eq('id', overrideMedicId)
           .single();

         const manualMatch: MatchCandidate = {
           medic_id: overrideMedicId,
           medic_name: medicRecord
             ? `${medicRecord.first_name} ${medicRecord.last_name}`
             : 'Assigned Medic',
           star_rating: medicRecord?.star_rating ?? 0,
           availability: 'Manually assigned',
           match_score: 100,
           match_reasons: ['Manually assigned by admin'],
         };

         return NextResponse.json({
           matches: [manualMatch],
           requiresManualApproval: false,
         });
       }
       ```

    4. Keep the existing auto-assign path (STEP 1/2/3 comments) completely unchanged below the new override branch.

    IMPORTANT: The manual override path MUST call the email endpoint (STEP 2 above). This is the key difference from the existing `useReassignBooking` mutation which does a raw DB update with no email. The email trigger uses `NEXT_PUBLIC_SITE_URL || 'http://localhost:30500'` -- match the existing pattern exactly.
  </action>
  <verify>
    Run: `grep -n "overrideMedicId" web/app/api/bookings/match/route.ts` -- must return multiple results (interface, destructure, if-check).
    Run: `grep -n "Manually assigned by admin" web/app/api/bookings/match/route.ts` -- must return 1 result.
    Run: `grep -n "auto-assign-medic-v2" web/app/api/bookings/match/route.ts` -- must still return 1 result (existing auto-assign path unchanged).
    Run: `pnpm build` passes.
  </verify>
  <done>
    Match endpoint accepts optional overrideMedicId. When provided: directly updates booking.medic_id, triggers email notification, returns medic info. When absent: existing auto-assign path runs unchanged.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Assign Medic Manually dialog to BookingDetailPanel</name>
  <files>web/components/admin/booking-detail-panel.tsx</files>
  <action>
    Add an "Assign Medic Manually" button and dialog to the BookingDetailPanel. Follow the exact pattern used in `booking-approval-table.tsx` (lines 768-840) for the reassign dialog.

    1. **Add imports** at the top of the file:
       ```typescript
       import {
         Dialog,
         DialogContent,
         DialogHeader,
         DialogTitle,
         DialogDescription,
         DialogFooter,
       } from '@/components/ui/dialog';
       import {
         Select,
         SelectContent,
         SelectItem,
         SelectTrigger,
         SelectValue,
       } from '@/components/ui/select';
       import { Button } from '@/components/ui/button';
       import { useAvailableMedics } from '@/lib/queries/admin/bookings';
       import { useQueryClient } from '@tanstack/react-query';
       ```
       Also add `UserPlus` to the lucide-react import (for the button icon).

    2. **Add state variables** inside the `BookingDetailPanel` component (after the existing `useState` declarations around line 93):
       ```typescript
       const [assignDialogOpen, setAssignDialogOpen] = useState(false);
       const [selectedMedicId, setSelectedMedicId] = useState('');
       const [isAssigning, setIsAssigning] = useState(false);
       const [assignError, setAssignError] = useState<string | null>(null);
       const queryClient = useQueryClient();
       ```

    3. **Add the useAvailableMedics hook** (after the state declarations):
       ```typescript
       const { data: availableMedics = [] } = useAvailableMedics(
         booking?.shift_date || ''
       );
       ```
       Note: `useAvailableMedics` has `enabled: !!shiftDate` built in, so it only fetches when shift_date exists.

    4. **Add the handleAssignMedic function** (before the `if (!booking) return null` line):
       ```typescript
       const handleAssignMedic = async () => {
         if (!booking || !selectedMedicId) return;

         setIsAssigning(true);
         setAssignError(null);

         try {
           const response = await fetch('/api/bookings/match', {
             method: 'POST',
             headers: { 'Content-Type': 'application/json' },
             body: JSON.stringify({
               bookingId: booking.id,
               overrideMedicId: selectedMedicId,
             }),
           });

           if (!response.ok) {
             const data = await response.json();
             throw new Error(data.error || 'Failed to assign medic');
           }

           // Invalidate bookings query to refresh the table
           queryClient.invalidateQueries({ queryKey: ['bookings'] });

           setAssignDialogOpen(false);
           setSelectedMedicId('');
         } catch (err) {
           setAssignError(err instanceof Error ? err.message : 'Failed to assign medic');
         } finally {
           setIsAssigning(false);
         }
       };
       ```

    5. **Add the Assign Medic button** inside the "Client & Medic" section (after the match_score div, around line 259, before the closing `</section>` tag of that section). Add it conditionally when the booking has no medic OR requires manual approval:
       ```tsx
       {(!booking.medics || booking.requires_manual_approval) && (
         <div className="mt-3 pt-3 border-t border-gray-700/30">
           <Button
             variant="outline"
             size="sm"
             onClick={() => {
               setAssignDialogOpen(true);
               setAssignError(null);
               setSelectedMedicId('');
             }}
             className="w-full bg-blue-600/10 border-blue-500/30 text-blue-400 hover:bg-blue-600/20 hover:text-blue-300"
           >
             <UserPlus className="w-4 h-4 mr-2" />
             Assign Medic Manually
           </Button>
         </div>
       )}
       ```

    6. **Add the Dialog** right before the closing `</Sheet>` tag (before line 506). Place it inside the SheetContent but after all sections:
       ```tsx
       {/* Assign Medic Dialog */}
       <Dialog open={assignDialogOpen} onOpenChange={setAssignDialogOpen}>
         <DialogContent className="bg-gray-800 border-gray-700">
           <DialogHeader>
             <DialogTitle className="text-white">Assign Medic Manually</DialogTitle>
             <DialogDescription className="text-gray-400">
               Select a medic to assign to this booking. This will trigger a confirmation email to the client and medic.
             </DialogDescription>
           </DialogHeader>

           <div className="space-y-4 py-4">
             <div>
               <label className="text-sm text-gray-300 mb-2 block">
                 Available Medics ({availableMedics.length})
               </label>
               <Select value={selectedMedicId} onValueChange={setSelectedMedicId}>
                 <SelectTrigger className="bg-gray-900/50 border-gray-700/50 text-white">
                   <SelectValue placeholder="Select a medic..." />
                 </SelectTrigger>
                 <SelectContent className="bg-gray-800 border-gray-700">
                   {availableMedics.map((medic) => (
                     <SelectItem
                       key={medic.id}
                       value={medic.id}
                       className="text-white hover:bg-gray-700"
                     >
                       {medic.first_name} {medic.last_name}
                       {medic.star_rating > 0 && (
                         <span className="ml-2 text-yellow-400 text-xs">
                           {medic.star_rating.toFixed(1)} stars
                         </span>
                       )}
                     </SelectItem>
                   ))}
                   {availableMedics.length === 0 && (
                     <div className="px-2 py-3 text-sm text-gray-500 text-center">
                       No available medics for this date
                     </div>
                   )}
                 </SelectContent>
               </Select>
             </div>

             {assignError && (
               <div className="text-sm text-red-400 bg-red-500/10 border border-red-500/20 rounded p-2">
                 {assignError}
               </div>
             )}
           </div>

           <DialogFooter>
             <Button
               variant="outline"
               onClick={() => setAssignDialogOpen(false)}
               className="border-gray-700 text-gray-300 hover:bg-gray-700"
             >
               Cancel
             </Button>
             <Button
               onClick={handleAssignMedic}
               disabled={!selectedMedicId || isAssigning}
               className="bg-blue-600 hover:bg-blue-700"
             >
               {isAssigning ? 'Assigning...' : 'Assign Medic'}
             </Button>
           </DialogFooter>
         </DialogContent>
       </Dialog>
       ```

    IMPORTANT NOTES:
    - The panel is rendered inside BookingApprovalTable which is already inside TanStack Query's QueryClientProvider, so `useQueryClient` and `useAvailableMedics` will work.
    - The `useAvailableMedics` hook fetches medics where `available_for_work = true` ordered by `star_rating` desc, org-scoped. It already exists in `@/lib/queries/admin/bookings`.
    - After successful assignment, invalidate the `['bookings']` query key so the BookingApprovalTable refreshes and shows the newly assigned medic.
    - The dialog matches the existing Reassign Dialog pattern in booking-approval-table.tsx -- same dark theme, same button styles, same component imports.
  </action>
  <verify>
    Run: `grep -n "Assign Medic Manually" web/components/admin/booking-detail-panel.tsx` -- must return results.
    Run: `grep -n "overrideMedicId" web/components/admin/booking-detail-panel.tsx` -- must return 1 result (in the fetch body).
    Run: `grep -n "useAvailableMedics" web/components/admin/booking-detail-panel.tsx` -- must return 1 result.
    Run: `grep -n "Dialog" web/components/admin/booking-detail-panel.tsx` -- must return multiple results.
    Run: `pnpm build` passes.
  </verify>
  <done>
    BookingDetailPanel shows "Assign Medic Manually" button when booking has no medic or requires manual approval. Dialog opens with available medics dropdown sorted by star rating. On confirm, calls /api/bookings/match with overrideMedicId, which assigns medic + triggers email. Table refreshes via query invalidation.
  </done>
</task>

</tasks>

<verification>
- Match endpoint: `curl -X POST /api/bookings/match -d '{"bookingId":"test","overrideMedicId":"test"}' ` returns structured response (or appropriate error)
- Booking detail panel: "Assign Medic Manually" button visible when booking.medics is null
- Booking detail panel: "Assign Medic Manually" button visible when booking.requires_manual_approval is true
- Booking detail panel: Button NOT visible when booking already has an assigned medic (and doesn't require manual approval)
- Dialog shows available medics from useAvailableMedics hook
- After assignment: email notification triggered, bookings query invalidated
- `pnpm build` passes
</verification>

<success_criteria>
1. Admin can manually assign a specific medic to an unmatched booking in 3 clicks (button -> select medic -> confirm)
2. Manual assignment triggers the email notification chain (client + medic receive confirmation emails with calendar invite)
3. Medic selector shows only available-for-work medics sorted by star rating
4. Dialog appears only when booking is unassigned or requires manual approval
5. Build passes
</success_criteria>

<output>
After completion, create `.planning/phases/15-code-quality/15-03-SUMMARY.md`
</output>
