---
phase: 46-expiry-tracking-alerts
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/155_document_expiry_reminders.sql
  - supabase/functions/document-expiry-checker/index.ts
  - supabase/functions/document-expiry-checker/email-templates.ts
autonomous: true

must_haves:
  truths:
    - "Progressive email alerts are sent to medics at 30, 14, 7, and 1 day(s) before a document expires"
    - "Each alert email is a daily digest listing all of the medic's documents hitting that threshold -- not one email per document"
    - "Org admin receives a separate org-wide digest at 14, 7, and 1 day stages listing all expiring documents across their medics"
    - "Duplicate alerts are prevented -- the same document+stage combination never generates more than one email"
    - "Documents with null expiry_date are excluded from alerts"
    - "Only the current document version's expiry_date is checked (not archived versions)"
    - "The cron job sets documents.status to 'expired' for documents whose current version has passed its expiry date"
  artifacts:
    - path: "supabase/migrations/155_document_expiry_reminders.sql"
      provides: "Audit table, RPC function, pg_cron schedule, status update function"
      contains: "document_expiry_reminders"
    - path: "supabase/functions/document-expiry-checker/index.ts"
      provides: "Daily cron Edge Function with deduplication and digest grouping"
      contains: "REMINDER_STAGES"
    - path: "supabase/functions/document-expiry-checker/email-templates.ts"
      provides: "Medic digest and admin digest email templates with Resend"
      contains: "sendMedicDigestEmail"
  key_links:
    - from: "supabase/migrations/155_document_expiry_reminders.sql"
      to: "supabase/functions/document-expiry-checker/index.ts"
      via: "pg_cron -> pg_net HTTP POST to Edge Function"
      pattern: "net.http_post.*document-expiry-checker"
    - from: "supabase/functions/document-expiry-checker/index.ts"
      to: "supabase/functions/document-expiry-checker/email-templates.ts"
      via: "import sendMedicDigestEmail, sendAdminDigestEmail"
      pattern: "import.*email-templates"
    - from: "supabase/functions/document-expiry-checker/index.ts"
      to: "document_expiry_reminders table"
      via: "INSERT for deduplication audit trail"
      pattern: "from\\('document_expiry_reminders'\\)"
---

<objective>
Create the database infrastructure and Edge Function for progressive document expiry alerts.

Purpose: Medics and org admins need proactive email notifications as compliance documents approach expiry. Without alerts, expired documents go unnoticed until an audit, creating compliance risk.

Output:
- Migration 155 with document_expiry_reminders audit table, get_documents_expiring_in_days RPC, mark_expired_documents function, and daily pg_cron job at 8:00 UTC
- Deno Edge Function (document-expiry-checker) that queries each reminder stage, deduplicates, groups by medic for digest emails, sends admin digests at critical stages, and logs reminders
- Digest email templates (medic + admin) with escalating urgency styling via Resend (dev mode fallback)
</objective>

<execution_context>
@/Users/sabineresoagli/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sabineresoagli/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Key reference files -- study these BEFORE writing code
@supabase/migrations/034_certification_tracking.sql  # Reminders table + RPC pattern
@supabase/migrations/031_certification_expiry_cron.sql  # pg_cron + pg_net + Vault pattern (file is actually named 031 but content is cron migration)
@supabase/functions/certification-expiry-checker/index.ts  # Edge Function pattern (dedup, stages, email)
@supabase/functions/certification-expiry-checker/email-templates.ts  # Resend email template in Deno
@supabase/migrations/143_comms_docs_schema.sql  # documents + document_versions table schema
@web/types/comms.types.ts  # DocumentStatus, Document, DocumentVersion types
@web/lib/email/resend.ts  # Resend dev mode fallback pattern (for reference)

# Phase 46 context and research
@.planning/phases/46-expiry-tracking-alerts/46-CONTEXT.md
@.planning/phases/46-expiry-tracking-alerts/46-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create migration 155 with audit table, RPC, status update, and pg_cron job</name>
  <files>supabase/migrations/155_document_expiry_reminders.sql</files>
  <action>
Create migration `155_document_expiry_reminders.sql` with these sections:

**1. document_expiry_reminders audit table:**
- id UUID PRIMARY KEY DEFAULT gen_random_uuid()
- document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE
- document_version_id UUID NOT NULL REFERENCES document_versions(id) ON DELETE CASCADE
- medic_id UUID NOT NULL REFERENCES medics(id) ON DELETE CASCADE
- org_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE
- days_before INT NOT NULL (values: 30, 14, 7, 1)
- sent_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
- resend_message_id TEXT (nullable -- for Resend delivery tracking)
- recipient_type TEXT NOT NULL DEFAULT 'medic' CHECK (recipient_type IN ('medic', 'admin'))
- created_at TIMESTAMPTZ DEFAULT NOW()
- Indexes: composite on (document_version_id, days_before, recipient_type) for dedup; org_id for scoped queries; medic_id for per-medic lookups
- Enable RLS. Policy: SELECT for users where org_id = (SELECT get_user_org_id())

**2. RPC function get_documents_expiring_in_days(days_ahead INT):**
- RETURNS TABLE with: document_id, document_version_id, medic_id, medic_first_name, medic_last_name, medic_email, org_id, category_name, file_name, expiry_date, expiry_date_formatted, days_remaining
- JOIN documents -> document_versions via documents.current_version_id = document_versions.id
- JOIN medics on documents.medic_id = medics.id
- JOIN document_categories on documents.category_id = document_categories.id
- WHERE dv.expiry_date = CURRENT_DATE + days_ahead AND dv.expiry_date IS NOT NULL AND d.status NOT IN ('archived') AND m.email IS NOT NULL
- ORDER BY d.org_id, m.last_name, m.first_name
- LANGUAGE plpgsql STABLE SECURITY DEFINER

**3. Function mark_expired_documents():**
- Updates documents.status = 'expired' WHERE current_version_id IS NOT NULL AND the current version's expiry_date < CURRENT_DATE AND documents.status NOT IN ('archived', 'expired')
- RETURNS void, LANGUAGE plpgsql VOLATILE SECURITY DEFINER

**4. pg_cron job (daily at 8:00 UTC = 8am GMT / 9am BST):**
- Clone the exact pattern from migration 031 (certification expiry cron)
- Job name: 'document-expiry-checker'
- Schedule: '0 8 * * *'
- Uses Vault secrets (project_url, service_role_key) for Edge Function auth
- Body includes trigger='cron' and check_date=CURRENT_DATE::text
- Include idempotent DO $$ block to unschedule existing job first (migration re-run safety)
- Enable pg_cron and pg_net extensions (IF NOT EXISTS)

Add monitoring/management comment block at the end matching the pattern in migration 031.
  </action>
  <verify>
Run `grep -c 'document_expiry_reminders\|get_documents_expiring_in_days\|mark_expired_documents\|document-expiry-checker' supabase/migrations/155_document_expiry_reminders.sql` -- should find at least 4 distinct items. Verify the file contains CREATE TABLE, CREATE OR REPLACE FUNCTION (x2), and cron.schedule.
  </verify>
  <done>
Migration 155 exists with: document_expiry_reminders table (with RLS), get_documents_expiring_in_days RPC, mark_expired_documents function, and pg_cron daily job at 8:00 UTC using Vault secrets.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create document-expiry-checker Edge Function with digest email templates</name>
  <files>
    supabase/functions/document-expiry-checker/index.ts
    supabase/functions/document-expiry-checker/email-templates.ts
  </files>
  <action>
**Create `supabase/functions/document-expiry-checker/email-templates.ts`:**

Adapt from `certification-expiry-checker/email-templates.ts`. Create two export functions:

1. `sendMedicDigestEmail(params)` -- sends a single digest email to a medic listing all their documents hitting a threshold:
   - params: { medicFirstName, medicLastName, medicEmail, orgName, items: DigestItem[], dashboardUrl }
   - DigestItem: { categoryName, fileName, expiryDate (formatted string), daysRemaining }
   - Subject escalation: daysRemaining <= 1 = "CRITICAL: Document(s) expiring tomorrow" / <= 7 = "URGENT: Document(s) expiring in X days" / <= 14 = "Action Required: Document(s) expiring in X days" / 30 = "Reminder: Document(s) expiring in 30 days"
   - Use the smallest daysRemaining in the batch for subject urgency level
   - HTML template: header banner, greeting, alert box with urgency colour (red/amber/blue matching cert pattern), table of documents (Category, File, Expiry Date, Days), CTA button "Upload Replacement Document" linking to dashboardUrl, next steps section, footer with org name
   - Colour scheme: match certification-expiry-checker (red for <=1d, amber for <=7d, blue for <=14d, default blue for 30d)
   - Dev mode fallback: if no RESEND_API_KEY, console.log the email details and return 'dev-mode-mock-id'

2. `sendAdminDigestEmail(params)` -- sends one org-wide digest to the admin listing ALL medics with expiring documents:
   - params: { adminEmail, adminName, orgName, groups: AdminDigestGroup[], dashboardUrl }
   - AdminDigestGroup: { medicName, items: DigestItem[] }
   - Subject: "Document Expiry Alert: X document(s) across Y medic(s)" with urgency prefix
   - HTML template: similar structure but groups documents by medic name, includes a "View Expiry Dashboard" CTA linking to dashboardUrl + '/admin/document-expiry'
   - Same dev mode fallback

Both functions use `import { Resend } from 'npm:resend@4.0.2';` (Deno import). Initialise Resend client once at module level. Send from `${orgName} <notifications@sitemedic.app>`.

**Create `supabase/functions/document-expiry-checker/index.ts`:**

Clone the structure from `certification-expiry-checker/index.ts`. Key differences:

1. REMINDER_STAGES = [30, 14, 7, 1]
2. ADMIN_STAGES = [14, 7, 1] (admin gets digest at critical stages only, not 30 days)
3. For each stage in REMINDER_STAGES:
   a. Call supabase.rpc('get_documents_expiring_in_days', { days_ahead: stage })
   b. Deduplicate: for each doc, check document_expiry_reminders for existing (document_version_id, days_before, recipient_type='medic') row. Skip if exists.
   c. Group remaining docs by medic_id into a Map
   d. For each medic group, call sendMedicDigestEmail with all their items
   e. On success, INSERT one row per document into document_expiry_reminders (recipient_type='medic')
   f. If stage is in ADMIN_STAGES: group all remaining docs by org_id, then for each org:
      - Fetch admin email from profiles table WHERE org_id = X AND role = 'site_manager' (single)
      - Also check org_settings.admin_email as fallback
      - Call sendAdminDigestEmail with all medic groups for that org
      - INSERT rows into document_expiry_reminders (recipient_type='admin')
4. After all stages: call supabase.rpc('mark_expired_documents') to set status='expired' on past-due documents
5. Return JSON response with counts: { success, medic_reminders_sent, admin_reminders_sent, expired_marked, check_date }

Error handling:
- Wrap each stage in try/catch (continue on stage failure)
- Wrap each medic email send in try/catch (continue on individual failure, matching cert checker pattern)
- Log extensively with console.log for each stage, each medic, each email sent

Use SUPABASE_URL and SUPABASE_SERVICE_ROLE_KEY from Deno.env. Use NEXT_PUBLIC_APP_URL for dashboardBaseUrl (fallback to 'http://localhost:30500').
  </action>
  <verify>
Verify both files exist: `ls supabase/functions/document-expiry-checker/`. Verify imports: grep for 'Resend' in email-templates.ts, grep for 'sendMedicDigestEmail' and 'sendAdminDigestEmail' in index.ts, grep for 'mark_expired_documents' in index.ts.
  </verify>
  <done>
Edge Function exists with: index.ts (daily cron handler with 4 reminder stages, deduplication, medic digest grouping, admin digest at critical stages, expired status marking) and email-templates.ts (two digest email functions with escalating urgency and dev mode fallback).
  </done>
</task>

</tasks>

<verification>
1. Migration file check: `cat supabase/migrations/155_document_expiry_reminders.sql | head -5` shows migration header
2. Edge Function structure: `ls supabase/functions/document-expiry-checker/` shows index.ts and email-templates.ts
3. Deduplication wired: `grep -c 'document_expiry_reminders' supabase/functions/document-expiry-checker/index.ts` returns > 0
4. Digest pattern confirmed: `grep -c 'sendMedicDigestEmail\|sendAdminDigestEmail' supabase/functions/document-expiry-checker/index.ts` returns 2+
5. Dev mode fallback: `grep 'RESEND_API_KEY' supabase/functions/document-expiry-checker/email-templates.ts` shows dev mode check
6. Cron schedule: `grep "'0 8' supabase/migrations/155_document_expiry_reminders.sql` shows daily 8:00 UTC schedule
7. mark_expired_documents called: `grep 'mark_expired_documents' supabase/functions/document-expiry-checker/index.ts` shows function call
</verification>

<success_criteria>
- Migration 155 creates the document_expiry_reminders audit table with RLS, get_documents_expiring_in_days RPC, mark_expired_documents function, and pg_cron daily job
- Edge Function queries each stage (30/14/7/1), deduplicates via the reminders table, groups by medic for digest emails, sends admin digests at 14/7/1 stages
- Email templates have escalating urgency (blue -> amber -> red), tabular document listing, CTA buttons, and dev mode fallback
- Only current document version expiry dates are queried (JOIN via current_version_id)
- NULL expiry dates are excluded
- Archived documents are excluded
</success_criteria>

<output>
After completion, create `.planning/phases/46-expiry-tracking-alerts/46-01-SUMMARY.md`
</output>
