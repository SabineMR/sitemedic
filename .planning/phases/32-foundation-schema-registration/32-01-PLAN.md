---
phase: 32-foundation-schema-registration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/140_marketplace_foundation.sql
  - supabase/migrations/141_compliance_documents.sql
  - supabase/migrations/142_marketplace_storage_bucket.sql
  - web/lib/marketplace/types.ts
  - web/lib/marketplace/cqc-client.ts
  - web/lib/marketplace/compliance.ts
autonomous: true

must_haves:
  truths:
    - "marketplace_companies table exists with CQC fields, verification_status, Stripe Connect columns, and org_id crossover link"
    - "compliance_documents table exists with document_type discriminator, expiry tracking, and review workflow columns"
    - "RLS policies on marketplace tables use auth.uid() and is_platform_admin() — NOT get_user_org_id()"
    - "btree_gist extension enabled and medic_commitments table has EXCLUSION constraint preventing overlapping time ranges for the same medic"
    - "Private compliance-documents storage bucket exists with owner-only + admin RLS policies"
    - "CQC API client can verify a provider ID and return valid/invalid with provider name"
    - "TypeScript types exist for marketplace_companies, compliance_documents, and CQC API responses"
  artifacts:
    - path: "supabase/migrations/140_marketplace_foundation.sql"
      provides: "marketplace_companies table, medic_commitments table with EXCLUSION constraint, bookings.source column, RLS policies"
      contains: "CREATE TABLE marketplace_companies"
    - path: "supabase/migrations/141_compliance_documents.sql"
      provides: "compliance_documents table with document_type CHECK, expiry tracking, review workflow"
      contains: "CREATE TABLE compliance_documents"
    - path: "supabase/migrations/142_marketplace_storage_bucket.sql"
      provides: "Private compliance-documents storage bucket with RLS for owners and platform admins"
      contains: "compliance-documents"
    - path: "web/lib/marketplace/types.ts"
      provides: "TypeScript interfaces for all marketplace entities"
      exports: ["MarketplaceCompany", "ComplianceDocument", "VerificationStatus", "DocumentType", "CQCProvider"]
    - path: "web/lib/marketplace/cqc-client.ts"
      provides: "CQC API client wrapper with verifyCQCProvider function"
      exports: ["verifyCQCProvider"]
    - path: "web/lib/marketplace/compliance.ts"
      provides: "Compliance utility functions for document expiry checking"
      exports: ["isDocumentExpired", "getExpiringDocuments", "REQUIRED_DOCUMENT_TYPES"]
  key_links:
    - from: "supabase/migrations/140_marketplace_foundation.sql"
      to: "organizations table"
      via: "org_id FK with UNIQUE constraint for bidirectional crossover"
      pattern: "REFERENCES organizations\\(id\\)"
    - from: "supabase/migrations/141_compliance_documents.sql"
      to: "marketplace_companies table"
      via: "company_id FK with CASCADE delete"
      pattern: "REFERENCES marketplace_companies\\(id\\)"
    - from: "web/lib/marketplace/types.ts"
      to: "supabase/migrations/140_marketplace_foundation.sql"
      via: "TypeScript interfaces mirror SQL table columns"
      pattern: "interface MarketplaceCompany"
---

<objective>
Create the marketplace database foundation: tables, RLS policies, EXCLUSION constraints, storage bucket, TypeScript types, and CQC API client library.

Purpose: Every other plan in Phase 32 (and subsequent marketplace phases) depends on these tables and types. This is the foundation layer that must exist before any UI or business logic can be built.

Output: 3 SQL migration files, 3 TypeScript library files, private storage bucket for compliance documents.
</objective>

<execution_context>
@/Users/sabineresoagli/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sabineresoagli/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/32-foundation-schema-registration/32-RESEARCH.md
@.planning/phases/32-foundation-schema-registration/32-CONTEXT.md

# Existing patterns to follow:
@supabase/migrations/002_business_operations.sql           # Table creation pattern, medics/clients/bookings schema
@supabase/migrations/028_enable_org_rls.sql               # get_user_org_id() function (DO NOT use for marketplace tables)
@supabase/migrations/101_migrate_to_platform_admin.sql    # is_platform_admin() function definition
@supabase/migrations/122_cqc_registration.sql             # Existing CQC fields on org_settings
@supabase/migrations/134_org_logos_bucket.sql             # Storage bucket + RLS policy pattern
@supabase/migrations/125_event_incident_reports_storage.sql  # Private bucket RLS pattern
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create marketplace foundation migration (tables, RLS, constraints)</name>
  <files>supabase/migrations/140_marketplace_foundation.sql</files>
  <action>
Create migration file `140_marketplace_foundation.sql` with:

**1. Enable btree_gist extension:**
```sql
CREATE EXTENSION IF NOT EXISTS btree_gist;
```

**2. Create `marketplace_companies` table:**
- `id` UUID PK with gen_random_uuid()
- `org_id` UUID UNIQUE FK to organizations(id) ON DELETE RESTRICT — for bidirectional crossover (nullable — new marketplace-only companies may not have an org yet)
- `admin_user_id` UUID NOT NULL FK to auth.users(id) — the user who registered this company
- CQC fields: `cqc_provider_id` TEXT NOT NULL, `cqc_registration_status` TEXT NOT NULL, `cqc_last_checked_at` TIMESTAMPTZ, `cqc_auto_verified` BOOLEAN DEFAULT FALSE
- Company details: `company_name` TEXT NOT NULL, `company_reg_number` TEXT, `company_address` TEXT, `company_postcode` TEXT, `company_phone` TEXT, `company_email` TEXT NOT NULL, `coverage_areas` TEXT[] (postcode prefixes), `company_description` TEXT
- Stripe Connect: `stripe_account_id` TEXT UNIQUE, `stripe_onboarding_complete` BOOLEAN DEFAULT FALSE
- Verification: `verification_status` TEXT NOT NULL DEFAULT 'pending' with CHECK constraint for ('pending', 'cqc_verified', 'verified', 'rejected', 'suspended', 'info_requested'), `verified_at` TIMESTAMPTZ, `verified_by` UUID REFERENCES auth.users(id), `rejection_reason` TEXT, `suspension_reason` TEXT, `suspended_at` TIMESTAMPTZ
- Flags: `can_browse_events` BOOLEAN DEFAULT TRUE, `can_submit_quotes` BOOLEAN DEFAULT FALSE
- Timestamps: `created_at` TIMESTAMPTZ DEFAULT NOW(), `updated_at` TIMESTAMPTZ DEFAULT NOW()

**3. Create `medic_commitments` table** (for race-condition prevention in later phases):
- `id` UUID PK
- `medic_id` UUID NOT NULL FK to medics(id)
- `booking_id` UUID FK to bookings(id) — nullable until booking is created
- `marketplace_company_id` UUID FK to marketplace_companies(id)
- `event_date` DATE NOT NULL
- `time_range` TSRANGE NOT NULL
- `created_at` TIMESTAMPTZ DEFAULT NOW()
- EXCLUSION constraint: `EXCLUDE USING GIST (medic_id WITH =, time_range WITH &&)` — prevents same medic from having overlapping commitments

**4. Add `source` column to bookings table:**
```sql
ALTER TABLE bookings ADD COLUMN IF NOT EXISTS source TEXT NOT NULL DEFAULT 'direct'
  CHECK (source IN ('direct', 'marketplace'));
```

**5. Add `marketplace_enabled` column to clients table** (for lightweight client marketplace registration):
```sql
ALTER TABLE clients ADD COLUMN IF NOT EXISTS marketplace_enabled BOOLEAN DEFAULT FALSE;
```

**6. RLS policies on marketplace_companies** — IMPORTANT: use auth.uid() NOT get_user_org_id():
- Enable RLS on marketplace_companies
- `company_owners_manage_own`: FOR ALL USING (admin_user_id = auth.uid())
- `browse_verified_companies`: FOR SELECT USING (verification_status = 'verified' AND auth.uid() IS NOT NULL)
- `platform_admin_all_companies`: FOR ALL USING (is_platform_admin())

**7. RLS policies on medic_commitments:**
- Enable RLS
- `commitment_owner_read`: FOR SELECT USING (medic_id IN (SELECT id FROM medics WHERE user_id = auth.uid()))
- `platform_admin_all_commitments`: FOR ALL USING (is_platform_admin())

**8. Create updated_at trigger** for marketplace_companies (follow existing trigger pattern from the codebase — check if a generic `update_updated_at_column()` trigger function already exists; if so, reuse it; if not, create one).

**9. Create indexes:**
- `idx_marketplace_companies_admin_user_id` ON marketplace_companies(admin_user_id)
- `idx_marketplace_companies_verification_status` ON marketplace_companies(verification_status)
- `idx_marketplace_companies_cqc_provider_id` ON marketplace_companies(cqc_provider_id)
- `idx_medic_commitments_medic_id` ON medic_commitments(medic_id)
- `idx_medic_commitments_event_date` ON medic_commitments(event_date)
- `idx_bookings_source` ON bookings(source)
  </action>
  <verify>
Run `grep -c "CREATE TABLE" supabase/migrations/140_marketplace_foundation.sql` — should return 2 (marketplace_companies + medic_commitments).
Run `grep -c "CREATE POLICY" supabase/migrations/140_marketplace_foundation.sql` — should return 5.
Run `grep "EXCLUDE USING GIST" supabase/migrations/140_marketplace_foundation.sql` — should match the EXCLUSION constraint.
Run `grep "btree_gist" supabase/migrations/140_marketplace_foundation.sql` — should match the extension.
Run `grep "source.*direct.*marketplace" supabase/migrations/140_marketplace_foundation.sql` — should match the bookings ALTER.
  </verify>
  <done>marketplace_companies and medic_commitments tables defined with all columns, RLS policies use auth.uid() and is_platform_admin(), EXCLUSION constraint prevents medic double-booking, bookings.source column discriminates direct vs marketplace, clients.marketplace_enabled flag added</done>
</task>

<task type="auto">
  <name>Task 2: Create compliance documents migration and storage bucket</name>
  <files>supabase/migrations/141_compliance_documents.sql, supabase/migrations/142_marketplace_storage_bucket.sql</files>
  <action>
**File 1: `141_compliance_documents.sql`**

Create the `compliance_documents` table:
- `id` UUID PK with gen_random_uuid()
- `company_id` UUID NOT NULL FK to marketplace_companies(id) ON DELETE CASCADE
- `uploaded_by` UUID NOT NULL FK to auth.users(id)
- `document_type` TEXT NOT NULL with CHECK constraint for ('public_liability_insurance', 'employers_liability_insurance', 'professional_indemnity_insurance', 'dbs_certificate', 'other')
- `storage_path` TEXT NOT NULL (Supabase Storage path)
- `file_name` TEXT NOT NULL
- `file_size_bytes` INT
- `mime_type` TEXT
- `issue_date` DATE
- `expiry_date` DATE (NULL if no expiry)
- `certificate_number` TEXT
- `staff_member_name` TEXT (for DBS: which staff member)
- `review_status` TEXT NOT NULL DEFAULT 'pending' with CHECK for ('pending', 'approved', 'rejected', 'expired')
- `reviewed_at` TIMESTAMPTZ
- `reviewed_by` UUID FK to auth.users(id)
- `review_notes` TEXT
- `created_at` TIMESTAMPTZ DEFAULT NOW()
- `updated_at` TIMESTAMPTZ DEFAULT NOW()

RLS policies on compliance_documents:
- Enable RLS
- `company_owners_manage_own_docs`: FOR ALL USING (EXISTS (SELECT 1 FROM marketplace_companies WHERE id = compliance_documents.company_id AND admin_user_id = auth.uid()))
- `platform_admin_all_docs`: FOR ALL USING (is_platform_admin())
- **DO NOT** allow any other SELECT access — compliance documents are sensitive

Indexes:
- `idx_compliance_docs_company_id` ON compliance_documents(company_id)
- `idx_compliance_docs_document_type` ON compliance_documents(document_type)
- `idx_compliance_docs_expiry_date` ON compliance_documents(expiry_date)
- `idx_compliance_docs_review_status` ON compliance_documents(review_status)

Trigger: reuse the updated_at trigger function on compliance_documents.

**File 2: `142_marketplace_storage_bucket.sql`**

Create private storage bucket `compliance-documents`:
- `public: false` (sensitive documents)
- `file_size_limit: 10485760` (10 MB)
- `allowed_mime_types`: ['application/pdf', 'image/jpeg', 'image/jpg', 'image/png', 'application/msword', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document']
- Use `ON CONFLICT (id) DO NOTHING` for idempotency

Storage RLS policies (follow pattern from `134_org_logos_bucket.sql` and `125_event_incident_reports_storage.sql`):
- `Company admins upload compliance docs`: FOR INSERT WITH CHECK — bucket_id = 'compliance-documents' AND company folder matches admin_user_id via marketplace_companies join
- `Company admins view own compliance docs`: FOR SELECT USING — same ownership check
- `Company admins delete own compliance docs`: FOR DELETE USING — same ownership check
- `Platform admins view all compliance docs`: FOR SELECT USING — bucket_id = 'compliance-documents' AND is_platform_admin()

The folder structure for compliance docs: `{company_id}/{document_type}/{filename}` — the first folder segment is the company ID.
  </action>
  <verify>
Run `grep -c "CREATE TABLE" supabase/migrations/141_compliance_documents.sql` — should return 1.
Run `grep -c "CREATE POLICY" supabase/migrations/141_compliance_documents.sql` — should return 2.
Run `grep "compliance-documents" supabase/migrations/142_marketplace_storage_bucket.sql` — should match bucket creation.
Run `grep -c "CREATE POLICY" supabase/migrations/142_marketplace_storage_bucket.sql` — should return 4 (upload, view own, delete, admin view).
  </verify>
  <done>compliance_documents table exists with document_type discriminator, expiry tracking, review workflow, and RLS restricting access to company owners and platform admins only. Private compliance-documents storage bucket created with proper RLS for uploads, views, and admin access.</done>
</task>

<task type="auto">
  <name>Task 3: Create TypeScript types, CQC client, and compliance utilities</name>
  <files>web/lib/marketplace/types.ts, web/lib/marketplace/cqc-client.ts, web/lib/marketplace/compliance.ts</files>
  <action>
**File 1: `web/lib/marketplace/types.ts`**

Create TypeScript interfaces mirroring the SQL schema:

```typescript
// Verification status enum
export type VerificationStatus = 'pending' | 'cqc_verified' | 'verified' | 'rejected' | 'suspended' | 'info_requested';

// Document types
export type DocumentType = 'public_liability_insurance' | 'employers_liability_insurance' | 'professional_indemnity_insurance' | 'dbs_certificate' | 'other';

// Document review status
export type DocumentReviewStatus = 'pending' | 'approved' | 'rejected' | 'expired';

// Marketplace company (mirrors marketplace_companies table)
export interface MarketplaceCompany {
  id: string;
  org_id: string | null;
  admin_user_id: string;
  cqc_provider_id: string;
  cqc_registration_status: string;
  cqc_last_checked_at: string | null;
  cqc_auto_verified: boolean;
  company_name: string;
  company_reg_number: string | null;
  company_address: string | null;
  company_postcode: string | null;
  company_phone: string | null;
  company_email: string;
  coverage_areas: string[] | null;
  company_description: string | null;
  stripe_account_id: string | null;
  stripe_onboarding_complete: boolean;
  verification_status: VerificationStatus;
  verified_at: string | null;
  verified_by: string | null;
  rejection_reason: string | null;
  suspension_reason: string | null;
  suspended_at: string | null;
  can_browse_events: boolean;
  can_submit_quotes: boolean;
  created_at: string;
  updated_at: string;
}

// Compliance document (mirrors compliance_documents table)
export interface ComplianceDocument {
  id: string;
  company_id: string;
  uploaded_by: string;
  document_type: DocumentType;
  storage_path: string;
  file_name: string;
  file_size_bytes: number | null;
  mime_type: string | null;
  issue_date: string | null;
  expiry_date: string | null;
  certificate_number: string | null;
  staff_member_name: string | null;
  review_status: DocumentReviewStatus;
  reviewed_at: string | null;
  reviewed_by: string | null;
  review_notes: string | null;
  created_at: string;
  updated_at: string;
}

// CQC API types
export interface CQCProvider {
  providerId: string;
  providerName: string;
  registrationStatus: string;
  registrationDate: string;
  organisationType: string;
  locationIds: string[];
}

export interface CQCVerificationResult {
  valid: boolean;
  provider: CQCProvider | null;
  error?: string;
}

// Admin verification action
export type VerificationAction = 'approve' | 'reject' | 'request_info';

// Registration wizard step
export type RegistrationStep = 'company-details' | 'cqc-verification' | 'document-upload' | 'stripe-connect';
```

**File 2: `web/lib/marketplace/cqc-client.ts`**

CQC API client (for use in Next.js API routes — NOT Edge Functions which use Deno):

```typescript
const CQC_BASE_URL = 'https://api.cqc.org.uk/public/v1';
const CQC_PARTNER_CODE = process.env.CQC_PARTNER_CODE || 'SiteMedic';

export async function verifyCQCProvider(providerId: string): Promise<CQCVerificationResult> {
  // Input validation
  if (!providerId || typeof providerId !== 'string') {
    return { valid: false, provider: null, error: 'Invalid provider ID' };
  }

  try {
    const response = await fetch(
      `${CQC_BASE_URL}/providers/${encodeURIComponent(providerId)}?partnerCode=${CQC_PARTNER_CODE}`,
      { next: { revalidate: 0 } }  // No caching — always fresh
    );

    if (response.status === 404) {
      return { valid: false, provider: null, error: 'CQC provider not found' };
    }

    if (!response.ok) {
      return { valid: false, provider: null, error: `CQC API error: ${response.status}` };
    }

    const provider: CQCProvider = await response.json();

    return {
      valid: provider.registrationStatus === 'Registered',
      provider,
      error: provider.registrationStatus !== 'Registered'
        ? `CQC status is "${provider.registrationStatus}", not "Registered"`
        : undefined,
    };
  } catch (err) {
    return {
      valid: false,
      provider: null,
      error: `CQC API request failed: ${err instanceof Error ? err.message : 'Unknown error'}`,
    };
  }
}
```

Import CQCVerificationResult and CQCProvider from `./types`.

**File 3: `web/lib/marketplace/compliance.ts`**

Compliance utility functions:

```typescript
import { ComplianceDocument, DocumentType } from './types';

// Required document types for marketplace registration
export const REQUIRED_DOCUMENT_TYPES: DocumentType[] = [
  'public_liability_insurance',
  'employers_liability_insurance',
  'professional_indemnity_insurance',
  'dbs_certificate',
];

// Human-readable labels for document types
export const DOCUMENT_TYPE_LABELS: Record<DocumentType, string> = {
  public_liability_insurance: 'Public Liability Insurance',
  employers_liability_insurance: "Employer's Liability Insurance",
  professional_indemnity_insurance: 'Professional Indemnity Insurance',
  dbs_certificate: 'DBS Certificate',
  other: 'Other',
};

// Check if a single document is expired
export function isDocumentExpired(doc: ComplianceDocument): boolean {
  if (!doc.expiry_date) return false;
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const expiry = new Date(doc.expiry_date);
  expiry.setHours(0, 0, 0, 0);
  return expiry < today;
}

// Get documents expiring within N days
export function getExpiringDocuments(
  documents: ComplianceDocument[],
  withinDays: number = 30
): ComplianceDocument[] {
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const cutoff = new Date(today);
  cutoff.setDate(cutoff.getDate() + withinDays);

  return documents.filter((doc) => {
    if (!doc.expiry_date) return false;
    const expiry = new Date(doc.expiry_date);
    expiry.setHours(0, 0, 0, 0);
    return expiry >= today && expiry <= cutoff;
  });
}

// Check if a company has all required documents with approved status and not expired
export function hasAllRequiredDocuments(documents: ComplianceDocument[]): {
  complete: boolean;
  missing: DocumentType[];
  expired: DocumentType[];
} {
  const missing: DocumentType[] = [];
  const expired: DocumentType[] = [];

  for (const type of REQUIRED_DOCUMENT_TYPES) {
    const doc = documents.find(
      (d) => d.document_type === type && d.review_status === 'approved'
    );
    if (!doc) {
      missing.push(type);
    } else if (isDocumentExpired(doc)) {
      expired.push(type);
    }
  }

  return {
    complete: missing.length === 0 && expired.length === 0,
    missing,
    expired,
  };
}
```
  </action>
  <verify>
Run `npx tsc --noEmit web/lib/marketplace/types.ts` (or equivalent TypeScript check) — should compile without errors.
Run `ls web/lib/marketplace/` — should list types.ts, cqc-client.ts, compliance.ts.
Run `grep "verifyCQCProvider" web/lib/marketplace/cqc-client.ts` — should match the export.
Run `grep "REQUIRED_DOCUMENT_TYPES" web/lib/marketplace/compliance.ts` — should match the export.
  </verify>
  <done>TypeScript types mirror SQL schema exactly, CQC client can verify a provider ID with proper error handling, compliance utilities provide document expiry checking and required-documents validation. All three files export named types/functions ready for import by registration and admin UI plans.</done>
</task>

</tasks>

<verification>
1. All 3 migration files exist in `supabase/migrations/` with sequential numbering (140, 141, 142)
2. `marketplace_companies` table has all columns from research schema including CQC fields, Stripe Connect columns, verification workflow columns
3. RLS policies on marketplace tables use `auth.uid()` and `is_platform_admin()` — grep confirms NO usage of `get_user_org_id()` in these migrations
4. `medic_commitments` table has EXCLUSION constraint with btree_gist
5. `bookings.source` column exists with 'direct'/'marketplace' CHECK
6. Private compliance-documents storage bucket created with owner-only + admin RLS
7. TypeScript types in `web/lib/marketplace/types.ts` match SQL column names exactly
8. CQC client handles 404, non-200, and network errors gracefully
9. Compliance utilities correctly identify expired and missing documents
</verification>

<success_criteria>
- 3 SQL migrations syntactically valid and follow existing migration patterns
- 3 TypeScript files compile without errors
- No usage of get_user_org_id() in any marketplace migration
- EXCLUSION constraint defined on medic_commitments(medic_id, time_range)
- Storage bucket is private (public: false) with 10MB limit
</success_criteria>

<output>
After completion, create `.planning/phases/32-foundation-schema-registration/32-01-SUMMARY.md`
</output>
