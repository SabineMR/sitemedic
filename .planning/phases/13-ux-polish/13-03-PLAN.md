---
phase: 13-ux-polish
plan: 03
type: execute
wave: 2
depends_on: ["13-02"]
files_modified:
  - web/hooks/useGeofenceExitMonitor.ts
  - web/stores/useMedicLocationsStore.ts
  - web/app/admin/command-center/page.tsx
autonomous: true

must_haves:
  truths:
    - "When a medic location ping is outside their assigned geofence radius, an alert of type geofence_failure is created"
    - "Alert creation uses the create_medic_alert DB RPC (not direct INSERT) for 15-minute deduplication"
    - "Geofences are loaded once at subscribe time into a Map for O(1) lookup per ping (not queried per ping)"
    - "Alert appears in the command center AlertPanel within 60 seconds of the ping"
  artifacts:
    - path: "web/hooks/useGeofenceExitMonitor.ts"
      provides: "Hook that loads active geofences and exposes checkPing() for distance validation"
      contains: "haversineMeters"
      exports: ["useGeofenceExitMonitor"]
    - path: "web/stores/useMedicLocationsStore.ts"
      provides: "Updated store that calls geofence exit check on each incoming ping"
      contains: "checkGeofenceExit"
    - path: "web/app/admin/command-center/page.tsx"
      provides: "Command center that initializes the geofence exit monitor"
      contains: "useGeofenceExitMonitor"
  key_links:
    - from: "web/hooks/useGeofenceExitMonitor.ts"
      to: "supabase.rpc('create_medic_alert')"
      via: "RPC call when distance exceeds radius"
      pattern: "rpc.*create_medic_alert.*geofence_failure"
    - from: "web/stores/useMedicLocationsStore.ts"
      to: "web/hooks/useGeofenceExitMonitor.ts"
      via: "checkPing called inside ping handler callback"
      pattern: "checkGeofenceExit|checkPing"
    - from: "web/hooks/useGeofenceExitMonitor.ts"
      to: "geofences table"
      via: "Single query at init time, stored in Map keyed by booking_id"
      pattern: "from.*geofences.*select.*is_active.*true"
---

<objective>
Wire geofence exit alerts so that when a medic's location ping falls outside their assigned geofence, an alert is automatically created.

Purpose: The `medic_alerts` table already has the `geofence_failure` alert type, the `create_medic_alert()` RPC already exists with 15-minute deduplication, and the `useMedicLocationsStore` already processes pings. The only missing piece is the distance check between ping coordinates and geofence boundaries.
Output: A `useGeofenceExitMonitor` hook and updated location store that checks every ping against active geofences.
</objective>

<execution_context>
@/Users/sabineresoagli/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sabineresoagli/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-ux-polish/13-RESEARCH.md

Key existing files:
@web/stores/useMedicLocationsStore.ts — Processes pings via Realtime; medicContext Map pattern at subscribe time
@web/stores/useMedicAlertsStore.ts — Subscribes to medic_alerts Realtime; AlertPanel already renders alerts
@web/app/admin/command-center/page.tsx — Mounts both stores; AlertPanel shows alerts in sidebar

DB infrastructure (already exists, no migration needed):
- `medic_alerts` table with `geofence_failure` alert type (migration 008)
- `create_medic_alert(p_medic_id, p_booking_id, p_alert_type, p_alert_severity, p_alert_title, p_alert_message, p_metadata, p_related_ping_id)` RPC with 15-minute dedup window
- `geofences` table with correct columns: center_latitude, center_longitude, radius_meters, is_active, booking_id (now nullable per 13-02 migration)

Depends on 13-02: The geofences table must have the correct schema (site_name column added, booking_id nullable) before this plan can correctly load geofences.

Decisions:
- D-10-01-004: Context-at-subscribe pattern (O(1) Map lookup per ping) — use same pattern for geofences
- Never INSERT directly into medic_alerts — always use create_medic_alert() RPC for dedup
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useGeofenceExitMonitor hook</name>
  <files>web/hooks/useGeofenceExitMonitor.ts</files>
  <action>
    Create `web/hooks/useGeofenceExitMonitor.ts`:

    1. Define Geofence interface:
       ```typescript
       interface GeofenceEntry {
         id: string;
         booking_id: string | null;
         org_id: string | null;
         center_latitude: number;
         center_longitude: number;
         radius_meters: number;
         site_name: string | null;
       }
       ```

    2. Implement haversineMeters function (matches the DB function from migration 006):
       ```typescript
       function haversineMeters(lat1: number, lng1: number, lat2: number, lng2: number): number {
         const R = 6371000; // Earth radius in meters
         const phi1 = (lat1 * Math.PI) / 180;
         const phi2 = (lat2 * Math.PI) / 180;
         const dPhi = ((lat2 - lat1) * Math.PI) / 180;
         const dLambda = ((lng2 - lng1) * Math.PI) / 180;
         const a = Math.sin(dPhi / 2) ** 2 + Math.cos(phi1) * Math.cos(phi2) * Math.sin(dLambda / 2) ** 2;
         return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
       }
       ```

    3. Export a `useGeofenceExitMonitor` hook:
       - `geofencesByBooking = useRef(new Map<string, GeofenceEntry>())`
       - `initialized = useRef(false)`
       - `loadGeofences()` async function: queries `supabase.from('geofences').select('id, booking_id, org_id, center_latitude, center_longitude, radius_meters, site_name').eq('is_active', true)`, populates the Map keyed by booking_id (skip entries where booking_id is null — org-level geofences are for admin reference only, not exit alerts)
       - `checkPing(medicId, bookingId, medicName, siteName, latitude, longitude, pingId?)` async function:
         - Look up `geofencesByBooking.current.get(bookingId)` — if not found, return silently (no geofence for this booking)
         - Calculate distance via `haversineMeters(latitude, longitude, geofence.center_latitude, geofence.center_longitude)`
         - If `distance > geofence.radius_meters`:
           - Call `supabase.rpc('create_medic_alert', { p_medic_id: medicId, p_booking_id: bookingId, p_alert_type: 'geofence_failure', p_alert_severity: 'high', p_alert_title: 'Medic Outside Geofence', p_alert_message: '${medicName} is ${Math.round(distance)}m outside the ${geofence.radius_meters}m boundary for ${siteName}', p_metadata: { distance_meters: Math.round(distance), geofence_radius: geofence.radius_meters, lat: latitude, lng: longitude }, p_related_ping_id: pingId ?? null })`
           - Log error to console if RPC fails, but do NOT throw (non-blocking)
       - Return `{ loadGeofences, checkPing }`

    4. Import supabase from `@/lib/supabase` (not `@/lib/supabase/client` — match the store pattern)

    IMPORTANT: This is NOT a React component hook with useEffect. It's a plain hook that returns functions. The caller (command center page) is responsible for calling loadGeofences() at the right time and passing checkPing to the location store.
  </action>
  <verify>
    - `grep "haversineMeters" web/hooks/useGeofenceExitMonitor.ts` shows distance function
    - `grep "create_medic_alert" web/hooks/useGeofenceExitMonitor.ts` shows RPC call
    - `grep "geofence_failure" web/hooks/useGeofenceExitMonitor.ts` shows correct alert type
    - `grep "booking_id" web/hooks/useGeofenceExitMonitor.ts` shows booking-keyed Map
  </verify>
  <done>
    Hook exists with haversine distance calculation, booking-keyed geofence Map, and create_medic_alert RPC call for pings outside radius.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire geofence exit check into location store and command center</name>
  <files>
    web/stores/useMedicLocationsStore.ts
    web/app/admin/command-center/page.tsx
  </files>
  <action>
    **Modify `web/stores/useMedicLocationsStore.ts`:**

    Add an optional callback mechanism so external code can hook into ping processing:

    1. Add to `MedicLocationsState` interface:
       ```typescript
       onPingReceived: ((ping: { medic_id: string; booking_id: string; medic_name: string; site_name: string; latitude: number; longitude: number; ping_id?: string }) => void) | null;
       setOnPingReceived: (callback: ((ping: { medic_id: string; booking_id: string; medic_name: string; site_name: string; latitude: number; longitude: number; ping_id?: string }) => void) | null) => void;
       ```

    2. Initialize in store: `onPingReceived: null`

    3. Add setter:
       ```typescript
       setOnPingReceived: (callback) => set({ onPingReceived: callback }),
       ```

    4. In the `postgres_changes` INSERT handler for `medic_location_pings` (around line 207-226), AFTER the `get().updateLocation(...)` call, add:
       ```typescript
       // Notify external listeners (e.g., geofence exit monitor)
       const onPing = get().onPingReceived;
       if (onPing) {
         onPing({
           medic_id: ping.medic_id,
           booking_id: context?.booking_id ?? ping.booking_id,
           medic_name: context?.medic_name ?? 'Unknown Medic',
           site_name: context?.site_name ?? 'Unknown Site',
           latitude: ping.latitude,
           longitude: ping.longitude,
           ping_id: ping.id,
         });
       }
       ```

    **Modify `web/app/admin/command-center/page.tsx`:**

    1. Import the hook:
       ```typescript
       import { useGeofenceExitMonitor } from '@/hooks/useGeofenceExitMonitor';
       ```

    2. Add to component body (after existing store hooks):
       ```typescript
       const setOnPingReceived = useMedicLocationsStore((state) => state.setOnPingReceived);
       const { loadGeofences, checkPing } = useGeofenceExitMonitor();
       ```

    3. Add a useEffect that wires the geofence check into the ping stream:
       ```typescript
       useEffect(() => {
         // Load geofences once, then wire checkPing as the ping callback
         loadGeofences().then(() => {
           setOnPingReceived((ping) => {
             checkPing(
               ping.medic_id,
               ping.booking_id,
               ping.medic_name,
               ping.site_name,
               ping.latitude,
               ping.longitude,
               ping.ping_id
             );
           });
         });

         return () => {
           setOnPingReceived(null);
         };
       }, [loadGeofences, checkPing, setOnPingReceived]);
       ```

    IMPORTANT:
    - Do NOT modify any existing functionality in the stores — only ADD the callback mechanism
    - The callback is fire-and-forget (non-blocking)
    - checkPing errors are logged, not thrown
  </action>
  <verify>
    - `grep "onPingReceived" web/stores/useMedicLocationsStore.ts` shows callback mechanism
    - `grep "setOnPingReceived" web/stores/useMedicLocationsStore.ts` shows setter
    - `grep "useGeofenceExitMonitor" web/app/admin/command-center/page.tsx` shows hook usage
    - `grep "loadGeofences" web/app/admin/command-center/page.tsx` shows initialization
    - `pnpm build` completes without errors
  </verify>
  <done>
    Location store has onPingReceived callback. Command center loads geofences at mount time and wires checkPing into the ping stream. Any ping outside geofence radius triggers create_medic_alert RPC. Build passes.
  </done>
</task>

</tasks>

<verification>
- `useGeofenceExitMonitor` hook loads active geofences into a Map keyed by booking_id
- haversine distance calculation matches the DB function from migration 006
- Pings outside radius trigger `create_medic_alert('geofence_failure')` RPC
- Alert deduplication is handled by the DB function (15-minute window)
- Geofence check is non-blocking (errors logged, not thrown)
- Existing AlertPanel will show the new alerts automatically (useMedicAlertsStore subscribes to medic_alerts Realtime)
- `pnpm build` passes
</verification>

<success_criteria>
1. `useGeofenceExitMonitor` hook exists with haversine distance check and create_medic_alert RPC call
2. Location store has onPingReceived callback mechanism
3. Command center initializes geofence monitor and wires it to ping stream
4. Geofences loaded once at mount (not per ping) using Map for O(1) lookup
5. `pnpm build` passes cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/13-ux-polish/13-03-SUMMARY.md`
</output>
