import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';

export const dynamic = 'force-dynamic';

interface GenerateInvoiceRequest {
  clientId: string;
  bookingIds: string[];
  invoiceDate?: string;
}

export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // Verify user is admin
    const { data: profile } = await supabase
      .from('profiles')
      .select('role')
      .eq('id', user.id)
      .single();

    if (profile?.role !== 'admin') {
      return NextResponse.json({ error: 'Forbidden - Admin only' }, { status: 403 });
    }

    const body: GenerateInvoiceRequest = await request.json();
    const { clientId, bookingIds, invoiceDate } = body;

    if (!clientId || !bookingIds || bookingIds.length === 0) {
      return NextResponse.json(
        { error: 'clientId and bookingIds are required' },
        { status: 400 }
      );
    }

    // Fetch client details
    const { data: client, error: clientError } = await supabase
      .from('clients')
      .select('*')
      .eq('id', clientId)
      .single();

    if (clientError || !client) {
      return NextResponse.json(
        { error: 'Client not found', details: clientError?.message },
        { status: 404 }
      );
    }

    // Fetch bookings and validate
    const { data: bookings, error: bookingsError } = await supabase
      .from('bookings')
      .select('*')
      .in('id', bookingIds);

    if (bookingsError || !bookings || bookings.length === 0) {
      return NextResponse.json(
        { error: 'Bookings not found', details: bookingsError?.message },
        { status: 404 }
      );
    }

    // Validate bookings
    for (const booking of bookings) {
      if (booking.client_id !== clientId) {
        return NextResponse.json(
          { error: `Booking ${booking.id} does not belong to client ${clientId}` },
          { status: 400 }
        );
      }
      if (booking.status !== 'completed') {
        return NextResponse.json(
          { error: `Booking ${booking.id} is not completed (status: ${booking.status})` },
          { status: 400 }
        );
      }
    }

    // Check if any bookings are already invoiced
    const { data: existingLineItems } = await supabase
      .from('invoice_line_items')
      .select('booking_id')
      .in('booking_id', bookingIds);

    if (existingLineItems && existingLineItems.length > 0) {
      const alreadyInvoiced = existingLineItems.map((item: any) => item.booking_id);
      return NextResponse.json(
        { error: `Bookings already invoiced: ${alreadyInvoiced.join(', ')}` },
        { status: 400 }
      );
    }

    // Calculate totals
    const subtotal = bookings.reduce((sum: number, booking: any) => sum + parseFloat(booking.total), 0);
    const vat = subtotal * 0.20; // 20% UK VAT
    const total = subtotal + vat;

    // Calculate invoice and due dates
    const invDate = invoiceDate ? new Date(invoiceDate) : new Date();
    const dueDate = new Date(invDate);
    dueDate.setDate(dueDate.getDate() + 30); // Net 30

    // Insert invoice record (invoice_number will be auto-generated by trigger)
    const { data: invoice, error: invoiceError } = await supabase
      .from('invoices')
      .insert({
        client_id: clientId,
        subtotal,
        vat,
        total,
        invoice_date: invDate.toISOString().split('T')[0],
        due_date: dueDate.toISOString().split('T')[0],
        payment_terms: client.payment_terms,
        status: 'draft',
      })
      .select()
      .single();

    if (invoiceError || !invoice) {
      return NextResponse.json(
        { error: 'Failed to create invoice', details: invoiceError?.message },
        { status: 500 }
      );
    }

    // Insert invoice line items
    const lineItems = bookings.map((booking: any) => ({
      invoice_id: invoice.id,
      booking_id: booking.id,
      description: `Medic service - ${booking.site_name} on ${booking.shift_date}`,
      quantity: parseFloat(booking.shift_hours),
      unit_price: parseFloat(booking.total) / parseFloat(booking.shift_hours),
      amount: parseFloat(booking.total),
    }));

    const { error: lineItemsError } = await supabase
      .from('invoice_line_items')
      .insert(lineItems);

    if (lineItemsError) {
      // Rollback invoice
      await supabase.from('invoices').delete().eq('id', invoice.id);
      return NextResponse.json(
        { error: 'Failed to create line items', details: lineItemsError.message },
        { status: 500 }
      );
    }

    // Generate PDF via Edge Function
    const { data: pdfData, error: pdfError } = await supabase.functions.invoke(
      'generate-invoice-pdf',
      { body: { invoiceId: invoice.id } }
    );

    if (pdfError) {
      console.error('PDF generation failed:', pdfError);
      // Don't fail - invoice is created, PDF can be regenerated later
    }

    // TODO: Send invoice email via Resend
    // This will be implemented when email integration is added

    return NextResponse.json({
      success: true,
      invoice: {
        id: invoice.id,
        invoice_number: invoice.invoice_number,
        total,
        pdf_url: pdfData?.pdf_url || null,
      },
    });
  } catch (error: any) {
    console.error('Error generating invoice:', error);
    return NextResponse.json(
      { error: 'Internal server error', details: error?.message || 'Unknown error' },
      { status: 500 }
    );
  }
}
